<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OSTEP-1操作系统上的程序 | 代码手记</title><meta name="author" content="zyw9825"><meta name="copyright" content="zyw9825"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="课程资源  课程名称：《操作系统：设计与实现》（2022）——南京大学蒋炎岩老师   课程网站 课程视频 课程教材 课程作业   读书笔记  范围：  第 1 章：Dialogue 第 2 章：Introduction to Operating Systems    Introduction   当一个程序在运行时到底发生了什么？ 一个正在运行的程序只做一件非常简单的事情——执行指令： 处理器每秒">
<meta property="og:type" content="article">
<meta property="og:title" content="OSTEP-1操作系统上的程序">
<meta property="og:url" content="https://zyw9825.github.io/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="代码手记">
<meta property="og:description" content="课程资源  课程名称：《操作系统：设计与实现》（2022）——南京大学蒋炎岩老师   课程网站 课程视频 课程教材 课程作业   读书笔记  范围：  第 1 章：Dialogue 第 2 章：Introduction to Operating Systems    Introduction   当一个程序在运行时到底发生了什么？ 一个正在运行的程序只做一件非常简单的事情——执行指令： 处理器每秒">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/wukong.png">
<meta property="article:published_time" content="2023-04-20T14:12:13.000Z">
<meta property="article:modified_time" content="2023-04-20T14:15:47.026Z">
<meta property="article:author" content="zyw9825">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/wukong.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OSTEP-1操作系统上的程序",
  "url": "https://zyw9825.github.io/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/",
  "image": "https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/wukong.png",
  "datePublished": "2023-04-20T14:12:13.000Z",
  "dateModified": "2023-04-20T14:15:47.026Z",
  "author": [
    {
      "@type": "Person",
      "name": "zyw9825",
      "url": "https://zyw9825.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/book.svg"><link rel="canonical" href="https://zyw9825.github.io/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?08ead5bb7d005bd4116f0ec90195f830";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OSTEP-1操作系统上的程序',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/wukong.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/11ps.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">代码手记</span></a><a class="nav-page-title" href="/"><span class="site-name">OSTEP-1操作系统上的程序</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OSTEP-1操作系统上的程序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-20T14:12:13.000Z" title="发表于 2023-04-20 22:12:13">2023-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-20T14:15:47.026Z" title="更新于 2023-04-20 22:15:47">2023-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BAOSTEP/">操作系统导论OSTEP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="课程资源">课程资源</h1>
<ul>
<li>课程名称：《操作系统：设计与实现》（2022）——南京大学蒋炎岩老师</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/">课程网站</a></li>
<li><a target="_blank" rel="noopener" href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498">课程视频</a></li>
<li><a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/">课程教材</a></li>
<li><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/">课程作业</a></li>
</ul>
<hr>
<h1 id="读书笔记">读书笔记</h1>
<ul>
<li>范围：
<ul>
<li>第 1 章：<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-threeeasy.pdf">Dialogue</a></li>
<li>第 2 章：<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf">Introduction to Operating Systems</a></li>
</ul>
</li>
</ul>
<h2 id="Introduction">Introduction</h2>
<ul>
<li>
<p>当一个程序在运行时到底发生了什么？<br>
一个正在运行的程序只做一件非常简单的事情——<font color="#245bdb">执行指令</font>：<br>
处理器每秒数百万次或上亿次地从内存中获取指令，对其进行解码（即找出这到底是哪条指令），然后执行之（访问内存、检查条件、跳转函数等）。这条指令执行结束后，处理器就继续抓取下一条指令。重复上述过程直到整个程序结束。</p>
</li>
<li>
<p>什么是<font color="#c00000">操作系统</font>（OS）？<br>
操作系统是这样一个软件，它负责让程序运行变得更容易（甚至可以让你看起来同时运行很多程序），允许程序共享内存，允许程序与设备交互等等，它使得系统以易于使用的方式正确和有效地运行。<br>
操作系统 OS 早期被称作<font color="#245bdb">监督程序</font>（Supervisor）或者<font color="#245bdb">主控制程序</font>（Master Control Program）。</p>
</li>
<li>
<p>什么是<font color="#c00000">虚拟化</font>（Virtualization）?<br>
操作系统主要通过使用虚拟化这一通用技术来实现其自身功能，即操作系统获取物理资源（处理器、内存、磁盘等）并且将其转化为更通用、更强大、更易于使用的虚拟形式。因此，操作系统有时也被称作<font color="#245bdb">虚拟机</font>。<br>
操作系统还提供了一些供程序调用的接口（<font color="#245bdb">API</font>）来进行程序运行、访问内存和设备等操作，所以有时也说操作系统为应用程序提供了标准库。<br>
虚拟化允许众多程序共享 CPU，共享内存、共享磁盘等，所以操作系统有时也被认为是一个<font color="#245bdb">资源管理器</font>。</p>
</li>
</ul>
<h2 id="虚拟化">虚拟化</h2>
<ul>
<li>问题的关键在于：操作系统如何将资源虚拟化？<br>
操作系统需要哪些机制和策略来实现虚拟化？如何有效地实现虚拟化？需要哪些硬件支持？</li>
</ul>
<h3 id="虚拟化-CPU">虚拟化 CPU</h3>
<ul>
<li>将一个 CPU（或一小组 CPU）变成<u>看似</u>无限数量的 CPU，从而允许许多程序<u>看似</u>在同时运行，这就是<font color="#c00000">虚拟化 CPU</font> 。</li>
</ul>
<h3 id="虚拟化内存">虚拟化内存</h3>
<ul>
<li>
<p>现代机器的物理内存模型非常简单：<mark style="background: #BBFABBA6;">内存就是一个字节数组</mark>，读取、写入或更改内存必须指明存储地址。</p>
</li>
<li>
<p>只要运行程序，就必然要访问内存。程序里所有数据结构都存储在内存里，程序依靠执行各种指令来访问它们。当然，指令也会保存在内存中，处理器在抓取指令时也要访问内存。</p>
</li>
<li>
<p>操作系统<font color="#c00000">虚拟化内存</font>：每个正在运行的程序都有自己的<font color="#245bdb">私有虚拟地址空间</font>，操作系统以某种方式将其映射到真实的物理内存上。正在运行的多个程序的内存彼此之间不会影响。</p>
</li>
</ul>
<blockquote>
<p>它使得应用程序认为自己拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
</blockquote>
<h2 id="并发">并发</h2>
<ul>
<li>
<p><font color="#c00000">并发（Concurrency）</font>这个概念术语用来指代在同一程序中同时（即并发）处理许多事情时出现的、必须解决的一系列问题。</p>
</li>
<li>
<p>并发产生的问题首先出现在操作系统自身内部，而多线程程序也存在同样的问题。</p>
</li>
<li>
<p>你可以将一个线程看作与其他函数运行在同一内存空间中的函数，同一时间内它们至少有一个在运行。</p>
</li>
<li>
<p>多线程程序同时工作在同一块内存空间上，可能会得到一些不正常的结果。事实证明，这些奇怪和不寻常的结果的原因与指令的执行方式有关。比如多个线程共享一个计数器，计数器递增需要三个指令：首先将计数器的值从内存加载到寄存器中，然后执行运算将值递增，最后将值再写入内存。因为这 3 条指令不是以<font color="#245bdb">原子方式</font>（atomically）执行（所有的指令一次性执行）的，所以会发生意想不到的结果。</p>
</li>
<li>
<p>问题的关键在于：如何构建正确的并发程序？<br>
当多个线程同时在同一内存空间执行时，我们该如何构建一个正确工作的程序？操作系统需要哪些原语？硬件应该提供何种机制？如何利用它们去解决并发问题？</p>
</li>
</ul>
<h2 id="持久性">持久性</h2>
<ul>
<li>
<p>在系统内存中，数据很容易丢失，许多设备比如 <font color="#245bdb">DRAM (Dynamic Random Access Memory 动态随机存取存储器) </font>以一种不稳定的方式来存储数据。当电源关闭或者系统崩溃时，内存中的所有数据都会丢失。因此，我们需要硬件和软件能够持续存储数据。</p>
<blockquote>
<p>DRAM 是一种半导体存储器，利用电容内存储电荷的多少来代表一个二进制比特（bit）是 1 还是 0。现实中晶体管存在漏电现象，导致电容上所存储的电荷数量并不足以正确的判别数据，从而导致数据毁损。 DRAM 必须周期性地充电，由于这种需要定时刷新的特性，因此被称为“动态”存储器。相对来说，静态存储器（SRAM）只要存入数据后，纵使不刷新也不会丢失数据。</p>
</blockquote>
</li>
<li>
<p>硬件通常以某种输入/输出或 I/O 设备的形式出现，被用来存储长期保存的信息。常见的有<font color="#245bdb">硬盘驱动器</font>和<font color="#245bdb">固态驱动器（SSD）</font>。</p>
</li>
<li>
<p><mark style="background: #BBFABBA6;"> 操作系统中管理磁盘的软件被称为<font color="#245bdb">文件系统</font>，负责以可靠和高效的方式在磁盘上存储任何用户创建的文件。</mark></p>
</li>
<li>
<p>与操作系统为 CPU 和内存提供的<font color="#245bdb">抽象</font>不同，操作系统不会为每个程序都创建专用的虚拟磁盘，而是假设用户需要的是共享文件中的信息。以编写 C 程序为例，首先使用编辑器创建和编辑一个 C 文件，然后用编译器将源代码转换为可执行文件，最后再运行这个可执行文件。在这个过程中，文件在不同的进程之间进行共享。</p>
</li>
<li>
<p>操作系统为了将数据实际写入磁盘到底做了什么？</p>
<p>文件系统必须做很多工作：首先要确定新数据要存储在磁盘的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这个过程需要向底层存储设备发出 I/O 请求，以读取现有结构或者更新它们。操作系统提供了一个通过系统调用来访问设备的标准和简单方法，使人们不必再深入了解底层设备接口及其语义。所以，OS 有时也被视为<font color="#245bdb">标准库</font>（standard library）。</p>
</li>
<li>
<p>出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如<font color="#245bdb">日志</font>（journaling）或<font color="#245bdb">写时复制</font>（copy-on-write），仔细排序写入磁盘的操作以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。</p>
</li>
<li>
<p>问题的关键在于：如何持久地存储数据？</p>
<p>文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？</p>
</li>
</ul>
<h2 id="操作系统的设计目标">操作系统的设计目标</h2>
<ul>
<li>操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期随全。鉴于我们希望建立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现，甚在必要时进行折中。</li>
</ul>
<ol>
<li>
<p>一个最基本的目标，是建立一些<font color="#245bdb">抽象</font>（abstraction），让系统方便和易于使用。</p>
<p>抽象使得编写一个大型程序成为可能，用 C 这样的高级语言编写程序不用考虑汇编，用汇编写代码不用考虑逻辑门，用逻辑门来构建处理器不用太多考虑晶体管。抽象是如此重要，有时我们会忘记它的重要性。</p>
</li>
<li>
<p>设计和实现操作系统的一个目标，是提供高性能（performance）。换言之，我们的目标是最小化操作系统的<font color="#245bdb">开销</font>（minimize the overhead）。</p>
<p>虚拟化和让系统易于使用不会不计较成本。开销以多种形式出现：<font color="#245bdb">额外时间</font>（更多指令）和<font color="#245bdb">额外空间</font>（内存或磁盘上）。完美并非总是可以实现的，我们应当寻求解决方案，尽量减少其中的一种或者两种。</p>
</li>
<li>
<p>另一个目标是在应用程序之间以及在 OS 和应用程序之间提供保护（protection）。</p>
<p>当多个程序同时运行时，必须确保某一个程序的不良行为无法损害其他程序。程序也不应损害操作系统本身，这会影响系统上运行的所有程序。保护是操作系统基本原理的一个核心就是<font color="#245bdb">隔离</font>（isolation），让进程彼此隔离是保护的关键。</p>
</li>
<li>
<p>操作系统也必须不间断运行。操作系统往往力求提供高度的可靠性（reliability）。</p>
</li>
<li>
<p>其他目标：能源效率（energy-efficiency）、安全性（security）、移动性（mobility）等。</p>
</li>
</ol>
<h1 id="课堂笔记">课堂笔记</h1>
<h2 id="什么是操作系统？">什么是操作系统？</h2>
<ol>
<li>课本定义：</li>
</ol>
<blockquote>
<p>Operating System: A body of software, in fact, that is responsible for <em>making it easy to run programs</em> (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p>
</blockquote>
<ol start="2">
<li>“管理软/硬件资源、为程序提供服务”的<u>程序</u>。</li>
<li>“精准”的定义毫无意义，本课程讨论<font color="#c00000">狭义的操作系统</font>：
<ul>
<li><mark style="background: #BBFABBA6;">对单一计算机硬件系统作出抽象、支撑程序执行的软件系统</mark>；</li>
<li>学术界谈论 “操作系统” 是更广义的 “System” (例子：OSDI/SOSP)、</li>
</ul>
</li>
<li>操作系统没有传说中那么复杂：
<ul>
<li>应用视角（设计）：一组对象（进程/文件） + API</li>
<li>硬件视角（实现）：一个 C 程序</li>
</ul>
</li>
</ol>
<h2 id="理解操作系统">理解操作系统</h2>
<ol>
<li>操作系统服务谁？
<ul>
<li><mark style="background: #BBFABBA6;">程序 = 状态机</mark></li>
</ul>
</li>
<li>(设计/应用视角) 操作系统为程序提供什么服务？
<ul>
<li><mark style="background: #BBFABBA6;">操作系统 = 对象 + API</mark></li>
</ul>
</li>
<li>(实现/硬件视角) 如何实现操作系统提供的服务？
<ul>
<li><mark style="background: #BBFABBA6;">操作系统 = C 程序</mark></li>
</ul>
</li>
</ol>
<h2 id="操作系统上的程序">操作系统上的程序</h2>
<ul>
<li>操作系统有三条主线：“软件 (应用)”、“硬件 (计算机)”、“操作系统 (软件直接访问硬件带来麻烦太多而引入的中间件)”。想要理解操作系统，对操作系统的服务对象——应用程序，有精确的理解是必不可少的。</li>
<li>本次课回答的主要问题：到底什么是程序？</li>
<li>本次课的主要内容：
<ol>
<li>程序的状态机模型 (和编译器)</li>
<li>操作系统上的 {最小/一般/图形} 程序</li>
</ol>
</li>
</ul>
<h3 id="数字电路与状态机">数字电路与状态机</h3>
<ul>
<li>
<p><font color="#c00000">时钟周期</font></p>
<ul>
<li>也称为<font color="#245bdb">震荡周期</font>，定义为时钟频率的倒数。<u>更小</u>的时钟周期意味着<u>更高</u>的工作频率。</li>
<li>时钟周期是计算机中 CPU 工作最基本的、最小的时间单位。</li>
<li>在一个时钟周期内，CPU 仅能完成一个最基本的动作。</li>
<li>在单个时钟周期内，逻辑 0 状态与逻辑 1 状态来回切换。</li>
</ul>
</li>
<li>
<p><font color="#c00000">状态机</font></p>
<ul>
<li>状态机由<font color="#245bdb">状态寄存器</font>和<font color="#245bdb">组合逻辑电路</font>组成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。</li>
<li>状态机就是<font color="#245bdb">状态转移图</font>。它是一个有向图形，由一组节点和一组相应的转移函数组成。状态机通过响应一系列事件而”运行“。这些节点中至少有一个必须是<font color="#245bdb">终态</font>。当到达终态，状态机停止。</li>
<li>状态机模型：
<ul>
<li>状态：寄存器保存的值</li>
<li>初始状态：状态机 RESET 后的值</li>
<li>迁移：组合逻辑电路计算寄存器下一周期的值</li>
</ul>
</li>
</ul>
</li>
<li>
<p><font color="#c00000">数字电路</font></p>
<ul>
<li>用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路。由于它具有逻辑运算和逻辑处理功能，所以又称<font color="#245bdb">数字逻辑电路</font>。</li>
<li><font color="#245bdb">逻辑门</font>是数字逻辑电路的基本单元。<font color="#245bdb">存储器</font>是用来存储二进制数据的数字电路。</li>
<li>从整体上看，数字电路可以分为<font color="#245bdb">组合逻辑电路</font>和<font color="#245bdb">时序逻辑电路</font>两大类。</li>
<li>组合逻辑电路由最基本的逻辑门电路组合而成，输出值只与当时的输入值有关，电路没有记忆功能，输出状态随着输入状态的变化而变化。</li>
<li>时序逻辑电路由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成，输出不仅取决于当时的输入值，而且还与电路过去的状态有关，具有记忆功能。如触发器、锁存器、计数器、移位寄存器、储存器等电路都是时序电路的典型器件。</li>
</ul>
</li>
</ul>
<h3 id="什么是程序（C-程序的语义）">什么是程序（C 程序的语义）</h3>
<ul>
<li>
<p><mark style="background: #BBFABBA6;">程序就是状态机</mark></p>
</li>
<li>
<p>C 程序的状态机模型：</p>
<ul>
<li>状态 = stack frame 的列表 (每个 frame 有 PC) + 全局变量</li>
<li>初始状态 = 仅有一个 frame: <code>main(argc, argv)</code> ；全局变量为初始值</li>
<li>迁移 = 执行 top stack frame PC 的语句; PC++
<ul>
<li>函数调用 = push frame (frame. PC = 入口)</li>
<li>函数返回 = pop frame</li>
</ul>
</li>
</ul>
</li>
<li>
<p>应用：将任何递归程序就地转为非递归</p>
<ul>
<li>
<p>汉诺塔-递归：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, from, to);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    hanoi(n - <span class="number">1</span>, from, via, to);</span><br><span class="line">    hanoi(<span class="number">1</span>,     from, to,  via);</span><br><span class="line">    hanoi(n - <span class="number">1</span>, via,  to,  from);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>汉诺塔-非递归：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pc, n;</span><br><span class="line">  <span class="type">char</span> from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret()     (&#123; top--; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;</span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="keyword">goto</span>(<span class="number">4</span>); &#125; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(n - <span class="number">1</span>, from, via, to);   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(    <span class="number">1</span>, from, to,  via);  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(n - <span class="number">1</span>, via,  to,  from); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>递归版本的汉诺塔是程序设计中的经典例题——理解这个程序可能会遇到困难。这种根本性的困难在于，大家可能并没有建立 “函数调用”、“函数返回” 和 “单步执行” 的正确模型。如果我们清楚地认识到所谓<mark style="background: #BBFABBA6;">单步执行，指的是从顶部的栈帧 PC 取一条指令执行</mark>，就不难用栈模拟递归程序。</p>
</li>
<li>
<p>此外，我们也可以用类似汉诺塔的方法把 C 语言改写成仅包含顺序执行的简单语句和条件跳转 <code>if (cond) goto</code> 的 “简化 C 语言代码”——循环、分支和函数调用都被消灭了。这时候，我们的 C 代码已经可以逐条翻译成汇编指令了。这也是为什么 C 语言被称为 “高级的汇编语言”——我们几乎总是能从 C 语言的语法层面对应到机器指令序列。</p>
</li>
</ul>
<h3 id="什么是程序（机器代码语义）">什么是程序（机器代码语义）</h3>
<ul>
<li>汇编代码的状态机模型：
<ul>
<li><mark style="background: #BBFABBA6;"><font color="#245bdb">状态 = 内存 M + 寄存器 R</font></mark></li>
<li>初始状态 = ABI 规定（例如有一个合法的 %rsp）</li>
<li>状态迁移 = 执行一条指令</li>
</ul>
</li>
</ul>
<blockquote>
<p>ABI：每个操作系统都会为运行在该系统下的应用程序提供<font color="#245bdb">应用程序二进制接口</font>（Application Binary Interface，ABI）。ABI 包含了应用程序在这个系统下运行时必须遵守的编程约定。ABI 总是包含一系列的<font color="#245bdb">系统调用</font>和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。<br>
%rsp：栈指针，指向栈最底部 (其实是平常所说的栈顶)元素。</p>
</blockquote>
<ul>
<li>
<p><mark style="background: #BBFABBA6;">操作系统上的程序绝大多数的指令都是单纯的计算</mark>，即从 (M, R)通过计算得到 (M’, R’)，从一个状态迁移到另一个状态。但仅有这些指令甚至都无法使程序停下来。</p>
</li>
<li>
<p><mark style="background: #BBFABBA6;">一条特殊的指令：<font color="#c00000">syscall</font>（操作系统调用）</mark></p>
<ul>
<li>把 (M, R) （所有状态）完全交给操作系统，任其修改；</li>
</ul>
<ul>
<li>实现与操作系统中的其他对象交互：
<ul>
<li>读写文件/操作系统状态 (例如把文件内容写入 M)</li>
<li>改变进程 (运行中状态机) 的状态，例如创建进程/销毁自己</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对操作系统上程序的一个很重要的理解是<mark style="background: #BBFABBA6;">程序是<font color="#245bdb">计算</font>和<font color="#245bdb">系统调用</font>组成的状态机</mark>；</p>
<ul>
<li><mark style="background: #BBFABBA6;"><font color="#c00000">程序 = 计算 + syscall</font></mark></li>
<li>大部分计算指令都是<font color="#245bdb">确定性</font> (deterministic，在相同环境下执行的结果总是相同) 的</li>
<li>少部分指令 (如 rdrand 返回随机数) 则有<font color="#245bdb">非确定</font>的结果。</li>
<li>系统调用指令 syscall 是非确定性的，操作系统可能会将计算机运行环境中的信息，例如来自设备的输入传递到程序中。</li>
</ul>
</li>
<li>
<p>操作系统上的所有程序本质还是计算，不管是编译器、浏览器、图形界面都是如此。比如你需要用绘图软件创作一张图片，绘图软件实际上要去计算一个二维的 rgb 数组，每个 rgb 的值是可以计算出来的。但是如果想把图片显示出来，这件事情进程本身是做不到的，进程就需要在适当的时候请求操作系统，将内存中的图片显示出来，操作系统具体做了什么来完成这个任务对于程序来说并不重要。</p>
</li>
</ul>
<h3 id="构造最小的-Hello-World">构造最小的 Hello World</h3>
<ul>
<li>
<p>为了理解操作系统上的程序，我们的目标是<font color="#c00000">构造一个能直接被操作系统加载且打印 Hello World 的指令序列。</font></p>
<ul>
<li>
<p>在失败的尝试中，我们直接为 main 函数返回 0，并直接将可执行文件的入口地址设置为 main 的第一条指令。函数可以被执行，但从 main 函数返回会导致 <font color="#245bdb">Segmentation Fault</font>。</p>
</li>
<li>
<p>在成功的尝试中，我们<font color="#245bdb">直接编写汇编代码</font>执行<font color="#245bdb">系统调用</font>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="编译器">编译器</h4>
<ul>
<li>
<p>用 C 语言编写程序时，编写的内容被储存在文本文件中，即<font color="#245bdb">源代码文件</font>（source code file），文件名一般以. C 结尾。C 语言编程的基本策略是用程序（<font color="#245bdb">编译器</font>）把源代码文件转换为<font color="#245bdb">可执行文件</font>（可以直接运行的机器语言代码），一般通过<font color="#245bdb">编译</font>和<font color="#245bdb">链接</font>两个步骤来完成这项任务。</p>
</li>
<li>
<p>我们有两种状态机：</p>
<ul>
<li>高级语言代码 .c
<ul>
<li>状态：栈、全局变量；</li>
<li>状态迁移：语句执行；</li>
</ul>
</li>
<li>汇编指令序列 .s
<ul>
<li>状态：(M,R)；</li>
<li>状态迁移：指令执行；</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编译器是二者之间的桥梁：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi>s</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">.s = compile(.c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi>s</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">.s = compile(.c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> 编译优化的正确性判断：.c 执行中的所有外部观测者可见的行为，必须在.s 中保持一致。</p>
</li>
<li>
<p>现代（与未来的）编译优化：在保证观测一致性（sound）的前提下改写代码（rewriting）</p>
</li>
</ul>
<h4 id="C-语言程序的执行流程：">C 语言程序的执行流程：</h4>
<ol>
<li>源代码首先发送到<font color="#245bdb">预处理器</font>（processor），预处理器负责将预处理指令转换为各自的值。预处理器生成<font color="#92d050">扩展的源代码</font>（Expanded source code）。</li>
<li>扩展的源代码发送到<font color="#245bdb">编译器</font>（Complier），编译代码并将其转换为<font color="#92d050">汇编代码</font>（Assembly code）。</li>
<li>汇编代码被发送到<font color="#245bdb">汇编器</font>（Assembler），将其转换成<font color="#92d050">目标代码</font>（Object Code），目标代码一般由机器代码组成。目标代码缺少<font color="#92d050">启动代码</font>（startup code），启动代码充当着程序和操作系统之间的接口。目标代码还缺少<font color="#92d050">库函数</font>。</li>
<li>目标代码被发送到<font color="#245bdb">链接器</font>（linker），链接器的作用是将<u>目标代码</u>、<u>系统的标准启动代码</u>和<u>库函数的代码</u>这三部分合并成一个<font color="#92d050">可执行文件</font>。</li>
<li>可执行代码发送到<font color="#245bdb">加载器</font>（loader），将其加载到内存中，然后执行，并将输出发送到控制台。</li>
</ol>
<ul>
<li>文件扩展名的转换：.c—.I—.s—.o—.exe（Linux 环境下是.out）</li>
</ul>
<h4 id="失败的尝试">失败的尝试</h4>
<ul>
<li>
<p>一个简单的 Hello World 程序 hello.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p>直接编译运行它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c &amp;&amp; ./a.out 	<span class="comment">#a.out是“assembler output”（汇编程序输出）的缩写形式</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gcc 编译出来的文件不满足 “最小”：</p>
<ul>
<li><code>$ gcc --verbose hello.c</code><br>
打印出编译连接时的详细信息，会看到 gcc 在编译它时用了很多的编译选项，而且编译和链接的过程非常复杂。</li>
<li><code>-static</code> 选项可以静态链接程序，即不需要再运行时依赖<font color="#245bdb">动态库</font>（dynamic libraries）</li>
</ul>
</li>
<li>
<p>查看 hello. C 的汇编代码，使用 <code>gcc -c </code> 就可以仅仅编译程序而不链接，objdump 工具可以查看对应的汇编代码。会看到代码非常短：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64</span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        <span class="comment"># f &lt;main+0xf&gt;</span></span><br><span class="line">   f:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;</span><br><span class="line">  17:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  1c:   5d                      pop    %rbp</span><br><span class="line">  1d:   c3                      ret</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>能不能直接链接这段代码呢？试试<u>强行编译+链接</u>：gcc -c + ld</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o &amp;&amp; ld hello.o</span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000</span><br><span class="line">ld: hello.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.c:(.text+0x13): undefined reference to `puts&#x27;</span></span><br></pre></td></tr></table></figure>
<p>首先报了一个不能找到汇编程序入口<code>_start</code>的 warning，这个警告其实是可以避免的，需要修改hello.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来试一下：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o &amp;&amp; ld hello.o</span><br><span class="line">ld: hello.o: <span class="keyword">in</span> <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.c:(.text+0x13): undefined reference to `puts&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还是会提示编译器无法找到 <code>puts</code> 的定义。</p>
<p>强行编译+链接失败了，这是因为 ld 不知道怎么链接库函数。如果把源代码中的 printf ()函数去掉，只留下一个空的函数呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;Hello World\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o &amp;&amp; ld hello.o</span><br><span class="line">$ ./a.out</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>可以看到，只有一个空的函数的 hello.c 程序是可以强行编译+链接而不报错的，但要执行它时，会报一个 <code>Segmentation fault</code>，即<font color="#245bdb">存储器段错误</font>，意思是程序企图访问 CPU 无法定址的存储器区块，也称<font color="#245bdb">访问权限冲突</font>。 <code>Segmentation fault</code> 出现的原因实际上因为<font color="#92d050">进程的初始状态是不能返回的</font>。</p>
</li>
<li>
<p>使用 GDB 调试找出错误的原因：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gdb a.out</span><br><span class="line">(gdb) starti	<span class="comment"># 开始执行程序，在第一条指令处会停下来</span></span><br><span class="line">Starting program: /home/imp/a.out</span><br><span class="line"></span><br><span class="line">Program stopped.</span><br><span class="line">0x0000000000401000 <span class="keyword">in</span> _start ()</span><br><span class="line">(gdb) layout asm	<span class="comment"># 分割窗口，显示汇编窗口</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230417165516545.png" alt="image-20230417165516545"></p>
<p>问题出在这条 ret 指令。在 CPU 中，寄存器 <font color="#245bdb">rip</font> 保存下一条执行指令的地址，寄存器 <font color="#245bdb">rbp</font> 保存的是栈中当前执行函数的基本地址，而 <font color="#245bdb">rsp</font> 就是所谓的栈指针，它永远指向一个进程的栈顶。假设函数调用链: <code>A()-&gt;B()-&gt;C()</code>, 并且正在执行函数 <code>C()</code>，则 rsp 和 rbp 指向的位置如图：</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230417171751872.png" alt="image-20230417171751872"></p>
<p>call 指令执行函数调用，ret 指令则用于从被调用函数返回到调用函数。比如，当 C 函数执行完时，此时 rsp 就会指向 <code>C函数执行完返回B的地址</code>。此时 ret 指令执行，它会把 rsp 的值赋值给 rip，然后使 rsp 的值自增。</p>
</li>
<li>
<p>解决异常退出：让状态机停下来的解决方法：<font color="#c00000">syscall</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  syscall(SYS_exit, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="成功的尝试（汇编代码直接执行系统调用）">成功的尝试（汇编代码直接执行系统调用）</h4>
<ul>
<li>
<p>minimal.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   // write(</span><br><span class="line">  movq $1,         %rdi   //   fd=1,</span><br><span class="line">  movq $st,        %rsi   //   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   //   count=ed-st</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   // exit(</span><br><span class="line">  movq $1,         %rdi   //   status=1</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译+链接：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi minimal.S</span><br><span class="line">imp@xiaoxin:~$ gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">imp@xiaoxin:~$ ./a.out</span><br><span class="line">Hello, OS World		<span class="comment"># 这个Hello, OS World实际会是红色的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>回顾：状态机视角的程序</p>
<p>程序 = 计算 → syscall → 计算 → syscall …</p>
</li>
</ul>
<h3 id="操作系统中的一般程序">操作系统中的一般程序</h3>
<ul>
<li>任何程序=minimal.S=调用 syscall 的状态机</li>
<li><mark style="background: #BBFABBA6;">操作系统收编了<font color="#245bdb">所有的硬件/软件资源</font>，只能用操作系统允许的方式（API）访问操作系统中的<font color="#245bdb">对象</font>（软硬件资源），这是为”管理多个状态机“所必须的。</mark></li>
<li>可执行文件
<ul>
<li>与大家日常使用的文件没有本质区别</li>
<li>操作系统提供 API 打开、读取、改写（需要相应的权限）</li>
</ul>
</li>
<li>查看可执行文件：vim，cat，xxd
<ul>
<li><code>vim</code> 中二进制的部分无法 “阅读”，但可以看到字符串常量</li>
<li>使用 <code>xxd</code> 可以看到文件以 <code>&quot;\x7f&quot; &quot;ELF&quot;</code> 开头</li>
<li>vscode 有 binary editor 插件</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>系统中常见的程序（分三个等级）
<ul>
<li><font color="#245bdb">Core Utilities</font> (coreutils)
<ul>
<li><em>Standard</em> programs for text and file manipulation（文本与文件操作标准程序）</li>
<li>系统中安装的是 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/coreutils/">GNU Coreutils</a>，有较小的替代品 <a target="_blank" rel="noopener" href="https://www.busybox.net/">busybox</a></li>
</ul>
</li>
<li><font color="#245bdb">系统/工具程序</font>
<ul>
<li>ash, <a target="_blank" rel="noopener" href="https://www.gnu.org/software/binutils/">binutils</a>, apt, ip, ssh, vim, tmux, jdk, python</li>
</ul>
</li>
<li><font color="#245bdb">其他各种应用程序</font>
<ul>
<li>浏览器、音乐播放器等</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="strace（追踪）"><a target="_blank" rel="noopener" href="https://strace.io/">strace</a>（追踪）</h3>
<ul>
<li>
<p><strong><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/strace.1.html">strace</a></strong> is a diagnostic, debugging and instructional user space utility for Linux. It is used to monitor and tamper with interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state.</p>
</li>
<li>
<p>strace 是一个非常重要的命令行工具，帮助我们 “观测” 应用程序和操作系统的边界。实际上，任何程序的执行就是状态机在计算机上的运行，因此 “用合适的方式观测状态机执行” 就是我们理解程序的根本方法。</p>
</li>
<li>
<p>一个小 Demo：</p>
<ul>
<li>
<p>hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用 strace 查看可执行文件a.out 执行后的系统调用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./a.out</span><br><span class="line">execve(<span class="string">&quot;./a.out&quot;</span>, [<span class="string">&quot;./a.out&quot;</span>], 0x7ffeefaeeb50 /* 27 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x557621d70000</span><br><span class="line">arch_prctl(0x3001 /* ARCH_??? */, 0x7ffded6d0ff0) = -1 EINVAL (Invalid argument)mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3c998a7000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">newfstatat(3, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=16915, ...&#125;, AT_EMPTY_PATH) = 0mmap(NULL, 16915, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f3c998a2000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line"><span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\237\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">pread64(3, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., 784, 64) = 784</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0 \0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&quot;</span>..., 48, 848) = 48</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0i8\235HZ\227\223\333\350s\360\352,\223\340.&quot;</span>..., 68, 896) = 68</span><br><span class="line">newfstatat(3, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=2216304, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">pread64(3, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., 784, 64) = 784</span><br><span class="line">mmap(NULL, 2260560, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f3c9967a000mmap(0x7f3c996a2000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7f3c996a2000</span><br><span class="line">mmap(0x7f3c99837000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7f3c99837000</span><br><span class="line">mmap(0x7f3c9988f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x214000) = 0x7f3c9988f000</span><br><span class="line">mmap(0x7f3c99895000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f3c99895000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3c99677000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7f3c99677740) = 0</span><br><span class="line">set_tid_address(0x7f3c99677a10)         = 857</span><br><span class="line">set_robust_list(0x7f3c99677a20, 24)     = 0</span><br><span class="line">rseq(0x7f3c996780e0, 0x20, 0, 0x53053053) = 0</span><br><span class="line">mprotect(0x7f3c9988f000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x557620169000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x7f3c998e1000, 8192, PROT_READ) = 0</span><br><span class="line">prlimit64(0, RLIMIT_STACK, NULL, &#123;rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY&#125;) = 0</span><br><span class="line">munmap(0x7f3c998a2000, 16915)           = 0</span><br><span class="line">newfstatat(1, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">getrandom(<span class="string">&quot;\x96\x5b\x8b\xcd\xd4\x7d\xdb\x18&quot;</span>, 8, GRND_NONBLOCK) = 8</span><br><span class="line">brk(NULL)                               = 0x557621d70000</span><br><span class="line">brk(0x557621d91000)                     = 0x557621d91000</span><br><span class="line">write(1, <span class="string">&quot;hello world\n&quot;</span>, 12hello world</span><br><span class="line">)           = 12</span><br><span class="line">exit_group(12)                          = ?</span><br><span class="line">+++ exited with 12 +++</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>本质上，所有的程序和 Hello World 类似：程序 = 计算 → syscall → 计算 → syscall …</p>
<ol>
<li>被系统加载：通过另一个进程执行 execve 设置为初始状态（可以看上面 strace 后的第一个系统调用就是 execve）</li>
<li>状态机执行
<ul>
<li>进程管理：fork, execve, exit, …</li>
<li>文件/设备管理：open, close, read, write, …</li>
<li>存储管理：mmap, brk, …</li>
</ul>
</li>
<li>直到 _exit (exit_group) 退出</li>
</ol>
</li>
<li>
<p>所有的程序，包括浏览器、游戏、杀毒软件、病毒等等，都是在调用这些操作系统提供的 API。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>动手实验：观察程序的执行</p>
<ul>
<li>
<p>工具程序代表：编译器 (gcc)</p>
<ul>
<li>
<p>主要的系统调用：execve, read, write</p>
</li>
<li>
<pre><code class="language-sh">  $ strace -f gcc a.c
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      (gcc 会启动其他进程)</span><br><span class="line"></span><br><span class="line">        - 可以管道给编辑器 `vim -`</span><br><span class="line">        - 编辑器里还可以 `%!grep` (细节/技巧)</span><br><span class="line"></span><br><span class="line">* 图形界面程序代表：编辑器 (xedit)</span><br><span class="line"></span><br><span class="line">    - 主要的系统调用：poll, recvmsg, writev</span><br><span class="line"></span><br><span class="line">    - ```sh</span><br><span class="line">		$ strace xedit</span><br></pre></td></tr></table></figure>

  - 图形界面程序和 X-Window 服务器按照 X11 协议通信
  - 虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Hos

</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<p>各式各样的应用程序都在操作系统 API (syscall) 和操作系统中的对象上构建:</p>
<ul>
<li>
<p>窗口管理器</p>
<ul>
<li>管理设备和屏幕 (read/write/mmap)</li>
<li>进程间通信 (send, recv)</li>
</ul>
</li>
<li>
<p>任务管理器</p>
<ul>
<li>访问操作系统提供的进程对象 (readdir/read)</li>
<li>参考 gdb 里的 <code>info proc *</code></li>
</ul>
</li>
<li>
<p>杀毒软件</p>
<ul>
<li>文件静态扫描 (read)</li>
<li>主动防御 (ptrace)</li>
<li>其他更复杂的安全机制……</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>本次课回答的问题：到底什么是 “程序”？</p>
<hr>
<p>Take-away message</p>
<ul>
<li>程序 = 状态机
<ul>
<li>源代码 <em>S</em>: 状态迁移 = 执行语句</li>
<li>二进制代码 <em>C</em>: 状态迁移 = 执行指令</li>
<li>编译器 C*=compile(*S)</li>
</ul>
</li>
<li>应用视角的操作系统
<ul>
<li>就是一条 syscall 指令</li>
</ul>
</li>
<li>计算机系统不存在玄学；一切都建立在确定的机制上
<ul>
<li>理解操作系统的重要工具：gcc, binutils, gdb, strace</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zyw9825.github.io">zyw9825</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zyw9825.github.io/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/">https://zyw9825.github.io/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zyw9825.github.io" target="_blank">代码手记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/wukong.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/" title="数据结构-6 图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构-6 图</div></div><div class="info-2"><div class="info-item-1">图的存储结构 图的顺序存储结构——邻接矩阵 12345678910typedef struct &#123;		int no;							//顶点编号，表示它的位置	char info;						//顶点的其他辅助信息，没有的话可以删除&#125;VertexType;	 //顶点		typedef struct&#123;			int edges[maxSize][maxSize];	//顶点之间的相邻关系（无权值：1表示相通，0表示不相通）（有权值：∞表示不相通，其它为权值）	int vexnum, arcnum;				//总顶点数和总边数	VertexType vex[maxSize];		//存放图中的所有顶点&#125;MGraph;		//图 图的链式存储结构——邻接链表 123456789101112131415161718//边——结点typedef struct ArcNode &#123;	int adjvex;					//该边所指顶点的位置	struct ArcNode *nextArc;	//指向下一条边的指针	int...</div></div></div></a><a class="pagination-related" href="/2023/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" title="CSAPP-1计算机系统漫游"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CSAPP-1计算机系统漫游</div></div><div class="info-2"><div class="info-item-1">课程资源汇总：  CSAPP视频课 课程网址 书籍下载   计算机系统漫游 信息就是位+上下文   hello.c 123456#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;hello, world\n&quot;);    return O;&#125;   hello 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编译器创建并保存的文本文件 hello.c。  源程序实际上由 0 和 1 组成的比特序列，每 8 位称为一个字节。每个字节表示程序中的某些文本字符。 大部分现代计算机系统都是用 ASCII 标准来表示文本字符，即用唯一的一个单字节大小（8bit）表示的整数来表示每一个字符。 hello.c 程序以字节序列的方式存储在文件中。 像 hello.c 这样只由 ASCII...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/bg/BG/wukong.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zyw9825</div><div class="author-info-description">你且迷这风浪永远二十赶朝暮</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zyw9825"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zyw9825" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zyw_9825@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=765830653&amp;website=www.oicqzone.com" target="_blank" title="添加QQ好友"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">课程资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"><span class="toc-number">2.</span> <span class="toc-text">读书笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96-CPU"><span class="toc-number">2.2.1.</span> <span class="toc-text">虚拟化 CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">虚拟化内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">2.3.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">持久性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">2.5.</span> <span class="toc-text">操作系统的设计目标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0"><span class="toc-number">3.</span> <span class="toc-text">课堂笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是操作系统？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">理解操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">操作系统上的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">数字电路与状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%EF%BC%88C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%AD%E4%B9%89%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">什么是程序（C 程序的语义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E8%AF%AD%E4%B9%89%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">什么是程序（机器代码语义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%9A%84-Hello-World"><span class="toc-number">3.3.4.</span> <span class="toc-text">构造最小的 Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">编译器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">C 语言程序的执行流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%B0%9D%E8%AF%95"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">失败的尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%8A%9F%E7%9A%84%E5%B0%9D%E8%AF%95%EF%BC%88%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">成功的尝试（汇编代码直接执行系统调用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E8%88%AC%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.3.5.</span> <span class="toc-text">操作系统中的一般程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strace%EF%BC%88%E8%BF%BD%E8%B8%AA%EF%BC%89"><span class="toc-number">3.3.6.</span> <span class="toc-text">strace（追踪）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/" title="小波变换">小波变换</a><time datetime="2025-05-22T01:54:11.022Z" title="发表于 2025-05-22 09:54:11">2025-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/" title="基础暴力算法">基础暴力算法</a><time datetime="2025-04-15T03:39:06.386Z" title="发表于 2025-04-15 11:39:06">2025-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" title="CSAPP-1计算机系统漫游">CSAPP-1计算机系统漫游</a><time datetime="2023-04-22T18:10:33.000Z" title="发表于 2023-04-23 02:10:33">2023-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/" title="OSTEP-1操作系统上的程序">OSTEP-1操作系统上的程序</a><time datetime="2023-04-20T14:12:13.000Z" title="发表于 2023-04-20 22:12:13">2023-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/" title="数据结构-6 图">数据结构-6 图</a><time datetime="2023-04-09T12:15:47.000Z" title="发表于 2023-04-09 20:15:47">2023-04-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By zyw9825</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><img src="https://haiyong.site/img/icp.png"> <a href="https://beian.miit.gov.cn"  style="color:white" target="_blank">陕ICP备2025066278号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-lrctype="0" data-id="922753585" data-order="random" data-listmaxheight="200px" data-theme="#2980b9" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>