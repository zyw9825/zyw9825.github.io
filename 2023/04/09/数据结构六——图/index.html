<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>数据结构六——图 | 晃在云淡风轻</title><meta name="author" content="zyw9825"><meta name="copyright" content="zyw9825"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图的存储结构 图的顺序存储结构——邻接矩阵 12345678910typedef struct &amp;#123;		int no;							&#x2F;&#x2F;顶点编号，表示它的位置	char info;						&#x2F;&#x2F;顶点的其他辅助信息，没有的话可以删除&amp;#125;VertexType;	 &#x2F;&#x2F;顶点		typedef struct&amp;#123;			int edges[maxSize][maxSize];	&#x2F;&#x2F;顶">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构六——图">
<meta property="og:url" content="https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/index.html">
<meta property="og:site_name" content="晃在云淡风轻">
<meta property="og:description" content="图的存储结构 图的顺序存储结构——邻接矩阵 12345678910typedef struct &amp;#123;		int no;							&#x2F;&#x2F;顶点编号，表示它的位置	char info;						&#x2F;&#x2F;顶点的其他辅助信息，没有的话可以删除&amp;#125;VertexType;	 &#x2F;&#x2F;顶点		typedef struct&amp;#123;			int edges[maxSize][maxSize];	&#x2F;&#x2F;顶">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg">
<meta property="article:published_time" content="2023-04-09T12:15:47.000Z">
<meta property="article:modified_time" content="2023-04-20T14:24:55.362Z">
<meta property="article:author" content="zyw9825">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg"><link rel="shortcut icon" href="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408232833.png"><link rel="canonical" href="https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?08ead5bb7d005bd4116f0ec90195f830";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构六——图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-20 22:24:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230409115434.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="晃在云淡风轻"><span class="site-name">晃在云淡风轻</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构六——图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-09T12:15:47.000Z" title="发表于 2023-04-09 20:15:47">2023-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-20T14:24:55.362Z" title="更新于 2023-04-20 22:24:55">2023-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构六——图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>图的存储结构</h1>
<h2 id="图的顺序存储结构——邻接矩阵">图的顺序存储结构——邻接矩阵</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;	</span><br><span class="line">	<span class="type">int</span> no;							<span class="comment">//顶点编号，表示它的位置</span></span><br><span class="line">	<span class="type">char</span> info;						<span class="comment">//顶点的其他辅助信息，没有的话可以删除</span></span><br><span class="line">&#125;VertexType;	 <span class="comment">//顶点		</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;		</span><br><span class="line">	<span class="type">int</span> edges[maxSize][maxSize];	<span class="comment">//顶点之间的相邻关系（无权值：1表示相通，0表示不相通）（有权值：∞表示不相通，其它为权值）</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;				<span class="comment">//总顶点数和总边数</span></span><br><span class="line">	VertexType vex[maxSize];		<span class="comment">//存放图中的所有顶点</span></span><br><span class="line">&#125;MGraph;		<span class="comment">//图</span></span><br></pre></td></tr></table></figure>
<h2 id="图的链式存储结构——邻接链表">图的链式存储结构——邻接链表</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边——结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> adjvex;					<span class="comment">//该边所指顶点的位置</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextArc;	<span class="comment">//指向下一条边的指针</span></span><br><span class="line">	<span class="type">int</span> info;					<span class="comment">//边的补充信息，如权值，没有则省略</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点——结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;					<span class="comment">//顶点信息</span></span><br><span class="line">	ArcNode *firstArc;			<span class="comment">//指向第一条依附于该顶点边的指针</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接表存储类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AGraph</span> &#123;</span><br><span class="line">	VNode adjlist[maxSize];		<span class="comment">//邻接表，由顶点表结点组成的数组</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;			<span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;AGraph;</span><br></pre></td></tr></table></figure>
<h1>图的遍历</h1>
<h2 id="深度优先搜索遍历">深度优先搜索遍历</h2>
<p>类似于二叉树的先序遍历。算法执行过程：<strong>访问任一顶点，然后从该顶点出发，递归访问该顶点的所有未被访问的邻接顶点</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[maxSize]; 	<span class="comment">//全局数组，作为顶点的访问标记，取0表示该位置的顶点未被访问，取1表示该位置的顶点未被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(AGraph *g)</span> </span>&#123;						<span class="comment">//深度优先搜索遍历图g</span></span><br><span class="line">    <span class="comment">//初始化标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)	&#123;</span><br><span class="line">        visited[v] = <span class="number">0</span>;								</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从0顶点开始遍历（连通图只需要从任一顶点出发就能完成遍历，非连通图需要依次从多个顶点出发才能完成遍历，这里假设为非连通图）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)	&#123;			</span><br><span class="line">		<span class="keyword">if</span> (visited[v] == <span class="number">0</span>)						<span class="comment">//对每个连通分量调用一次DFS</span></span><br><span class="line">			<span class="built_in">DFS</span>(g, v);								<span class="comment">//v位置的顶点未被访问过，访问之</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span> </span>&#123;				<span class="comment">//从顶点v出发，深度优先遍历G</span></span><br><span class="line">	<span class="built_in">visit</span>(v);								<span class="comment">//访问顶点v</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;							<span class="comment">//更改全局数组，表示v已经被访问过</span></span><br><span class="line">    <span class="comment">//递归访问v的所有未被访问过的邻接顶点</span></span><br><span class="line">	ArcNode *p = G-&gt;adjlist[v].firstArc;	<span class="comment">//p指向顶点v的第一条边</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;	</span><br><span class="line">		<span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) &#123;		</span><br><span class="line">			<span class="built_in">DFS</span>(G, p-&gt;adjvex);				<span class="comment">//边p另一端的顶点，即v的邻接顶点没被访问过，递归访问之</span></span><br><span class="line">			p = p-&gt;nextArc;					<span class="comment">//挪动p指向v的下一条边，循环访问v的其他邻接顶点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>深度优先搜索生成树：对<strong>连通图</strong>的深度优先搜索遍历过程中所经历的边保留，其余的边删掉，就会形成一棵树，称为~。</li>
<li>图的深度优先搜索遍历类似于二叉树的先序遍历。区别在于二叉树的先序遍历对于每个结点要递归地访问两个分支，而图的深度优先搜索遍历则是递归地访问多个分支。</li>
<li>DFS的空间复杂度：O(n)，n为顶点个数。</li>
<li>DFS的时间复杂度：
<ol>
<li>图以邻接矩阵表示：查找每个顶点的邻接点所需要的时间为O(n)，有n个顶点，故总的时间复杂度为<strong>O(n^2^</strong>)</li>
<li>图以邻接表表示：查找所有顶点的邻接点所需要的是时间为O(e)，访问所有顶点为O(n)，故总的时间复杂度为<strong>O(n+e)</strong></li>
</ol>
</li>
</ul>
<h2 id="广度优先搜索遍历">广度优先搜索遍历</h2>
<p>类似于二叉树的层次遍历。访问v的所有邻接顶点，再访问v的所有邻接顶点的邻接顶点…以此类推，直到图中所有顶点都被访问。</p>
<p>广度优先搜索需要借助一个队列：</p>
<ol>
<li>任取图中一个结点访问，入队，并标记其已经被访问过</li>
<li>队列非空时循环执行：出队，依次检查出队结点的所有邻接顶点，如果没被访问过，访问之，然后入队；</li>
<li>队列非空时跳出循环，结束遍历。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[maxSize]; <span class="comment">//全局数组，作为顶点的访问标记，取0表示该位置的顶点未被访问，取1表示该位置的顶点未被访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对图g进行广度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(AGraph *g)</span> </span>&#123;						<span class="comment">//广度优先搜索遍历图g</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++) &#123;</span><br><span class="line">		visited[v] = <span class="number">0</span>;								<span class="comment">//初始化标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)				<span class="comment">//从v=0开始遍历</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (visited[v] == <span class="number">0</span>)						<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">			<span class="built_in">BFS</span>(g, v);								<span class="comment">//v位置的顶点未被访问过，访问之	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS函数，访问v的所有邻接顶点，再访问v的所有邻接顶点的邻接顶点......</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> que[maxSize], front = <span class="number">0</span>, rear = <span class="number">0</span>;		<span class="comment">//定义循环队列作为辅助工具</span></span><br><span class="line">	<span class="built_in">visit</span>(v);									<span class="comment">//访问顶点v</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;								<span class="comment">//更改访问标记</span></span><br><span class="line">	rear = (rear + <span class="number">1</span>) % maxSize;				<span class="comment">//顶点v入队</span></span><br><span class="line">	que[rear] = v;</span><br><span class="line">	<span class="type">int</span> j;						<span class="comment">//两个临时变量，j用来接收出队顶点，p用来接收出队顶点j的第一条边</span></span><br><span class="line">	ArcNode *p;	</span><br><span class="line">	<span class="comment">//队列非空时执行，完成对v的所有邻接顶点的访问后，再访问v的所有邻接顶点的邻接顶点......</span></span><br><span class="line">	<span class="keyword">while</span> (front != rear) &#123;						</span><br><span class="line">		<span class="comment">//队列非空，出队</span></span><br><span class="line">		front = (front + <span class="number">1</span>) % maxSize;			</span><br><span class="line">		j = que[front];				<span class="comment">//出队顶点</span></span><br><span class="line">		p = G-&gt;adjlist[j].firstArc;	<span class="comment">//出队顶点的第一条边</span></span><br><span class="line">		<span class="comment">//遍历出队顶点j的所有邻接顶点，未被访问过就访问之，并入队</span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;	</span><br><span class="line">			<span class="comment">//如果j的邻接顶点p-&gt;adjvex未被访问过，访问并入队</span></span><br><span class="line">			<span class="keyword">if</span> (visited[p-&gt;adjvex] != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">visit</span>(p-&gt;adjvex);</span><br><span class="line">				visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				que[rear] = p-&gt;adjvex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//更新p指向j的下一条边，检查j的下一个邻接顶点</span></span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//p的所有邻接顶点访问完之后，队列中存有p的所有邻接顶点，再去访问访问它们的邻接顶点，直到队空退出外层循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS的时间复杂度：</li>
</ul>
<ol>
<li>图以邻接矩阵表示：查找每个顶点的邻接点所需要的时间为O(n)，有n个顶点，故总的时间复杂度为<strong>O(n^2^</strong>)</li>
<li>图以邻接表表示：查找所有顶点的邻接点所需要的是时间为O(e)，访问所有顶点为O(n)，故总的时间复杂度为<strong>O(n+e)</strong></li>
</ol>
<h2 id="判断无向图G是否是一棵树">判断无向图G是否是一棵树</h2>
<p>一个无向图是一棵树的条件是有<strong>n-1条边</strong>的<strong>连通</strong>图（n为图中顶点的个数）。</p>
<p>判读无向图g是否是一棵树需要满足两个条件：</p>
<ol>
<li>无向图g是一个连通图；</li>
<li>无向图有n-1条边，其中n是顶点数；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断无向图是否是一棵树</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">G_isTree</span><span class="params">(AGraph *g)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)	&#123;</span><br><span class="line">		visited[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> vn = <span class="number">0</span>, en = <span class="number">0</span>;					<span class="comment">//新增两个计数器：vn——已访问顶点数，en——已访问边数</span></span><br><span class="line">	<span class="built_in">DFS_isTree</span>(g, <span class="number">0</span>, vn, en);			<span class="comment">//从0顶点出发，DFS图g</span></span><br><span class="line">	<span class="comment">//判读无向图g是否是一棵树需要满足两个条件：</span></span><br><span class="line">	<span class="comment">//1.无向图g是一个连通图：通过一次DFS返回的顶点数是否和g的顶点数相等</span></span><br><span class="line">	<span class="comment">//2.无向图有n-1条边，n是顶点数：深度遍历过程中，每条边都会访问2次，所以需要除以2和n-1比较</span></span><br><span class="line">	<span class="keyword">if</span> (vn == g-&gt;vexnum &amp;&amp; en / <span class="number">2</span> == (g-&gt;vexnum - <span class="number">1</span>)) &#123;	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改DFS算法，新增两个计数器：vn——已访问顶点数，en——已访问边数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_isTree</span><span class="params">(AGraph *G, <span class="type">int</span> v, <span class="type">int</span> &amp;vn, <span class="type">int</span> &amp;en)</span> </span>&#123;</span><br><span class="line">	vn++;									<span class="comment">//访问操作改为：已访问顶点数+1</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;							</span><br><span class="line">	ArcNode *p = G-&gt;adjlist[v].firstArc;	</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		en++;								<span class="comment">//已访问边数+1</span></span><br><span class="line">		<span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) &#123;		</span><br><span class="line">			<span class="built_in">DFS_isTree</span>(G, p-&gt;adjvex, vn, en);</span><br><span class="line">			p = p-&gt;nextArc;				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断顶点i到顶点j是否连通">判断顶点i到顶点j是否连通</h2>
<p>方法：从顶点i出发遍历图，如果遇到j则说明连通，否则不连通。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断顶点i到顶点j是否连通</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFSTrave</span><span class="params">(AGraph *g, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		visited[v] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(g, i);</span><br><span class="line">    <span class="comment">//visited[j]等于1，说明被访问过了</span></span><br><span class="line">	<span class="keyword">if</span> (visited[j] == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>图的应用</h1>
<h2 id="最小生成树">最小生成树</h2>
<ul>
<li>生成树：一个连通图的最小生成树包含图中的所有顶点，并且只含尽可能少的边。</li>
<li>砍去生成树的一条边，生成树就会变成非连通图；增加一条边，它就会形成一个回路。</li>
<li>最小生成树：带权连通无向图中权值之和最小的生成树。</li>
<li><strong>最小生成树不是唯一的，但不同最小生成树的边权值之和是一样的，而且是最小的</strong>。当图中各边的权值不相等时，最小生成树唯一。</li>
<li>图的边数比它的顶点数少1，即图本身就是一棵树时，它的最小生成树是它自己。</li>
<li>最小生成树的边数=顶点数-1。</li>
</ul>
<h3 id="普里姆（Prim）算法">普里姆（Prim）算法</h3>
<p>基本思想：从图中任取一个顶点，把它当做一棵树，然后从与<strong>这棵树相接</strong>的边中选取一条最短（权值最小）的边，将这条边与其连接的顶点一并加入到树中，重复这个过程，直到图中所有顶点都被并入树中，此时得到的数就是最小生成树。</p>
<p>普里姆算法需要用到两个辅助数组：</p>
<ol>
<li>vset[]数组，vset[i]=1表示顶点i已经加入到树中，vset[i]=0说明顶点i还未加入到树中（类似于上面的visited[]，标记数组）。</li>
<li>lowcost[]数组，存放当前生成树到其余顶点最短边的权值。比如lowcost[j]=4就表示当前生成树到j顶点的最短边的权值是4。</li>
</ol>
<p>要注意，lowcost[]数组中存放的当前生成树到其余顶点的最小权值，而非树中结点到顶点的权值。而且，树到其余顶点的边可能有很多条，此时应该选最短的那一条边，记录它的权值。</p>
<p>从树中任一顶点v0开始，构成最小生成树的算法执行过程：</p>
<ol>
<li>
<p>v0作为树根结点，然后从v0到其他顶点的所有边都作为候选边</p>
</li>
<li>
<p>重复执行以下步骤n-1次，使得其他n-1个顶点被并入到树中：</p>
<p>(1)从候选边中挑出权值最小的边 ，将与之相连的另一个顶点v并入到树中；</p>
<p>(2)更新lowcost数组，以新加入的顶点v为出发点，如果其余顶点vi使得(v0，vi)的权值比lowcost[vi]小，就用(v0，vi)的权值覆盖lowcost[vi]。</p>
</li>
</ol>
<p>这里采用的图的存储结构是顺序存储结构——邻接矩阵。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100 <span class="comment">//INF是一个已经定义的比图中所有边权值都大的常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普里姆算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph g, <span class="type">int</span> v0, <span class="type">int</span> &amp;sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> min, v;								<span class="comment">//min：记录每次新增顶点后的权值增量；v：树新增顶点</span></span><br><span class="line">	<span class="type">int</span> lowcost[maxSize], vset[maxSize];	</span><br><span class="line">    <span class="comment">//遍历图中顶点，给lowcost[], vset[]赋初始值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)		</span><br><span class="line">	&#123;	</span><br><span class="line">		lowcost[i] = g.edges[v0][i];		<span class="comment">//开始时，v0自己是一棵树，lowcost数组里放v0到其他边的权值</span></span><br><span class="line">		vset[i] = <span class="number">0</span>;						</span><br><span class="line">	&#125;</span><br><span class="line">	vset[v0] = <span class="number">1</span>;							<span class="comment">//修改v0的标记值，表示v0已经加入到树中</span></span><br><span class="line">	sum = <span class="number">0</span>;								<span class="comment">//sum用来保存当前生成树的总权值</span></span><br><span class="line">	<span class="comment">//循环g.vexnum-1次,将除了v0以外的其他顶点加入到树中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INF;							<span class="comment">//INF为已知的比图中所有边的权值都大的常量</span></span><br><span class="line">		<span class="comment">//1.选出当前生成树到其余顶点的边中权值最小的那一条</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++)	</span><br><span class="line">		&#123;	<span class="comment">//vest[j]等于0说明未加入树中，lowcost[j]小于min说明树到顶点j的边权值可能是最小的</span></span><br><span class="line">			<span class="keyword">if</span> (vset[j] == <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) </span><br><span class="line">			&#123;</span><br><span class="line">				min = lowcost[j];		<span class="comment">//不停地刷新min值，遍历结束，min记录选出的边的权值</span></span><br><span class="line">				v = j;					<span class="comment">//v记录顶点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vset[v] = <span class="number">1</span>;					<span class="comment">//选出的顶点加入树</span></span><br><span class="line">		sum += min;						<span class="comment">//刷新当前生成树的总权值</span></span><br><span class="line">		<span class="comment">//2.每次加入一个新顶点，树到其他顶点的权值信息会发生变化，所以要刷新lowcost[]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum; k++)</span><br><span class="line">		&#123;	<span class="comment">//从新加入顶点v出发，如果到剩余某个顶点k的权值比lowcost[]中记录的值小，则用其值覆盖lowcost[]</span></span><br><span class="line">			<span class="keyword">if</span> (vset[k] == <span class="number">0</span> &amp;&amp; g.edges[v][k] &lt; lowcost[k]) </span><br><span class="line">			&#123;</span><br><span class="line">				lowcost[k] = g.edges[v][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//完成一个树结点的添加，继续添加下一个</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Prim算法不依赖边，它的时间复杂度为<strong>O(n^2^)</strong>。</li>
<li>因为不依赖边，Prim算法适用于求解<strong>边稠密的图</strong>的最小生成树。</li>
</ul>
<h3 id="克鲁斯卡尔（Kruskal）算法">克鲁斯卡尔（Kruskal）算法</h3>
<p>基本思想：每次找出侯选边中权值最小的边，将其加入到树中。重复这个过程直到所有边都被检测完。</p>
<p>是否为侯选边：看这条边的并入是否会构成回路作为标准。构成回路就说明这条边两边的顶点都是树中结点。</p>
<p>算法执行过程：</p>
<ol>
<li>
<p>将图中所有的边按照权值从小到大排序；</p>
</li>
<li>
<p>从权值最小边开始扫描各边，若该边为侯选边，则将其加入到树中，直到所有的树都被检测完。</p>
</li>
</ol>
<p>为了判断侯选边的加入是否会构成回路，我们需要借助并查集。并查集类似于树的双亲存储结构，我们定义一个一维数组，用下标表示顶点的编号，用下标对应的数组值表示它的父结点。这种结构有两个好处：</p>
<ol>
<li>可以快速的将两棵树合并为一棵树，只需要找到其中树A的根结点a，a作为树B的任一结点的孩子结点即可。即只需要修改A[a]的值。</li>
<li>可以很方便的判断两个结点是否属于用一棵树，只需要知道它们各自的根结点，看是否相等即可。</li>
</ol>
<p>我们把图的所有顶点放入到并查集中，在算法开始之前，将他们看做一棵棵单独的树，算法执行的过程中，不断地合并两棵树即可。</p>
<p>我们规定，在并查集V[]中，如果i是某棵树根结点，那么A[i]=i，即根结点的双亲结点是它自己。</p>
<p>那么将图g中所有顶点存到并查集v中并初始化的代码应该这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)&#123;</span><br><span class="line">		v[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，与普里姆算法中针对顶点操作不同，克鲁斯卡尔算法中要不断地针对“边&quot;进行操作，所以我们需要定义新的数据结构来保存和边有关的信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Road结构保存了边，权值和它的两个结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b;		<span class="comment">//边的两个顶点</span></span><br><span class="line">	<span class="type">int</span> w;			<span class="comment">//边的权值</span></span><br><span class="line">&#125;Road;</span><br></pre></td></tr></table></figure>
<p>克鲁斯卡尔算法，假设road[]数组中已经存放了图中所有边，且排序函数sort()已经存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Road road[maxSize];	<span class="comment">//定义road[]存放图中所有的边信息</span></span><br><span class="line"><span class="type">int</span> v[maxSize];		<span class="comment">//定义并查集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">(MGraph g, <span class="type">int</span> &amp;sum, Road road[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//所有顶点加入并查集并单独作为一棵树，并查集初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)&#123;</span><br><span class="line">		v[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//对road数组中所有边信息按照权值从小到大排序，这里没有具体实现sort函数</span></span><br><span class="line">	<span class="built_in">sort</span>(road, g.arcnum);</span><br><span class="line">   	<span class="comment">//从权值最小边开始扫描各边，若该边为侯选边，则将其加入到树中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.arcnum; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="built_in">getRoot</span>(road[j].a);		<span class="comment">//得到边j的其中一个顶点a在并查集结构中的根结点</span></span><br><span class="line">		b = <span class="built_in">getRoot</span>(road[j].b);		<span class="comment">//得到边j的其中一个顶点b在并查集结构中的根结点</span></span><br><span class="line">        <span class="comment">//a!=b说明边road[j]的两个顶点属于不同的两棵树，则合并这两棵树，将a作为b的子树</span></span><br><span class="line">		<span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">			v[a] = b;</span><br><span class="line">			sum += road[j].w;		<span class="comment">//更新总权值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getRoot()方法放回并查集v中的根结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRoot</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n!=v[n])	 <span class="comment">//n不是根结点</span></span><br><span class="line">	&#123;</span><br><span class="line">		n = v[n];	<span class="comment">//从n出发，沿着它的父结点往上找根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Road存储结构示意图：<br>
<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/1cfd6803d3d94c328ef8de83f4de5bea.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>下图右半部分为算法执行之后的并查集结构以及最小生成树的的结构示意图：</p>
</li>
</ul>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/b0d891c8dff84c98b17fcb6bd5f810d3.png" alt="在这里插入图片描述"></p>
<p>Kruskal算法时间花费在排序函数sort()和单层循环中，循环是线性级的，可以认为算法时间主要花费在排序函数中，根据所选排序函数不同，算法的时间复杂度不同。由于排序函数是以图的边数为问题规模的，与顶点数无关，可见Kruskal算法适合于<strong>稀疏图</strong>。</p>
<ul>
<li>Prim算法和Kruskal算法都是针对无向图的。</li>
<li>Prim算法适用于稠密图，而Kruskal适用于稀疏图。</li>
</ul>
<h2 id="最短路径">最短路径</h2>
<ul>
<li>最短路径：当图是带权图时，把一个顶点v~0~到图中任意一个顶点v~i~的一条路径（非唯一）所经过的边上的权值之和，定义为该路径的带权路径长度，代全路径长度最短的路径就是最短路径。</li>
</ul>
<h3 id="迪杰斯特拉（Dijkstra）算法">迪杰斯特拉（Dijkstra）算法</h3>
<p>迪杰斯特拉（Dijkstra）算法主要用来<strong>求图中任意顶点v~0~到其余各顶点的最短路径</strong>。</p>
<p>其基本思想是：每次加入的新顶点v~j~，保证v~0~从现有路径到v~j~的路径长度是v~0~到其他剩余顶点中最短的。每次加入新顶点后，重新计算v~0~到剩余顶点的最短路径值。</p>
<p>需要用到3个辅助数组：</p>
<ol>
<li>dist[ vi]表示当前已找到的从v~0~到每个终点 V~i~的最短路径的长度。它的初态为：若从v~0~到 V~i~有边，则dist[vi]为边上的权值，否则置 dist[vi]为∞（算法里为INF，一个比图中任意边权值都大的常数）。</li>
<li>path[vi]中保存从 v~0~到 V~i~最短路径上 V~i~的前一 个顶点。path[]的初态为：如果 v~0~到 v~i~有边，则 path[vi]=v~0~，否则 path[vi]=-1。</li>
<li>set[]为标记数组，set[vi]=0表示v~i~还没有被并入最短路径；set[vi]=1表示 v~i~已经被并入最短路径。set[]初态为：set[v0]=1, 其余元素全为0。</li>
</ol>
<p>迪杰斯特拉算法执行过程如下：</p>
<ol>
<li>
<p>从当前dist[]数组中选出最小值加入路径，假设为dist[vu]，则需要设置set[vu]=1。</p>
</li>
<li>
<p>新顶点的加入可能会使得从v0到vk的路径长度变得更短，所以可能需要更新dist[k]以及path[k]。循环扫描图中顶点，对每个顶点进行以下检测：</p>
<p>如果set[vk]=1，说明v~k~已经加入路径，则什么都不用做；</p>
<p>如果set[vk]=0，说明v~k~还没有加入路径，则比较旧路径v0-vk的长度<code>dist[k]</code>和新路径v0-vu-vk的长度<code>dist[u] + g.edges[u][k]</code>的大小，看是否新路径的长度更短，即是否满足<code>dist[u] + g.edges[u][k] &lt; dist[k]</code>。如果满足，则说明vu的加入使得v0到vk的路径长度更短，所以更新dist[k]为新路径的长度，同时更新path[k]=u。</p>
</li>
<li>
<p>每加入一个新顶点，更新一次dist[k]以及path[k]。重复1,2步骤n-1次，完成从v0到其余各顶点的最短路径。路径保存在path[]数组中，且最短路径长度值保存在dist[]数组中。</p>
</li>
</ol>
<ul>
<li>
<p>辅助数组的初始值举例，v~0~为顶点0，dist[]，path[]，set[]三个辅助数组的初始值如下：<br>
<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/a7268b0c4a8e4e4f973b5a0504fcd585.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>对上图的算法的执行过程模拟：</p>
</li>
</ul>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/c400a9f17f904ca58ce6b090d218591c.png" alt="在这里插入图片描述"></p>
<ul>
<li>迪杰斯特拉算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迪杰斯特拉算法,求v0到其余各顶点的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Dijkstra</span><span class="params">(MGraph g, <span class="type">int</span> v0, <span class="type">int</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> set[maxSize];							<span class="comment">//辅助标记数组</span></span><br><span class="line">	<span class="type">int</span> min, u;									<span class="comment">//两个辅助变量</span></span><br><span class="line">	<span class="comment">//初始化dist[]，path[]，set[]三个辅助数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; g.vexnum;i++) &#123;			<span class="comment">//辅助数组赋初始值</span></span><br><span class="line">		dist[i] = g.edges[v0][i];				<span class="comment">//顶点i与v0单边相连，则dist[i]为边的权值，不相连为INF;</span></span><br><span class="line">		set[i] = <span class="number">0</span>;								<span class="comment">//所有顶点的标记值初始化为0，表示未加入路径</span></span><br><span class="line">		<span class="comment">//path[a]=b表示在路径中，顶点a前一个顶点是b</span></span><br><span class="line">		<span class="keyword">if</span> (g.edges[v0][i] &lt; INF) &#123;				<span class="comment">//如果vi与v0相连，则path[vi]=v0</span></span><br><span class="line">			path[i] = v0;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;									<span class="comment">//如果vi与v0不相连，则path[vi]=-1</span></span><br><span class="line">			path[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	set[v0] = <span class="number">1</span>;								<span class="comment">//v0加入路径</span></span><br><span class="line">	path[v0] = <span class="number">-1</span>;								<span class="comment">//v0是路径的起点，规定path[v0]为-1</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化结束，算法开始</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum<span class="number">-1</span>; i++)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//1.在剩余顶点中，从dist[]中选出最小值，表示通过已有路径走到这个顶点的路径是最短的</span></span><br><span class="line">        min = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (set[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">				u = j;</span><br><span class="line">				min = dist[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		set[u] = <span class="number">1</span>;								<span class="comment">//新加入顶点为Vu</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//2.如果新顶点的加入使得从v0到vk的路径长度变得更短，则更新dist[k]以及path[k]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum; k++)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span> (set[k] == <span class="number">0</span> &amp;&amp; dist[u] + g.edges[u][k] &lt; dist[k]) &#123;</span><br><span class="line">				dist[k] = dist[u] + g.edges[u][k];</span><br><span class="line">				path[k] = u;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法结束后，最短路径保存在path[]数组中，且最短路径长度值保存在dist[]数组中。path[]数组如下：</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/f5c9ec1f419a4cf18256912b1c820fb2.png" alt="在这里插入图片描述"></p>
<p>path[] 数组中其实保存了一棵树，这是一棵用<strong>双亲存储结构存储的树</strong>，通过这棵树可以打印出从源点到任何一个顶点最短路径上所经过的所有顶点。树的双亲表示法只能直接输出由叶子结点到根结点路径上的结点，而不能逆向输出，因此需要借助一个栈来实现逆向输出。</p>
<ul>
<li>打印路径函数如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a是目标顶点，输出从v0到a的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> path[], <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> stack[maxSize], top = <span class="number">-1</span>;	<span class="comment">//初始化栈</span></span><br><span class="line">	<span class="keyword">while</span> (path[a] != <span class="number">-1</span>) &#123;			<span class="comment">//从a往上到根结点依次入栈</span></span><br><span class="line">		stack[++top] = a;</span><br><span class="line">		a = path[a];</span><br><span class="line">	&#125;</span><br><span class="line">	stack[++top] = a;	<span class="comment">//根结点入栈</span></span><br><span class="line">	<span class="keyword">while</span> (top != <span class="number">-1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; stack[top--] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法的时间复杂度：O(n^2^)</li>
<li>当图中含有负权值时，迪杰斯特拉算法并不适用。</li>
</ul>
<h3 id="弗洛伊德（Floyd）算法">弗洛伊德（Floyd）算法</h3>
<p>弗洛伊德（Floyd）算法主要用来<strong>求图中任意一对顶点v~i~和v~j~的最短路径</strong>。</p>
<ol>
<li>基本思想</li>
</ol>
<p>弗洛伊德算法的基本思想是递推n阶方阵，该算法需要用到两个矩阵：A和Path</p>
<ul>
<li>矩阵A表示任意两顶点之间的路径长度。比如A~k~[i][j]就表示顶点i到j的路径长度，而k表示以k顶点作为中间顶点的运算步骤。</li>
<li>矩阵Path表示用来记录当前两顶点最短路径上要经过的中间顶点。</li>
</ul>
<p>逐步尝试在原路径中加入顶点k（k=0,1,2,3…n-1）作为中间顶点，若增加中间顶点后，得到的路径比原来的路径长度减少了，则用新路径代替原路径，直到所有顶点加入路径。</p>
<ol start="2">
<li>举例</li>
</ol>
<p>对于下图最右边的图来说，写出它的邻接矩阵，得到初始矩阵A~-1~，同时矩阵Path~-1~中元素的初始值为-1，表示没有任意顶点对的路径之间都没有中间顶点：<br>
<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/56118477af19437f808ee84301363a72.png" alt="在这里插入图片描述"></p>
<p>对于每次新加入的顶点k，对于任⼀顶点对 (i, j)，<strong>i ≠ j，k ≠ i，v ≠ j</strong>，如果A[i][j] &gt; A[i][k] + A[k][j]，则将 A[i][j] 更新为 A[i][k] + A[k][j] 的值，并且将 Path[i][j] 改为k。</p>
<ul>
<li>加入顶点0（k=0），矩阵A和Path不变：</li>
</ul>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/25b8ca4b73734ad295cb0466b0dee631.png" alt="在这里插入图片描述"></p>
<ul>
<li>加入顶点1（k=1），检查所有顶点对（因为i ≠ j，k ≠ i，v ≠ j，实际上不用检查所有顶点对。首先，<strong>主对角线</strong>上的顶点对始终都是0，不需要更新，其次，<strong>第k行</strong>以及<strong>第k列</strong>上的顶点对都不需要检查），所以需要检查的顶点对就是0-2,0-3,2-0,2-1,2-3,3-0,3-1,3-2，发现A[0][2]&gt;A[0][1]+A[1][2]=5+4=9，则将A[0][2]修改为9，同时将Path[0][2]改为1，表示此时0到2中的中间路径是1：</li>
</ul>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/76c2f55e29d746a1a5a1b4b97da653ee.png" alt="在这里插入图片描述"></p>
<ul>
<li>
<p>加入顶点2（k=2），需要检查的顶点对为0-1,0-3,1-0,1-1,1-3，3-0,3-1,3-3。按照上面的方法，得到A~2~和Path~2~：<br>
<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/5c020c46fa864fb7bd187aee1ce8cc30.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>加入顶点3（k=3），得到A~3~和Path~3~：</p>
</li>
</ul>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/bc6ad06ce82d48aa93754c4d00b63699.png" alt="在这里插入图片描述"></p>
<p>至此，所有的顶点都已经加入到路径中，所以A~3~和Path~3~就是最终的矩阵。</p>
<ul>
<li>
<p>通过A矩阵可以找到图中任意两个结点之间的最短路径长度，比如A[1][3]为2，就表示顶点1到顶点3的最短路径长度为2。</p>
</li>
<li>
<p>通过Path矩阵可以写出任意两个结点的最短路径。比如从1到0，Path[1][0]为3，就表示3是中间顶点：</p>
</li>
</ul>
<ol>
<li>先写出1到3的路径，发现Path[1][3]为-1，表示顶点1到顶点3之间没有中间顶点，则1-&gt;3</li>
<li>再写3到0的路径，发现Path[3][0]为2，表示顶点3到顶点0之间有中间顶点2</li>
<li>写3到2的路径，发现Path[3][2]为-1，则3-&gt;2</li>
<li>再写2到0的路径，发现Path[2][0]=-1，则2-&gt;0</li>
</ol>
<p>由此可以得到顶点1到顶点0的最短路径就是1-3-2-0。可以发现这是一个递归的过程，用代码表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> path[][maxSize], <span class="type">int</span> A[][maxSize])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (A[i][j] &lt; INF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (path[i][j] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//直接输出边&lt;i,j&gt;;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> mid = path[i][j];		<span class="comment">//中间顶点</span></span><br><span class="line">			<span class="built_in">printPath</span>(i, mid, path, A); <span class="comment">//前半段路径</span></span><br><span class="line">			<span class="built_in">printPath</span>(mid, j, path, A);	<span class="comment">//后半段路径</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>弗洛伊德算法的代码表示</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph* g, <span class="type">int</span> Path[][maxSize], <span class="type">int</span> A[][maxSize])</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			A[i][j] = g-&gt;edges[i][j];</span><br><span class="line">			Path[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//算法的主体部分是一个三重循环,表示将k顶点逐步加入到路径中，并修改A矩阵和Path矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g-&gt;vexnum; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vexnum; j++)</span><br><span class="line">				<span class="keyword">if</span> (A[i][j] &gt; A[i][k] + A[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">					A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">					Path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法复杂度：O(n^3^)</li>
<li>弗洛伊德算法允许图中带有负权值的边存在，但不允许包含带负权值的边组成的回路。</li>
<li>弗洛伊德算法同样适用于带权无向图。</li>
<li>也可以使用单源最短路径算法来解决任意顶点之间的最短路径问题，需要对每个顶点都使用一次Dijkstra算法，时间复杂度是O(n^3^)。</li>
</ul>
<h2 id="拓扑排序">拓扑排序</h2>
<ul>
<li>
<p>DAG图：即有向无环图。</p>
</li>
<li>
<p>AOV网：即顶点表示活动的网络（Activity On Vertex network），用DAG图表示一个工程，其<strong>顶点表示活动</strong>，用有向<strong>边</strong>&lt;V~i~,V~j~&gt;表示<strong>活动之间的先后关系</strong>。</p>
</li>
<li>
<p>拓扑排序：是对DAG图顶点的一种排序，它使得若存在路径从顶点A到顶点B，则在拓扑排序中顶点B必然出现在A的后面。</p>
</li>
<li>
<p>拓扑排序满足下面的条件：</p>
<ol>
<li>每个顶点出现且只出现一次；</li>
<li>A在B的前面，则图中不存在从B到A的路径。</li>
</ol>
</li>
<li>
<p>拓扑排序不唯一。</p>
</li>
<li>
<p><strong>拓扑排序的方法：</strong></p>
<ol>
<li>从AOV网中选出一个没有前驱（入度为0）的顶点输出；</li>
<li>删除1中输出的顶点以及和它有关的边；</li>
<li>重复1和2，直到AOV网为空或者不存在没有前驱（入度为0）的顶点。</li>
</ol>
</li>
<li>
<p>举例：</p>
</li>
</ul>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/86c079e36a6541248117b9df068fafef.png" alt="在这里插入图片描述"></p>
<p>​			 拓扑排序1：abced</p>
<p>​			 拓扑排序2：abecd</p>
<p>​			 拓扑排序3：aebcd</p>
<ul>
<li>
<p>拓扑排序算法</p>
<p>需要用到一个入度数组indegree[]来记录顶点的入度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> indegree[maxSize];					<span class="comment">//入度数组，记录所有顶点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopSort</span><span class="params">(AGraph *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;								<span class="comment">//计数器	</span></span><br><span class="line">	<span class="type">int</span> stack[maxSize], top = <span class="number">-1</span>;		<span class="comment">//初始化栈（不一定是栈，其他容器，比如队列也行，这里并没有对顺序要求）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)	<span class="comment">//将所有入度为0的顶点入栈</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			stack[++top] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关键步骤</span></span><br><span class="line">	<span class="keyword">while</span> (top!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v = stack[top--];			<span class="comment">//栈顶顶点出栈</span></span><br><span class="line">		++n;							<span class="comment">//计数器+1</span></span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;				<span class="comment">//输出出栈顶点</span></span><br><span class="line">		<span class="comment">//将出栈顶点v指向的所有顶点的入度-1，并将入度减为0的顶点入栈</span></span><br><span class="line">		ArcNode *p = g-&gt;adjlist[v].firstArc;	</span><br><span class="line">		<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="type">int</span> k = p-&gt;adjvex;</span><br><span class="line">			indegree[k]--;</span><br><span class="line">			<span class="keyword">if</span> (indegree[k] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				stack[++top] = k;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == g-&gt;vexnum) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>算法时间复杂度：由于输出每个顶点的同时还要删除以它为起点的边，所以算法复杂度为O(n+e)</p>
</li>
<li>
<p><strong>逆拓扑排序</strong></p>
<p>对一个AOV网如下操作进行排序，称之为逆拓扑序列：</p>
</li>
</ul>
<ol>
<li>在网中任选一个没有后继的顶点（出度为0）输出</li>
<li>在网中删除和它有关的边（所有指向它的边）</li>
<li>重复1和2，直到AOV网为空或者不存在没有后继的顶点</li>
</ol>
<ul>
<li>使用<strong>DFS</strong>（深度优先搜索遍历）进行拓扑排序</li>
</ul>
<p>当有向图无环时，可以<strong>用DFS（深度优先搜索遍历）先得到逆拓扑序列</strong>，进而得到拓扑序列。</p>
<p>由于图中无环，当由图中某个顶点出发进行DFS时，最先退出算法的顶点即为出度为0的顶点，就是逆拓扑序列的第一个顶点。所以，按照DFS算法的先后次序记录下的顶点序列即为逆向拓扑序列，将其逆向输出即为拓扑序列。</p>
<h2 id="关键路径">关键路径</h2>
<ul>
<li>AOE网：在带权有向图中，用顶点表示时间，有向边表示活动，权值表示活动进行的时间，则称之为用边表示活动的网络（Activity On Edge network）。</li>
<li>AOE网和AOV网都是有向无环图，区别在于它们的顶点和边表示的含义不同。</li>
<li>AOE网的性质
<ol>
<li>只有在某个顶点所表示的事件发生后，从该顶点出发的各有向边代表的活动才能开始；</li>
<li>只有在所有指向某个顶点的边代表的所有活动都结束后，该顶点代表的事件才会发生；</li>
</ol>
</li>
<li>AOE网中只有一个入度为0的顶点，称为<strong>源点</strong>，代表着整个工程的开始；AOE网中只有一个出度为0的顶点，称为<strong>汇点</strong>，代表整个工程的结束。</li>
<li>关键路径：从源点到汇点的所有路径中，具有<strong>最大路径长度</strong>的路径称为<strong>关键路径</strong>。</li>
<li>关键活动：关键路径上的活动。</li>
<li>关键路径的长度代表完成整个工程所需要的时间，任何一个关键活动不能按时完成，整个工程的完成时间都会延后。所以，只有找到了关键路径，才能得到工程最短完成时间。</li>
<li>通过加快某些关键活动可以缩短整个工程的工期，但这也可能会导致该关键活动变成非关键活动。</li>
<li>关键路径并不唯一，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，必须<strong>加快那些包括所有关键路径上的关键活动才能缩短工期</strong>。</li>
</ul>
<p>按照下面的步骤可以求得某活动的关键路径与关键活动：</p>
<ol>
<li>
<p><strong>事件v~k~的最早发生时间ve(k)</strong></p>
<p>从源点v~1~到v~k~的最长路径长度。v~k~的最早发生时间决定了所有从顶点k开始的活动能够开工的最早时间。</p>
<p>推算方法：对图进行拓扑排序，按照拓扑排序的顺序求ve：</p>
<blockquote>
<p>ve(源点)=0;</p>
<p>ve(k) = Max{ ve(j) + Weight(v~j~,v~k~) }</p>
</blockquote>
<p>其中，j是k的任意前驱，Weight(v~j~,v~k~) 表示边&lt;v~j~,v~k~&gt;上的权值。也就是说，在图中可能有多条边指向k（k在图中能有多个直接前驱），而经过直接前驱j到k的这条路径最长，即ve(j)+ Weight(v~j~,v~k~) 最大，则取这个最大值作为ve(k)。</p>
</li>
<li>
<p><strong>事件v~k~的最迟发生时间vl(k)</strong></p>
<p>在不推迟整个工程完成的前提下，该事件最迟发生的时间。</p>
<p>推算方法：对图进行逆拓扑排序，按照逆拓扑排序的顺序求vl：</p>
<blockquote>
<p>vl(汇点)=ve(汇点)；</p>
<p>vl(k) = min{ vl(j) - Weight(v~k~,v~j~) }</p>
</blockquote>
<p>假设j是k的后继事件（j可能有多个），vl(j)是事件j的最迟发生时间，从事件k到事件j的活动须花费时长Weight(v~k~,v~j~)，所以vl(j) - Weight(v~k~,v~j~)表示相对于事件j来说事件k的最晚的发生时间。j可能有多个，k应该相对尽早地发生，才能满足所有的j在各自的最迟发生时间能发生，所以要取vl(j) - Weight(v~k~,v~j~)最小值，即为k的最迟发生时间。</p>
</li>
<li>
<p><strong>活动a~i~的最早开始时间e(i)</strong></p>
<p>即该活动的起点事件所发生的最早发生时间。若&lt;v~k~,v~j~&gt;表示活动a~i~，则e(i)=ve(k)。</p>
</li>
<li>
<p><strong>活动a~i~的最迟开始时间l(i)</strong></p>
<p>即该活动的终点事件的最迟发生时间与该活动所需要的时间之差。若&lt;v~k~,v~j~&gt;表示活动a~i~，则l(i)=vl(j)-Weight(v~k~,v~j~)。</p>
</li>
<li>
<p><strong>活动的剩余时间：l(i)-e(i)</strong></p>
<p>表示在不延长总工程完成时间的前提下，活动a~i~可以拖延的时间。当某个活动的剩余时间为0时，表示它必须如期完成，否则就会导致整个工期的延后，称这种活动为关键活动。所有关键活动构成的路径就是关键路径。</p>
</li>
</ol>
<p>举例：</p>
<p>先求拓扑排序和逆拓扑排序：1346和6431。</p>
<p>按照拓扑排序，从源点处开始，求事件v~k~的最早发生时间ve(k)</p>
<p>按逆拓扑排序，从汇点处开始，求事件v~k~的最迟发生时间vl(k)。</p>
<p>规定，源点处的事件的最早发生时间是0，而汇点处的事件的最迟发生时间等于它的最早发生时间。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/886b51c810a34810b428c2416713f8e2.png" alt=""></p>
<p>求事件的最早发生时间时，如果有多条边指向它，要选“ve(j) + Weight(v~j~,v~k~) ”最长的。</p>
<p>比如，求ve(6)时，ve(3)+a7=2+6 &lt; ve(4)+a6=1+8=9，选ve(4)+a7</p>
<p>求事件的最迟发生时间时，如果它指向多条边，要选“vl(j) - Weight(v~k~,v~j~)  ”最短的。</p>
<p>求vl(1)时，vl(4)-a3=1-1=0 &lt; vl(3)-a2=3-2=1，选k       vl(4)-a3</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/8d103f44b6ed4c958caf64de315ca1af.png" alt="在这里插入图片描述"></p>
<p>活动的最早开始时间就是引出这项活动的事件的最早发生时间，比如e(a2)=ve(1)，e(a6)=ve(3)</p>
<p>活动的最迟开始时间就是活动的终点事件的最晚发生时间与活动持续时间的差。</p>
<p>关键活动是指：活动的最早开始时间=活动的最迟开始时间的活动。这里就是a3和a7。</p>
<p>关键路径：关键活动组成的路径。它的路径最长，它的持续时间代表了整个工程的最短完成时间。</p>
<h1>例题</h1>
<ol>
<li>
<p>顶点个数为n的无向图最多有n(n-1)/2条边。(C~n~^2^)</p>
</li>
<li>
<p>含有n个顶点的连通无向图最少有n-1条边。</p>
</li>
<li>
<p>含有n个顶点的连通有向图最少有n条边。</p>
</li>
<li>
<p>含有n个顶点的完全有向图含有n(n-1)条边。</p>
</li>
<li>
<p>使用下列（AB）方法可以判断出一个有向图是否有环?</p>
<p>A. 深度优先遍历</p>
<p>B. 拓扑排序</p>
<p>C. 求最短路径</p>
<p>D. 求关键路径</p>
<p>在有向图的DFS算法中，如果在遍历没有结束前，出现从孩子结点到父结点的边，自然说明这个有向图有环。</p>
<p>在拓扑排序中，每次要删除一个没有前驱的结点，如果到最后还有结点</p>
</li>
<li>
<p>当各边权值均相等时，BFS算法可以解决单源最短路径问题。</p>
</li>
<li>
<p>拓扑排序不唯一。</p>
</li>
<li>
<p>在拓扑排序中，如果A出现在B前面，则在图中必不会出现从B到A的路径。</p>
</li>
<li>
<p>无向图的邻接矩阵是对称矩阵。</p>
</li>
<li>
<p>对于无向图的邻接矩阵，顶点i的出度是指<strong>第i行元素之和</strong>，第j列的元素之和表示顶点j的入度。（1表示邻接，0表示不邻接）</p>
</li>
<li>
<p>对于有向图的邻接矩阵，顶点i的出度是指<strong>第i行所有非∞非0元素的个数</strong>，顶点i的入度是指第i列所有非∞非0元素的个数。</p>
</li>
<li>
<p>DFS算法类似于二叉树的先序遍历算法；BFS算法类似于二叉树的层次遍历算法。</p>
</li>
</ol>
<p>这项活动的事件的最早发生时间，比如e(a2)=ve(1)，e(a6)=ve(3)</p>
<p>活动的最迟开始时间就是活动的终点事件的最晚发生时间与活动持续时间的差。</p>
<p>关键活动是指：活动的最早开始时间=活动的最迟开始时间的活动。这里就是a3和a7。</p>
<p>关键路径：关键活动组成的路径。它的路径最长，它的持续时间代表了整个工程的最短完成时间。</p>
<h1>例题</h1>
<ol>
<li>
<p>顶点个数为n的无向图最多有n(n-1)/2条边。(C~n~^2^)</p>
</li>
<li>
<p>含有n个顶点的连通无向图最少有n-1条边。</p>
</li>
<li>
<p>含有n个顶点的连通有向图最少有n条边。</p>
</li>
<li>
<p>含有n个顶点的完全有向图含有n(n-1)条边。</p>
</li>
<li>
<p>使用下列（AB）方法可以判断出一个有向图是否有环?</p>
<p>A. 深度优先遍历</p>
<p>B. 拓扑排序</p>
<p>C. 求最短路径</p>
<p>D. 求关键路径</p>
<p>在有向图的DFS算法中，如果在遍历没有结束前，出现从孩子结点到父结点的边，自然说明这个有向图有环。</p>
<p>在拓扑排序中，每次要删除一个没有前驱的结点，如果到最后还有结点</p>
</li>
<li>
<p>当各边权值均相等时，BFS算法可以解决单源最短路径问题。</p>
</li>
<li>
<p>拓扑排序不唯一。</p>
</li>
<li>
<p>在拓扑排序中，如果A出现在B前面，则在图中必不会出现从B到A的路径。</p>
</li>
<li>
<p>无向图的邻接矩阵是对称矩阵。</p>
</li>
<li>
<p>对于无向图的邻接矩阵，顶点i的出度是指<strong>第i行元素之和</strong>，第j列的元素之和表示顶点j的入度。（1表示邻接，0表示不邻接）</p>
</li>
<li>
<p>对于有向图的邻接矩阵，顶点i的出度是指<strong>第i行所有非∞非0元素的个数</strong>，顶点i的入度是指第i列所有非∞非0元素的个数。</p>
</li>
<li>
<p>DFS算法类似于二叉树的先序遍历算法；BFS算法类似于二叉树的层次遍历算法。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zyw9825.github.io">zyw9825</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/">https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zyw9825.github.io" target="_blank">晃在云淡风轻</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/20/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/" title="OSTEP-1操作系统上的程序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OSTEP-1操作系统上的程序</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构五——树与二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构五——树与二叉树</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构五——树与二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">数据结构五——树与二叉树</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zyw9825</div><div class="author-info__description">你且迷这风浪永远二十赶朝暮</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zyw9825"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zyw9825" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zyw_9825@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=765830653&amp;website=www.oicqzone.com" target="_blank" title="添加QQ好友"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_44238142?spm=1010.2135.3001.5421" target="_blank" title="csdn"><i class="fa-solid fa-blog"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">个人邮箱：zyw_9825@163.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.1.</span> <span class="toc-text">图的顺序存储结构——邻接矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%82%BB%E6%8E%A5%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">图的链式存储结构——邻接链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.</span> <span class="toc-text">深度优先搜索遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text">广度优先搜索遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%97%A0%E5%90%91%E5%9B%BEG%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%80%E6%A3%B5%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">判断无向图G是否是一棵树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%A1%B6%E7%82%B9i%E5%88%B0%E9%A1%B6%E7%82%B9j%E6%98%AF%E5%90%A6%E8%BF%9E%E9%80%9A"><span class="toc-number">2.4.</span> <span class="toc-text">判断顶点i到顶点j是否连通</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%EF%BC%88Prim%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">普里姆（Prim）算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%88Kruskal%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">克鲁斯卡尔（Kruskal）算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">3.2.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%EF%BC%88Dijkstra%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">迪杰斯特拉（Dijkstra）算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%EF%BC%88Floyd%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">弗洛伊德（Floyd）算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">3.4.</span> <span class="toc-text">关键路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">例题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/20/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/" title="OSTEP-1操作系统上的程序">OSTEP-1操作系统上的程序</a><time datetime="2023-04-20T14:12:13.000Z" title="发表于 2023-04-20 22:12:13">2023-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/" title="数据结构六——图">数据结构六——图</a><time datetime="2023-04-09T12:15:47.000Z" title="发表于 2023-04-09 20:15:47">2023-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构五——树与二叉树">数据结构五——树与二叉树</a><time datetime="2023-04-09T12:14:47.000Z" title="发表于 2023-04-09 20:14:47">2023-04-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By zyw9825</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-test-eoihet3sd-zyw9825.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div class="aplayer no-destroy" data-lrctype="0" data-id="922753585" data-order="random" data-listmaxheight="200px" data-theme="#2980b9" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>