<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>数据结构五——树与二叉树 | 晃在云淡风轻</title><meta name="author" content="zyw9825"><meta name="copyright" content="zyw9825"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树的基本概念  结点：结点不仅包含数据元素，而且包含指向子树的指针 结点的度：结点拥有的子树个数或者分支的个数。 树的度：树中各结点度的最大值。 叶子结点：又叫作终端结点，指度为0的结点 孩子：结点的子树的根结点。 双亲：与孩子的定义相对应。A是B的孩子，那么B就是A的双亲。 兄弟：同一 个双亲的孩子之间互为兄弟。 祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。 树的高度（或者深度）：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构五——树与二叉树">
<meta property="og:url" content="https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="晃在云淡风轻">
<meta property="og:description" content="树的基本概念  结点：结点不仅包含数据元素，而且包含指向子树的指针 结点的度：结点拥有的子树个数或者分支的个数。 树的度：树中各结点度的最大值。 叶子结点：又叫作终端结点，指度为0的结点 孩子：结点的子树的根结点。 双亲：与孩子的定义相对应。A是B的孩子，那么B就是A的双亲。 兄弟：同一 个双亲的孩子之间互为兄弟。 祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。 树的高度（或者深度）：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg">
<meta property="article:published_time" content="2023-04-09T12:14:47.000Z">
<meta property="article:modified_time" content="2023-04-09T12:50:38.197Z">
<meta property="article:author" content="zyw9825">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg"><link rel="shortcut icon" href="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408232833.png"><link rel="canonical" href="https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?08ead5bb7d005bd4116f0ec90195f830";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构五——树与二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-09 20:50:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230409115434.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="晃在云淡风轻"><span class="site-name">晃在云淡风轻</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构五——树与二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-09T12:14:47.000Z" title="发表于 2023-04-09 20:14:47">2023-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-09T12:50:38.197Z" title="更新于 2023-04-09 20:50:38">2023-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构五——树与二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>树的基本概念</h1>
<ul>
<li>结点：结点不仅包含数据元素，而且包含指向子树的指针</li>
<li>结点的度：结点拥有的子树个数或者分支的个数。</li>
<li>树的度：树中各结点度的最大值。</li>
<li>叶子结点：又叫作终端结点，指度为0的结点</li>
<li>孩子：结点的子树的根结点。</li>
<li>双亲：与孩子的定义相对应。A是B的孩子，那么B就是A的双亲。</li>
<li>兄弟：同一 个双亲的孩子之间互为兄弟。</li>
<li>祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。</li>
<li>树的高度（或者深度）：树中结点的最大层次。</li>
<li>结点的深度：从根结点到该结点的路径上的结点个数。</li>
<li>结点的高度：从某结点往下走可能到达多个叶子结点，对应了多条通往这些叶子结点的路径，其中最长的那条路径上结点的个数。</li>
</ul>
<h1>树的存储结构</h1>
<ul>
<li>
<p>顺序存储结构：<strong>双亲存储结构</strong></p>
<p>用一维数组即可实现：用数组下标表示树中的结点，数组元素的内容表示该结点的双亲结点，这样有了结点（下标）以及结点之间的关系（内容），就可以表示一 棵树了。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/2bdf73a2b0fa2165c8110bfe134b7660.png" alt="image-20210715231435883"></p>
</li>
<li>
<p>链式存储结构：</p>
<ol>
<li>
<p><strong>孩子存储结构</strong>：即将每个结点的所有孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表。</p>
</li>
<li>
<p><strong>孩子兄弟存储结构</strong>：又称二叉树表示法，即以二叉链表作为树的存储结构。</p>
<p>每个结点都包含了三个内容：结点值、指向结点的第一个孩子结点的指针、指向结点的下一个兄弟结点的指针。</p>
<p>这种存储方法比较灵活，最大的优点是可以方便实现树转化成二叉树的操作，方便查找孩子，但查找双亲比较麻烦，对此，可以采用三叉链表，多加一个指向父结点的指针。</p>
</li>
</ol>
</li>
</ul>
<h1>二叉树的定义</h1>
<p>将一般的树加上如下两个限制条件就得到了二叉树：</p>
<ol>
<li>每个结点最多只有两棵子树，即二叉树中结点的度只能为0、1、2。</li>
<li>子树有左右顺序之分，不能颠倒。</li>
</ol>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/37b8e8ed986c5636dae42da5fe930ae6.png" alt="请添加图片描述"></p>
<h1>二叉树的主要性质</h1>
<ol>
<li>
<p>总结点数=总分支数+1（根结点上面没有分支，其余每一个结点上面对应一个分支）</p>
</li>
<li>
<p>非空二叉树的叶子结点数=双分支结点数+1，即n~0~=n~2~+1（下标表示结点的分支个数）</p>
<blockquote>
<p>证明：总结点数=n~0~+n~1~+n~2~ ，总分支数=n~1~+2n~2~ ，又因为树中除了根结点，其余每个结点都对应一个分支，即总结点数=总分支数+1，所以有n~0~+n~1~+n~2~=n~1~+2n~2~+1，整理得n~0~=n~2~+1。</p>
</blockquote>
</li>
<li>
<p>二叉树中的空指针数=总结点数+1，空指针数也是线索二叉树的线索数</p>
<blockquote>
<p>证明：假设所有的空指针都是叶子结点，那么树中的所有结点都变成了双分支结点（n个），根据性质1，那么空指针数=叶子结点数=双分支结点数+1=n+1；</p>
</blockquote>
</li>
<li>
<p>在一个度为m的树中，度为1的结点数为n~1~，度为2的结点数为n~2~，……，度为m的结点为n~m~，则树中的叶子结点数n~0~=1+n~2~+2n~3~+…+(m-1)n~m~</p>
<blockquote>
<p>证明：总结点数n=n~0~+n~1~+…+n~m~，总分支数=n~1~+2n~2~+3n~3~+…+mn~m~，总结点数=总分支数+1，则有n~0~+n~1~+n~2~…+n~m~=1+n~1~+2n~2~+3n~3~+…+mn~m~，整理得：n~0~=1+n~2~+2n~3~+…+(m-1)n~m~</p>
</blockquote>
</li>
<li>
<p>二叉树的第i层上最多有2^i-1^个结点。（a~0~=1，q=2的等比数列第i项）</p>
</li>
<li>
<p>高度为k二叉树最多有2^k^-1结点（即高度为h的满二叉树）。（a~0~=1，q=2的等比数列前h项和）</p>
</li>
<li>
<p>高度为k二叉树最少有2^k-1^结点（=2^k-1^-1+1）。</p>
</li>
<li>
<p>有n个结点的完全二叉树，对各结点从上到下、从左到右依次编号（1~n）,对于结点a~i~来说：</p>
<ol>
<li>a的父结点的为编号为⌊i/2⌋（向下取整）</li>
<li>如果2i&lt;=n，那么a的左孩子的编号为2i</li>
<li>如果2i+1&lt;=n，那么a的右孩子编号为2i+1</li>
</ol>
</li>
<li>
<p>函数Catalan()：给定n个结点，能构成h(n)种不同的二叉树：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><msubsup><mi>C</mi><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">h(n)=\frac{C_{2}^{2n}}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5375em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1341em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0715em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</li>
<li>
<p>具有n（n&gt;=1）个结点的完全二叉树的高度（或深度）为：</p>
<ul>
<li>⌊log~2~n⌋ + 1（⌊⌋表示向下取整）</li>
<li>⌈log~2~(n+1)⌉（⌈⌉表示向上取整）</li>
</ul>
</li>
<li>
<p>设N~h~表示高度为h的平衡二叉树所含有的最少结点数，则有：N~1~=1，N~2~=2，N~3~=4，N~5~=7，……，N~h~=N~h-2~+N~h-1~+1</p>
</li>
</ol>
<h1>二叉树的存储结构</h1>
<ul>
<li>
<p>顺序存储结构</p>
<p>即通过一个数组来存储一个二叉树。适用于完全二叉树，用于存储一般的二叉树会浪费大量的空间。</p>
<p>假如有n个结点的完全二叉树存储在数组a中，根结点的下标为<strong>1</strong>，对于结点<code>a[i]</code>，它的：</p>
<ol>
<li>左孩子：如果<code>2*i&lt;=n</code>，则左孩子为<code>a[2*i]</code>，否则没有左孩子</li>
<li>右孩子：如果<code>2*i+1&lt;=n</code>，则右孩子为<code>a[2*i+1]</code>，否则没有右孩子</li>
<li>双亲：<code>a[j]</code>，j=取整{i/2}</li>
</ol>
<p>假如有n个结点的完全二叉树存储在数组a中，根结点的下标为<strong>0</strong>，对于结点<code>a[i]</code>，它的：</p>
<ol>
<li>左孩子：如果<code>2*i+1&lt;=n</code>，则左孩子为<code>a[2*i+1]</code>，否则没有左孩子</li>
<li>右孩子：如果<code>2*i+2&lt;=n</code>，则右孩子为<code>a[2*i+2]</code>，否则没有右孩子</li>
<li>双亲：<code>a[j-1]</code>，j=取整{i/2}</li>
</ol>
<p><strong>易错点</strong>：注意和树的顺序存储结构区分，在树的顺序存储结构中，数组下标代表结点编号，数组中所存的内容是各结点之间的关系。而在二叉树的顺序存储结构中，数组下标不仅是结点编号，还包含了各结点之间的关系。由于二叉树属于树的一种，所以树的顺序存储结构可以用来存储二叉树，但二叉树的顺序存储结构不能用来存储树。</p>
</li>
<li>
<p>链式存储结构</p>
<table>
<thead>
<tr>
<th style="text-align:center">lchild</th>
<th style="text-align:center">data</th>
<th style="text-align:center">rchild</th>
</tr>
</thead>
</table>
<ol>
<li>data表示数据域</li>
<li>lchild表示左指针域，存储左孩子的位置</li>
<li>rchild表示右指针域，存储右孩子的位置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树链式存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data; 					<span class="comment">//默认char，可换</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchild;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>二叉树的遍历</h1>
<p>二叉树的遍历主要分为<strong>先序遍历、中序遍历、后序遍历</strong>以及一个<strong>层次遍历</strong>。</p>
<ul>
<li>先序遍历（DLR）
<ol>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
<li>中序遍历（LDR）
<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
</li>
<li>后序遍历（LRD）
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
</li>
</ul>
<p><strong>这里“序“指的是根结点何时被访问。可以看出三种遍历方式只是访问结点的时机不一样。</strong></p>
<ul>
<li>
<p>层次遍历</p>
<p>按照从左到右（或从右到左），从上到下逐行遍历结点。</p>
</li>
</ul>
<h2 id="二叉树深度优先遍历算法的实现">二叉树深度优先遍历算法的实现</h2>
<ul>
<li>
<p>三种二叉树深度优先遍历算法的程序模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trave</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//1.</span></span><br><span class="line">		<span class="built_in">trave</span>(p-&gt;lchild);</span><br><span class="line">		<span class="comment">//2.</span></span><br><span class="line">		<span class="built_in">trave</span>(p-&gt;rchild);</span><br><span class="line">		<span class="comment">//3.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于树中的每一个结点，不管是采用先序遍历、中序遍历、后序遍历哪一种，每个结点都会被经过<strong>3</strong>次。</p>
<p>如果统一在第一次经过时访问结点，那就是先序遍历；此时把对结点的访问操作写在1处；</p>
<p>如果统一在第二次经过时访问结点，那就是中序遍历；此时把对结点的访问操作写在2处；</p>
<p>如果统一在第三次经过时访问结点，那就是后序遍历。此时把对结点的访问操作写在3处；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">visit</span>(p);				<span class="comment">//对结点的访问操作</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">preOrder</span>(p-&gt;lchild);</span><br><span class="line">		<span class="built_in">preOrder</span>(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">inOrder</span>(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">visit</span>(p);				<span class="comment">//对结点的访问操作</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">inOrder</span>(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrder</span>(p-&gt;lchild);</span><br><span class="line">		<span class="built_in">postOrder</span>(p-&gt;rchild);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">visit</span>(p);				<span class="comment">//对结点的访问操作</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//visit()函数是自定义的，根据实际需要，可以用任何针对结点的操作来代替它</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="层次遍历">层次遍历</h2>
<p>按照从左到右（或从右到左），从上到下逐行遍历结点。</p>
<p>要进行层次遍历，需要建立一 个队列。先将二叉树头结点入队列，然后出队列，访问该结点，如果它有左子树，则将左子树的根结点入队；如果它有右子树，则将右子树的根结点入队。然后出队列，对出队结点访问。如此反复，直到队列为空为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	BTNode *que[maxSize];						<span class="comment">//定义一个循环队列</span></span><br><span class="line">	<span class="type">int</span>  front = <span class="number">0</span>, rear = <span class="number">0</span>;					<span class="comment">//初始化队列，队头与队尾归零</span></span><br><span class="line"></span><br><span class="line">	BTNode *q;									<span class="comment">//临时变量，用来临时存储出队元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;							<span class="comment">//非空树</span></span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">		que[rear] = p;							<span class="comment">//这两句是循环队列的入队操作，这里表示根结点入队</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (front!=rear)	&#123;					<span class="comment">//队列非空</span></span><br><span class="line"></span><br><span class="line">			front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">			q = que[front];						<span class="comment">//这两句是循环队列的出队操作，这里表示队头元素出队</span></span><br><span class="line">            </span><br><span class="line">			<span class="built_in">visit</span>(q);							<span class="comment">//访问结点</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;			<span class="comment">//如果当前结点有左孩子，左孩子入队</span></span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				que[rear] = q-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;			<span class="comment">//如果当前结点有右孩子，右孩子入队</span></span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				que[rear] = q-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是借助了循环队列，乍一看好像很麻烦，其实只是循环队列的初始化、入队、出队看着比较麻烦，如果可以把这些操作写成函数放在外面，会看着简洁一些。但是，不管怎么变化，核心思想是不变的，根据借助的队列类型不同、针对结点的操作不同，可以根据此模板来记忆层次遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOorder</span><span class="params">(BTNode *p)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//1.初始化队列</span></span><br><span class="line"></span><br><span class="line">	BTNode *q;	<span class="comment">//临时变量，用来临时存储出队元素</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;	<span class="comment">//树非空	</span></span><br><span class="line">        <span class="comment">//2.根结点入队</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span> (队列非空)&#123;         </span><br><span class="line">			 <span class="comment">//3.出队 (出队元素赋值给q)</span></span><br><span class="line">             <span class="comment">//4.visit(q); 针对结点q的操作</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;			</span><br><span class="line">				<span class="comment">//5.如果q有左孩子，左孩子入队</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;			</span><br><span class="line">				<span class="comment">//6.如果q有右孩子，右孩子入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>层次遍历的模板与下面的二叉树深度优先遍历算法的非递归实现中的先序遍历模板很相似，主要区别是：</p>
<ol>
<li>层次遍历借助的是队列，而非递归先序遍历借助的是栈</li>
<li>层次遍历是左孩子优先于右孩子入队，而非递归先序遍历是右孩子优先于左孩子入栈</li>
</ol>
<p>注意不要记混。</p>
<h2 id="快速写出遍历序列的方法">快速写出遍历序列的方法</h2>
<p>先看最简单的情况：只有3个结点ABC</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/44a7985c4739e53feed3874930e362a7.png" alt="image-20210713000928775"></p>
<ul>
<li>先序遍历：按照DLR的规则：ABC（中左右）</li>
<li>中序遍历：按照LDR的规则：BAC（左中右）</li>
<li>后序遍历：按照LRD的规则：BCA（左右中）</li>
</ul>
<p>下面看更一般的情况：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vAUFRelu-1626800975200)(<a target="_blank" rel="noopener" href="https://i.loli.net/2021/07/18/c8RfDynuWQqdGYh.png">https://i.loli.net/2021/07/18/c8RfDynuWQqdGYh.png</a>)]</p>
<ol>
<li>
<p>先序遍历：ABDECFG</p>
<p>将其按照（ A（BDE）（CFG））来划分，有没有观察到，BDE刚好是树A左下角以B为根结点的二叉树的先序遍历排列，CFG刚好是数A右下角以C为根结点的二叉树的先序遍历排列。往下还可以再划分，拿BDE来说，BDE又可以分成：（B（D）（E）），那么D自然就是树D的先序遍历了，E就是树E的先序遍历了。到这里就不能再划分了，因为D没有左子树了。有没有发现规律？</p>
<p>总结一下对A快速写出先序遍历结果的方法，即从大树化小树的方法：</p>
<ol>
<li>沿A最左边的分支一路向左下找，找到第一个没有左孩子的结点，这里就是树D</li>
<li>先完成对树D的先序遍历，这里树D没有右孩子，那遍历结果就是（D）。注意，如果树D有右孩子，把它当成树，依旧按照本方法</li>
<li>把对树D的先序遍历结果看成一个整体，再完成对树B的先序遍历，即：B（D）（?）。这里的?表示的B的右子树E的先序遍历结果，E没有子树，那么就是（E）。注意，如果E下面还有很多分支，还是按照本方法。那么树B的先序遍历就是（B（D）（E）），即：BDE</li>
<li>再把整个树B看成一个整体，再完成对树A的先序遍历即：（A（BDE）（?））。?表示的就是右子树C的先序遍历结果，那么就对树C按照上面的方法，沿C最左边的分支一路向左下找到第一个没有左孩子的结点，就是F，再按照上面的方法一次完成对树F，树C的先序遍历，得到数C的先序遍历结果（C（F）（G）），即：CFG，代入？里，得到树A的先序遍历结果（A（BDE）（CFG）），即：ABDECFG</li>
</ol>
</li>
<li>
<p>中序遍历：DBEAFCG</p>
<p>方法是类似的，沿A最左边的分支一路向左下找，找到第一个没有左孩子的结点，这里就是树D，依次对树D、树B、树A完成后序遍历即可。即：（（（D）B（E））A（（F）C（G）））</p>
</li>
<li>
<p>后序遍历：DEBFGCA</p>
<p>方法是类似的，沿A最左边的分支一路向左下找，找到第一个没有左孩子的结点，这里就是树D，依次对树D、树B、树A完成后序遍历列即可。（（（D）E（B））（（F）G（C））A），即：DEBFGCA</p>
</li>
</ol>
<p>本例中举的是最理想的情况，实际的树可能要比这复杂的多，越复杂的树利用这种方法就越方便。只要按照步骤1找到正确的开始结点，大树化小数的方法都是可以完成的（实际上我们写的遍历的递归程序就是这么做的）。熟悉这个过程这也为我们下面写非递归方法提供了思路。</p>
<h2 id="根据遍历序列确定二叉树">根据遍历序列确定二叉树</h2>
<ol>
<li>
<p>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</p>
</li>
<li>
<p>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</p>
</li>
<li>
<p><strong>但是已知前序遍历序列和后序遍历序列，是不能确定一棵二叉树</strong></p>
</li>
</ol>
<p>即：<strong>没有中序遍历序列的情况下是无法确定一颗二叉树的</strong></p>
<p>why?拿上面的例子来说：</p>
<p>先序遍历：ABDECFG：（A（B（D）（E））（C（F）（G）））</p>
<p>中序遍历：DBEAFCG：（（（D）B（E））A（（F）C（G）））</p>
<p>后序遍历：DEBFGCA：（（（D）E（B））（（F）G（C））A）</p>
<p>几个规律：</p>
<ol>
<li><strong>先序遍历序列的第一个结点一定是根结点</strong></li>
<li><strong>后序遍历序列的最后一个结点一定是根结点</strong></li>
<li><strong>根结点将中序遍历序列分成左右子树两部分</strong></li>
</ol>
<p>所以，前序和后序在本质上可以将父子结点分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树。</p>
<p>按照上述的规律可以一步一步的还原二叉树，这里拿先序排列和中序排列举例：</p>
<ol>
<li>由先序可以确定根结点是A</li>
<li>在中序中找到A，左边DBE就是左子树，右边FCG就是右子树</li>
<li>在先序中找到去掉A，发现D、B、E三个结点的构成的树，B是根结点，同理，C是根结点。</li>
<li>在中序遍历中确定D是B的左孩子，E是B的右孩子；同理，F是C的左孩子，G是C的右孩子</li>
</ol>
<p>根据上述信息画图：<br>
<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/9f294ed2e36670ab96d7257dc655c8fa.png" alt="在这里插入图片描述"></p>
<h1>二叉树遍历算法的改进</h1>
<h2 id="二叉树深度优先遍历算法的非递归实现">二叉树深度优先遍历算法的非递归实现</h2>
<ul>
<li>
<p>Q1：为什么说二叉树的递归算法效率不高？如何解决？</p>
<p>递归函数所申请的系统栈，是一个所有递归函数都通用的栈。对于二叉树深度优先遍历算法，系统栈除了记录访问过的结点信息之外，还有其他信息需要记录，以实现函数的递归调用。</p>
<p>如果可以手动建立栈，仅保存遍历所需的结点信息，即对二叉树遍历算法进行针对性的设计，对于遍历算法来说，显然要比递归函数通用的系统栈更高效。</p>
</li>
<li>
<p><strong>递归算法是把大问题逐渐化成一个越来越小的问题，再从小到大，从内到外逐个解决，这个核心思想在我们把递归转化成循环时是不变的。循环代替递归的关键，就是通过手动维护栈来实现递归，这个时候，结点入栈出栈的时机就显得非常重要</strong>。递归算法描述起来非常简洁而且想象，但运行过程并不容易搞透，若想把递归算法转化成非递归算法（循环），就要对他的运行过程非常清楚，手动尝试去模拟各种遍历算法的运行过程有利于理解这一部分内容。</p>
</li>
<li>
<p>先序遍历的非递归算法</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder2</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bt非空</span></span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BTNode *stack[maxSize];					<span class="comment">//定义栈</span></span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>;							<span class="comment">//初始化,栈顶指针top为-1时栈空</span></span><br><span class="line">        stack[++top] = bt;						<span class="comment">//根结点入栈</span></span><br><span class="line">        BTNode *q;								<span class="comment">//q是遍历指针，表示当前正在处理的元素</span></span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span>) &#123;						<span class="comment">//循环条件：栈非空	</span></span><br><span class="line">            q = stack[top--];					<span class="comment">//出栈，用q保存</span></span><br><span class="line">            <span class="built_in">visit</span>(q);							<span class="comment">//访问q         </span></span><br><span class="line">            <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;			<span class="comment">//如果q还有右孩子，右孩子入栈</span></span><br><span class="line">                stack[++top] = q-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;			<span class="comment">//如果q还有左孩子，左孩子入栈</span></span><br><span class="line">                stack[++top] = q-&gt;lchild;</span><br><span class="line">            &#125;									</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先序遍历的非递归过程：从根结点开始，入栈。进入循环，出栈并访问根结点，先判断根结点是否有右孩子，如果有，右孩子入栈，然后判断根结点是否有左孩子，如果有，左孩子入栈。继续循环，根结点的左孩子出栈，如果它有右孩子，右孩子入栈，如果它有左孩子，左孩子入栈…栈空时退出循环。</p>
<p>关键之处：右孩子优先于左孩子入栈的顺序不能变。在先序遍历中，对左孩子的访问要优先于右孩子，又由于栈的先进后出特性，所以，每次访问完一个结点，它的右孩子要先于它的左孩子入栈，这样做才能保证左孩子先被访问到。</p>
</li>
<li>
<p>中序遍历的非递归算法</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历的递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder2</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BTNode *stack[maxSize];					</span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        BTNode *q = bt;							<span class="comment">//q是遍历指针，表示当前正在处理的元素，初始值为根结点bt</span></span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> || q != <span class="literal">NULL</span>) &#123;		<span class="comment">//注意这里的循环条件：栈非空或q非空</span></span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;					<span class="comment">//这个whiLe的作用是沿着q的左下方走到头，路过的结点依次入栈</span></span><br><span class="line">                stack[++top] = q;</span><br><span class="line">                q = q-&gt;lchild;					</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span>) &#123;			<span class="comment">//这个if的作用是将出栈、访问栈顶元素之后，将遍历指针q指向出栈元素的右孩子</span></span><br><span class="line">                q = stack[top--];				</span><br><span class="line">                <span class="built_in">visit</span>(q);</span><br><span class="line">                q = q-&gt;rchild;					</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历的非递归过程：</p>
<ol>
<li>
<p>从根结点出发，一路朝着树的左下走到头，找到第一个没有左孩子的结点a，路过的结点依次入栈。a就是中序遍历的第一个结点，它一定在左下角（但并不一定是叶子结点，a可能还有右孩子） 。</p>
</li>
<li>
<p>出栈并访问a，然后将遍历指针指向它的右孩子，去判断它的右孩子是否存在：</p>
<p>如果a的右结点b存在，就把b视为一个新树，回到步骤1，又一路朝着b的左下走…这里也就体现了递归的思想。</p>
<p>如果a的右结点b不存在（这意味着以a为根结点的数就只有它一个元素，那么树a此时已经遍历），那就去找a的父结点c，去完成对c的遍历（还是递归的思想）。c此时就在栈顶（如果栈非空），那么我们就出栈，完成对c的访问操作后，继续把遍历指针p指向c的右孩子…再接着判断c的右孩子是否存在…</p>
</li>
<li>
<p>重复这个过程，当栈空而且p也为空时循环结束。</p>
</li>
</ol>
<p>关键之处：假设根结点是t，当t出栈并完成访问操作后，这就意味着这个数的左半部分（包括t）遍历完成，此时栈是空的，但树的右半部分还没有遍历，所以不能将栈空作为遍历循环的判断条件。此时遍历指针p指向的是t的右孩子，可以根据p的状态此来判断遍历是否继续，最后一个元素遍历完时p指向的是它的右孩子，此时p为空。这就是外层遍历循环的判断条件<code>top != -1 || q != NULL</code>的原因。</p>
</li>
<li>
<p>后序遍历的非递归算法</p>
<p>后序遍历的非递归算法是最困难的，这里提供一种易于理解的版本。</p>
<p>先序遍历：ABDECFG			（A（B（D）（E））（C（F）（G）））</p>
<p>中序遍历：DBEAFCG</p>
<p>后序遍历：DEBFGCA</p>
<p>逆后序遍历：ACGFBED</p>
<p>有一个规律是：逆后序遍历可以看成是把先序遍历过程中对左右子树遍历顺序交换所得的结果。</p>
<p>按照此规则实现后序遍历，要做两件事：</p>
<ol>
<li>在交换左右子树的遍历顺序的前提下进行先序遍历</li>
<li>对上述遍历结果逆序输出</li>
</ol>
<p>所以我们这里用到两个栈，一个栈是遍历本来就需要的，另一个则是来进行逆序的。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder2</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//栈1用来辅助进行交换了左右子树遍历顺序的先序遍历</span></span><br><span class="line">		<span class="comment">//栈2用来实现上述遍历结果的逆序输出</span></span><br><span class="line">		BTNode *stack1[maxSize];	<span class="type">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">		BTNode *stack2[maxSize];	<span class="type">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">		BTNode *q;							<span class="comment">//遍历指针q</span></span><br><span class="line">		stack1[++top1] = bt;</span><br><span class="line">		<span class="comment">//进行交换了左右子树遍历顺序的先序遍历</span></span><br><span class="line">		<span class="keyword">while</span>(top1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			q = stack1[top1--];</span><br><span class="line">			stack2[++top2] = q;				<span class="comment">//每次从栈1出去的元素,就立即把它放入到栈2中</span></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;		<span class="comment">//如果q还有左孩子，左孩子入栈，这里左右子树的入栈的先后顺序发生了变化</span></span><br><span class="line">				stack1[++top1] = q-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;		<span class="comment">//如果q还有右孩子，右孩子入栈</span></span><br><span class="line">				stack1[++top1] = q-&gt;rchild;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//先序遍历结束后，栈2元素逐个出栈即可实现后序遍历</span></span><br><span class="line">		<span class="keyword">while</span> (top2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			q = stack2[top2--];				<span class="comment">//栈2元素出栈并访问</span></span><br><span class="line">			<span class="built_in">visit</span>(q);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线索二叉树">线索二叉树</h2>
<p>对于先序遍历、中序遍历、后序遍历来说，存在一定的局限性：</p>
<ol>
<li>不能从指定结点开始遍历，遍历操作必须从根开始</li>
<li>无法快速的找到某个结点的前驱与后继，每次查找都要从头开始遍历</li>
</ol>
<p>对此，解决思路是，能不能通过某种方式把树中结点的前驱和后继的相关信息保存起来，这样后续查找时就非常高效。</p>
<p>n个结点的二叉树共计有n+1个空指针，利于这些空指针来保存前驱与后继信息。</p>
<h3 id="线索二叉树的存储结构">线索二叉树的存储结构</h3>
<table>
<thead>
<tr>
<th style="text-align:center">lchild</th>
<th style="text-align:center">ltag</th>
<th style="text-align:center">data</th>
<th style="text-align:center">rtag</th>
<th style="text-align:center">rchild</th>
</tr>
</thead>
</table>
<p>在二叉树线索化的过程中会把树中的空指针（lchild与rchild）利用起来作为寻找当前结点前驱或后继的线索，这样就出线索和树中原有指向孩子结点的指针无法区分。为解决这个问题，增设两个标识域ltag和rtag，它们的具体意义如下：</p>
<ol>
<li>如果<strong>ltag=0</strong>，则表示<strong>lchild为指针</strong>，指向结点的<strong>左孩子</strong>；如果<strong>ltag=1</strong>， 则表示<strong>lchild为线索</strong>，指向结点的<strong>直接前驱</strong>。</li>
<li>如果<strong>rtag=0</strong>，则表示<strong>rchild为指针</strong>，指向结点的右孩子；如果<strong>rtag=1</strong>，则表示<strong>rchild为线索</strong>，指向结点的<strong>直接后继</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树数结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTBNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;					<span class="comment">//默认为char，可替换</span></span><br><span class="line">	<span class="type">int</span> ltag, rtag;				</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTBNode</span>* lchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTBNode</span>* rchild;</span><br><span class="line">&#125;TBTNode;</span><br></pre></td></tr></table></figure>
<p>先序遍历、中序遍历、后序遍历的线索化方式是不同的，对应的线索二叉树称为<strong>先序线索二叉树、中序线索二叉树、后续线索二叉树</strong>。</p>
<h3 id="中序线索化">中序线索化</h3>
<p>对一棵二叉树中所有结点的空指针域按照某种遍历方式加线索的过程叫作<strong>线索化</strong>，被线索化了的二叉树称为<strong>线索二叉树</strong>。</p>
<p>线索化从某种程度上讲，可以看成是对<strong>遍历算法的一种应用</strong>。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/9f47a702f64d0f31479129e2f1f3f96a.png" alt="image-20210713203209570"></p>
<p>中序线索化的规则是：</p>
<ol>
<li>左线索指针指向当前结点在中序遍历序列中的前驱结点，右线索指针指向后继结点；</li>
<li>需要两个辅助指针p和pre，p表示当前结点，pre表示p的前驱结点；</li>
<li>p 的左线索如果存在则让其指向pre， pre的右线索如果存在则让其指向p，这样就完成了一 对线索的连接；</li>
<li>按照这样的规则一 直进行下去，当整棵二叉树遍历完成的时候，线索化也就完成了。</li>
</ol>
<p>按照上述规则可以写出两个结点线索化的过程，这就：</p>
<ul>
<li>==<strong>二叉树线索化的代码块</strong>==(非常重要)：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p-&gt;lchild = pre;</span><br><span class="line">    p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pre-&gt;rchild = p;</span><br><span class="line">    pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">pre = p;</span><br></pre></td></tr></table></figure>
<p>二叉树进行中序线索化是在二叉树中序遍历算法的框架中进行的，先回顾下中序遍历递归算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">inOrder</span>(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">visit</span>(p);				<span class="comment">//线索化写在这里代替visit</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">inOrder</span>(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把前面的visit()函数替换成线索化的代码块，即可得到中序线索化一个二叉树的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">		<span class="built_in">inThread</span>(p-&gt;lchild, pre);			<span class="comment">//递归，中序遍历并线索化左子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">        pre = p;	</span><br><span class="line"></span><br><span class="line">		<span class="built_in">inThread</span>(p-&gt;rchild, pre);			<span class="comment">//递归，中序遍历并线索化左子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过中序遍历建立中序线索二叉树的主程序为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过中序遍历建立中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatInThread</span><span class="params">(TBTNode *tbt)</span> </span>&#123;</span><br><span class="line">	TBTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (tbt != <span class="literal">NULL</span>) &#123;	</span><br><span class="line">		<span class="built_in">inThread</span>(tbt, pre);		 <span class="comment">//中序线索化，传入根结点tbt和它的前驱NULL</span></span><br><span class="line">		pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*inThread最后一次执行时：</span></span><br><span class="line"><span class="comment">p指向中序遍历的最后一个结点的右孩子（NULL），pre指向最后一个结点，不满足if（p!=NULL）&#123;...&#125;，函数结束。</span></span><br><span class="line"><span class="comment">此时还差最后一个结点的后继没有线索化，应该手动完成最后一个结点的右线索*/</span></span><br></pre></td></tr></table></figure>
<p>经过上述操作后，可以理解为已经把二叉树变成了一个中序线索二叉树，可以将其视为一个链表。</p>
<p>中序线索二叉树中隐含了线索二叉树的前驱与后继信息。对其遍历时，只需要先找到序列中的第一个结点，然后依次找到结点的后继，直到后继为空即可。</p>
<ul>
<li>
<p>查找中序线索二叉树的中序序列的第一个结点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求以p为根的中序线索二叉树中，中序序列下的第一个结点：</span></span><br><span class="line"><span class="function">TBTNode *<span class="title">getFirst</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) &#123;		<span class="comment">//树中最左下的结点（不一定是叶结点）</span></span><br><span class="line">		p = p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找中序线索二叉树的中序序列的最后一个结点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求以p为根的中序线索二叉树中，中序序列下的最后一个结点：</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">getLast</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>) &#123;	<span class="comment">//最右下的就是最后一个结点</span></span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找中序线索二叉树的中序序列的后继结点：</p>
<ol>
<li>若右标志为1，则右链被线索化，直接指向它的后继；</li>
<li>若右标志为0，就遍历右子树中找到第一个的结点，它就是p的后继，它在右子树的左下角，这里调用getFirst即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点p在中序线索二叉树的后继结点</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">getNext</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getFirst</span>(p-&gt;rchild);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找中序线索二叉树的中序序列的前驱结点：</p>
<ol>
<li>若左标志为1，则左链被线索化，直接指向它的前驱；</li>
<li>若左标志为0，就遍历左子树中找到最后一个结点，它就是p的前驱，它在左子树的右下角，这里调用getLast()</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点p在中序线索二叉树的前驱结点</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">getPrior</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getLast</span>(p-&gt;lchild);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>中序线索二叉树的中序遍历方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索二叉树的中序遍历方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TBTNode *t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (TBTNode *p = <span class="built_in">getFirst</span>(t);p != <span class="literal">NULL</span>;p = <span class="built_in">getNext</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="先序线索化">先序线索化</h3>
<ul>
<li>
<p>二叉树线索化的代码块</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p-&gt;lchild = pre;</span><br><span class="line">    p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pre-&gt;rchild = p;</span><br><span class="line">    pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">pre = p;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>先序遍历的递归算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">visit</span>(p);				<span class="comment">//线索化的代码块放这里代替visit</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">preOrder</span>(p-&gt;lchild);</span><br><span class="line">		<span class="built_in">preOrder</span>(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与中序线索二叉树一样，根据二叉树线索化的代码块以及先序遍历和后序遍历算法，只需要变动线索化代码块与递归的位置即可：</p>
<ul>
<li>
<p>二叉树的先序线索化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;   </span><br><span class="line">        <span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">        pre = p;	</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意，这里在递归入口处设有条件，左右指针不是线索才能继续递归      </span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">inThread</span>(p-&gt;lchild, pre);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">inThread</span>(p-&gt;rchild, pre);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>易错点</strong>：注意<strong>递归处的条件判断</strong>，这是先序线索化独有的，考虑一种特殊情况：加入p此时指向D，pre指向的是B，在对p完成线索化之后，p的lchild已经指向了B，此时按照程序，pre指向D，q指向D的lchild（注意，此时D已经完成线索化），即q又指向了B，又要去完成对B的线索化。可是， 在对D线索化前不是刚对B线索化过了吗？这就产生了死循环。所以，在递归入口前，我们要添加左右指针非线索的条件，就是为了避免这种情况。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/fb11b46b3d986ec64b87f58cfdcc9715.png" alt="image-20210714014808947"></p>
<ul>
<li>
<p>查找先序线索二叉树的先序后继结点</p>
<p>先序遍历遵循的是“根左右”的原则，</p>
</li>
</ul>
<ol>
<li>如果p有左孩子（ltag=0），那么左孩子就是它的后继</li>
<li>如果p没有左孩子但有右孩子（ltag=1，rtag=0），那么右孩子就是它的后继</li>
<li>如果p左右孩子都没有(ltag=1，rtag=1)，那么必然被线索化，它的右链域就指向它后继</li>
</ol>
<p>也就是说，只需要判断p有没有左孩子，如果它有左孩子，左孩子就是它的后继，否则，它的rchild一定指向它的后继。</p>
<p>所以不难写出先序遍历一个先序线索二叉树的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历先序线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (TBTNode *p = root;p != <span class="literal">NULL</span>;) &#123;</span><br><span class="line">			<span class="built_in">visit</span>(p);</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)		<span class="comment">//ltag == 0说明p的左链域没有被线索化，那么它一定有左孩子，左孩子就是p的后继</span></span><br><span class="line">				p = p-&gt;lchild;</span><br><span class="line">			<span class="keyword">else</span>					<span class="comment">//只要p没有左孩子，那么不管右孩子是否被线索化，rchild一定指向p的后继</span></span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>天勤书上的版本，个人觉得没有上面这个好理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOreder</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		TBTNode *p = root;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (p-&gt;ltag==<span class="number">0</span>)&#123;	</span><br><span class="line">				<span class="built_in">visit</span>(p);</span><br><span class="line">				p = p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">visit</span>(p);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>查找先序线索二叉树的先序前驱结点</p>
<ol>
<li>p结点被线索化，那么p-&gt;lchild就是它的前驱</li>
<li>p结点没有被线索化，根据先序二叉树：根左右的顺序，根的左子树和右子树都是他的后继，而未被线索化的结点是没有办法返回查找的，所以这种情况下找不到前驱。此时只能从头遍历一次二叉树，才能确定p结点的前驱。</li>
</ol>
<p>改进：改二叉链表结构为三叉链表结构，每个结点再增设一个指向父结点的指针。</p>
</li>
</ul>
</li>
</ul>
<h3 id="后序线索化">后序线索化</h3>
<ul>
<li>
<p>后序遍历的递归算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrder</span>(p-&gt;lchild);</span><br><span class="line">		<span class="built_in">postOrder</span>(p-&gt;rchild);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">visit</span>(p);				<span class="comment">//线索化的代码块放这里代替visit</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二叉树的后序线索化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">		<span class="built_in">postThread</span>(p-&gt;lchild, pre);			<span class="comment">//递归，后序遍历并线索化左子树</span></span><br><span class="line">        <span class="built_in">postThread</span>(p-&gt;rchild, pre);			<span class="comment">//递归，后序遍历并线索化左子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">        pre = p;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找后序线索二叉树的后序前驱结点</p>
<p>后序遍历遵循“左右根”的规则：</p>
<ol>
<li>如果p有右孩子，那么p的后序前驱为p的右孩子</li>
<li>如果p没有右孩子，那么p的后序前驱为p的左孩子</li>
<li>如果p左右孩子都没有，那么p已经被线索化，lchild指向它的前驱</li>
</ol>
<p>也就是说，只需要判断p到底有没有右孩子即可，有右孩子，p的前驱就是rchild，否则就是lchild。</p>
</li>
<li>
<p>查找后序线索二叉树的后序后继结点</p>
<ol>
<li>如果p的右链域被线索化，那么p的后继就是rchild；</li>
<li>如果p没有被线索化，那么根据后序二叉树：左右根的顺序，根的左子树和右子树都是他的前驱，而未被线索化的结点是没有办法返回查找的，所以这种情况下找不到p的后继。此时只能从头遍历一次二叉树，才能确定p结点的后继。</li>
</ol>
<p>改进：改二叉链表结构为三叉链表结构，每个结点再增设一个指向父结点的指针。</p>
</li>
</ul>
<h3 id="手动查找线索二叉树中的前驱与后继">手动查找线索二叉树中的前驱与后继</h3>
<p>首先，上面已经分析了机器查找的过程，总结如下图：先序线索二叉树和后续线索二叉树都存在一定的局限性。为了解决这个问题，可以将二叉链表结构为三叉链表结构，多增设一个指向父结点的指针。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n3SRU0Ni-1626800975205)(C:/Users/76583/Desktop/%E5%A4%A9%E5%8B%A4%E7%AC%94%E8%AE%B0/image-20210714205603680.png)]</p>
<p>如何人工的查找前驱与后继呢？这里重点看先序线索二叉树找前驱以及后序线索二叉树找后继。</p>
<ul>
<li>
<p>查找中序线索二叉树的中序后继结点：</p>
<ol>
<li>若右标志为1，则右链被线索化，直接指向它的后继；</li>
<li>若右标志为0，就遍历右子树中找到第一个的结点，它就是p的后继，它在右子树的左下角。</li>
</ol>
</li>
<li>
<p>查找中序线索二叉树的中序前驱结点：</p>
<ol>
<li>若左标志为1，则左链被线索化，直接指向它的前驱；</li>
<li>若左标志为0，就遍历左子树中找到最后一个结点，它就是p的前驱，它在左子树的右下角。</li>
</ol>
</li>
<li>
<p>查找先序线索二叉树的先序后继结点</p>
<ol>
<li>如果p有左孩子（ltag=0），那么左孩子就是它的后继</li>
<li>如果p没有左孩子但有右孩子（ltag=1，rtag=0），那么右孩子就是它的后继</li>
<li>如果p左右孩子都没有(ltag=1，rtag=1)，那么必然被线索化，它的右链域就指向它后继</li>
</ol>
<p>也就是说，只需要判断p有没有左孩子，如果它有左孩子，p的后继就是lchild，否则就是rchild。</p>
</li>
<li>
<p><strong>查找先序线索二叉树的先序前驱结点</strong></p>
<ol>
<li>p结点被线索化，那么p-&gt;lchild就是它的先序前驱</li>
<li>p结点没有被线索化，找到p的父亲结点q，按照“根左右”的规则 ：
<ol>
<li>p是q的左孩子，则p的先序前驱是q；</li>
<li>p是q的右孩子，且p没有左孩子，则p的先序前驱是q；</li>
<li>p是q的右孩子，且p有左孩子，则p的先序前驱是q的左子树最后一个被先序遍历的结点（右下角）</li>
</ol>
</li>
<li>p是根结点，则p没有先序前驱。</li>
</ol>
</li>
<li>
<p>查找后序线索二叉树的后序前驱结点</p>
<ol>
<li>如果p有右孩子，那么p的后序前驱为p的右孩子</li>
<li>如果p没有右孩子，那么p的后序前驱为p的左孩子</li>
<li>如果p左右孩子都没有，那么p已经被线索化，lchild指向它的前驱</li>
</ol>
<p>也就是说，只需要判断p到底有没有右孩子即可，有右孩子，p的前驱就是rchild，否则就是lchild。</p>
</li>
<li>
<p><strong>查找后序线索二叉树的后序后继结点</strong></p>
<ol>
<li>如果p的右链域被线索化，那么p的后继就是rchild；</li>
<li>如果p没有被线索化，找到p的父亲结点q，根据后序二叉树“左右根”的规则：
<ol>
<li>p是q的右孩子，那么p的后序后继就是q；</li>
<li>p是q的左孩子，且p没有右孩子，则p的后序后继就是q；</li>
<li>p是q的左孩子，且p有右孩子，则p的后序后继就是q的左子树中第一个被后序遍历的结点（左下角）</li>
</ol>
</li>
<li>p是根节点，则p没有后序后继。</li>
</ol>
</li>
</ul>
<h1>树、森林和二叉树的相互转换</h1>
<p>树的孩子兄弟存储结构与二叉树的存储结构本质上都是二叉链表，只是左右结点表达的含义不同：</p>
<ul>
<li>二叉树
<ol>
<li>lchild：结点的左孩子</li>
<li>rchild：结点的右孩子</li>
</ol>
</li>
<li>树的孩子兄弟表示法
<ol>
<li>child：结点的第一个孩子</li>
<li>sibling：结点的下一个兄弟</li>
</ol>
</li>
</ul>
<h2 id="树转换为二叉树">树转换为二叉树</h2>
<p>规则：孩子兄弟表示法：</p>
<ol>
<li>每个结点的左指针指向自己的第一个孩子</li>
<li>每个结点的右指针指向相邻的右兄弟</li>
</ol>
<p>即“<strong>左孩子，右兄弟</strong>”，<strong>由于根结点没有兄弟，所以转换后的二叉树没有右子树</strong>。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/a8bfb37d1d45859433611024ecc31fd2.png" alt="请添加图片描述"></p>
<p>树转换成二叉树的画法：</p>
<ol>
<li>
<p>在各兄弟结点之间加一条连线</p>
</li>
<li>
<p>对每一个结点，只保留它与第一个孩子之间的连线，其余都抹去</p>
</li>
<li>
<p>以树根为圆心，顺时针旋转45度</p>
</li>
</ol>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/4cbfb18f43c39d853f53855b45ea7ffa.png" alt="请添加图片描述"></p>
<h2 id="二叉树转换为树">二叉树转换为树</h2>
<p>把树转换为二叉树的过程逆过来即可：</p>
<ol>
<li>以树根为圆心，逆时针旋转45度</li>
<li>则同一层的为兄弟，顺着兄弟的路径找到上一层父结点，连线</li>
<li>抹去每一层结点之间的连线</li>
</ol>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/fa1b09a2a2ba6f3ceb12c20a9c9fd481.png" alt="请添加图片描述"></p>
<h2 id="森林转换为二叉树">森林转换为二叉树</h2>
<ol>
<li>对森林中的每一颗树都按照上面的方法转换为二叉树</li>
<li>每个树转换为二叉树后都没有右子树，那么就把森林中的第二棵树当做第一颗树的右子树，以此类推，最终整个森林就转变成了二叉树。</li>
</ol>
<h2 id="二叉树转换为森林">二叉树转换为森林</h2>
<ol>
<li>不停地将根结点有右孩子的二叉树的右孩子链接断开，直到不存在根结点有右孩子的二叉树为止；</li>
<li>然后将得到的多棵二叉树按照二叉树转化为树的规则依次转化即可。</li>
</ol>
<h2 id="树的遍历">树的遍历</h2>
<p>树的遍历有两种方式：先序遍历和后序遍历。</p>
<ol>
<li>
<p>先序遍历是先访问根结点，再依次访问根结点的每棵子树，访问子树时仍然遵循先根再子树的规则；</p>
</li>
<li>
<p>后序遍历是先依次访问根结点的每棵子树，再访问根结点，访问子树时仍然遵循先子树再根的规则。<br>
<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/dc1c4a82d16091dc9adb3531cccf7b05.png" alt="请添加图片描述"></p>
</li>
</ol>
<p>对于如图所示的树：先序遍历的结果为ABEFCGDHIJ，后序遍历的结果为EFBGCHIJDA。</p>
<p><strong>树转换为二叉树后，树的先序遍历对应二叉树的先序遍历，树的后序遍历对应二叉树的中序遍历（注意不是后序遍历）。</strong></p>
<p>所以，可以将树转换为二叉树后，借助遍历二叉树的方法来遍历树。假如一 棵树已经转化为二叉树来存储，要得到其先序遍历序列，只需先序遍历这棵二叉树；要得到其后序遍历序列，只需中序遍历这棵二叉树。</p>
<h2 id="森林的遍历">森林的遍历</h2>
<p>森林的遍历方式有两种：先序遍历和后序遍历。</p>
<ol>
<li>先序遍历的过程：先访问森林中第一 棵树的根结点，然后先序遍历第一 棵树中根结点的子树，最后先序遍历森林中除了第一 棵树以外的其他树。</li>
<li>后序遍历的过程：后序遍历第一棵树中根结点的子树，然后访问第一棵树的根结点，最后后序遍历森林中除去第一 棵树以外的其他树。</li>
</ol>
<p><strong>森林转换为二叉树，森林的先序遍历对应二叉树的先序遍历，森林的后序遍历对应二叉树的中序序列（注意不是后序遍历）。</strong></p>
<h1>二叉树的应用</h1>
<h2 id="赫夫曼树">赫夫曼树</h2>
<h3 id="赫夫曼二叉树">赫夫曼二叉树</h3>
<p>赫夫曼树又叫作最优二叉树，它的特点是带权路径最短。几个相关概念：</p>
<ol>
<li>路径：路径是指从树中一个结点到另一个结点的分支所构成的路线。</li>
<li>路径长度：路径长度是指路径上的分支数目。</li>
<li>树的路径长度：树的路径长度是指从根到每个结点的路径长度之和。</li>
<li>带权路径长度：结点具有权值，从该结点到根之间的路径长度乘以结点的权值，就是该结点的带权路径长度。</li>
<li><strong>树的带权路径长度（WPL）</strong>：树的带权路径长度是指树中所有叶子结点的带权路径长度之和。</li>
</ol>
<ul>
<li>
<p>构造赫夫曼二叉树</p>
<p>给定n个权值，用这n个权值来构造赫夫曼树的算法描述如下：</p>
<ol>
<li>将这n个权值分别看作只有根结点的n棵二叉树，这些二叉树构成的集合记为F。</li>
<li>从F中选出两棵根结点的权值最小的树（假设为a、b）作为左、右子树，构造一 棵新的二叉树c， 新的二叉树的根结点的权值为左、右子树根结点权值之和。</li>
<li>从F中删除a、b, 加入新构造的树c。</li>
<li>重复进行2、3两步，直到F中只剩下一 棵树为止，这棵树就是赫夫曼树。</li>
</ol>
</li>
<li>
<p>赫夫曼树的特点</p>
<ol>
<li><strong>树的带权路径长度最短</strong>。</li>
<li><strong>权值越大的结点，距离根结点越近</strong>。</li>
<li><strong>树中没有度为1的结点</strong>。这类树又叫作正则（严格）二叉树。</li>
<li>树中两个权值最小的结点一定是兄弟结点；</li>
<li>树中任一非叶结点的权值一定不小下一层任一结点的权值；</li>
<li>赫夫曼树的结点总数为2n-1，n为叶子结点个数，也是最开始给定权值的结点个数。</li>
<li>赫夫曼树不唯一，但WPL相同且最优。</li>
</ol>
</li>
</ul>
<h3 id="赫夫曼编码">赫夫曼编码</h3>
<p>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为<strong>固定长度编码</strong>。</p>
<p>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<strong>可变长度编码</strong>。</p>
<p>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</p>
<p>赫夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</p>
<p>任意一个字符的编码都不是另一个字符编码的前缀，则称这样的编码为前缀编码。前缀编码可以保证不会出现歧义。</p>
<ul>
<li>
<p>由赫夫曼树得到哈赫夫曼编码</p>
<ol>
<li>将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），根据频度大小构造出对应的赫夫曼树。</li>
<li>对赫夫曼树每个结点的左右分支编号，左0右1，则从根到每个结点的路径上的数字即为每个字符的赫夫曼编码。</li>
</ol>
<p>一个例子：假设有字符串s=“AAABBACCCDEEA”，按照上图的方法得到如图所示的赫夫曼树并对分支编号：</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ec77dfdf0c5a43f4cf3c78bbf901b0f8.png" alt="image-20210717233804817"></p>
<p>那么对ABCDE进行赫夫曼编码有：</p>
<ol>
<li>A=0</li>
<li>B=110</li>
<li>C=10</li>
<li>D=1110</li>
<li>E=1111</li>
</ol>
<p>可以看到，显然，所有字符结点都出现在叶结点中，且越靠近根结点的字符频度越高（权值越大），<strong>出现次数最多的字符编码长度就越短，而且赫夫曼编码属于前缀编码</strong>。根据赫夫曼树WPL最短的特性可知，<strong>赫夫曼编码产生的是最短前缀编码</strong>。</p>
</li>
</ul>
<h3 id="赫夫曼多叉树">赫夫曼多叉树</h3>
<p>赫夫曼二叉树是赫夫曼n叉树的一 种特例。</p>
<p>对于结点数目&gt;= 2 的待处理序列，都可以构造赫夫曼二叉树，但却不一 定能构造赫夫曼 n 叉树。</p>
<p>当发现无法构造时，需要补上权值为0的结点让整个序列凑成可以构造赫夫曼n叉树的序列。</p>
<p>例如：对于序列A(1)、B(3)、C(4)、D(6) (括号内为权值），就不能直接构造赫夫曼三叉树，需要补上一 个权值为0的结点H。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/155d465e9e92879998fa09bf79083222.png" alt="image-20210717234900685"></p>
<p>H结点的存在对WPL值没有影响，得到的仍然是最小WPL：(0*2)+(1*2)+(3*2)+(4*1)+(6*1)=18。</p>
<p>但要注意的是，二叉赫夫曼树和三叉赫夫曼树所得到的WPL是不同的，不要混淆最小的概念，这里的最小是说在含有n个带权叶结点的三叉树中，赫夫曼三叉树是WPL最小的。</p>
<h2 id="二叉排序树BST">二叉排序树BST</h2>
<ul>
<li>
<p>BST（Binary Search Tree）定义</p>
<p>二叉排序树或者是空树，或者是满足以下条件的树：</p>
<ol>
<li>若它的左子树不为空，则左子树上所有关键字的值均不大于（或不小于）根关键字的值</li>
<li>若它的右子树不为空，则右子树上所有关键字的值均不小于（或不大于）根关键字的值</li>
<li>左右子树又各是一颗二叉排序数。</li>
</ol>
<p>根据定义可知，二叉排序数的中序遍历是非递减有序（或非递增有序）的，没有特殊说明，BST均采取左小右大的分布。</p>
</li>
<li>
<p>存储结构</p>
<p>二叉排序树和二叉树的存储结构没有差别，都是有一个值域和两个指针域组成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> key;		</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BSTNode</span> *rchild;</span><br><span class="line">&#125;BSTNode;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找key</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">BSTSearch</span><span class="params">(BSTNode *bst,<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bst == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;	</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (key == bst-&gt;key) &#123;</span><br><span class="line">			<span class="keyword">return</span> bst;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bst-&gt;key) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bst-&gt;lchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bst-&gt;rchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>插入关键字</p>
<p>要插入关键字首先要找到插入位置，对于一个不存在于二叉排序树中的关键字，其查找不成功的位置就是该关键字的插入位置。</p>
<ol>
<li>查找关键字，当来到空指针的位置就插入，返回1，新插入的结点必是叶结点</li>
<li>如果找到关键字，则不需要再插入，返回0，插入失败</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSTInsert</span><span class="params">(BSTNode *bst, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		bst = (BSTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">		bst-&gt;lchild = bst-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		bst-&gt;key = key;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (key == bst-&gt;key) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bst-&gt;key) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">BSTInsert</span>(bst-&gt;lchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">BSTInsert</span>(bst-&gt;rchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除关键字</p>
<p>二叉排序树的删除操作是最麻烦的，因为必须保证删除操作之后继续维持树的“有序性”。假设将要被删除的结点为p，f是它的父结点，那么会出现三种情况：</p>
<ol>
<li>
<p>p是叶子结点。直接删除即可。</p>
</li>
<li>
<p>p只有右子树而没有左子树，或者p只有左子树没有右子树。此时，只需要删除p，把它的子树接在f上取代p的位置即可。</p>
</li>
<li>
<p>p既有右子树也有左子树。按照以下操作方法可以将情况3转换为情况1,2：</p>
<p>找到中序遍历序列中p的直接前驱m，或者，找到中序遍历序列中p的直接后继n，将p的值改为m或者n，之后删除原m或者原n。</p>
<p>原先的m或者n的删除方式必然是情况1,2中的某一种，这样就完成了情况3向情况1,2的转换。</p>
</li>
</ol>
</li>
<li>
<p>建立二叉排序树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBST</span><span class="params">(BSTNode *&amp;bst,<span class="type">int</span> key[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    bst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">BSTInsert</span>(bst,key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二叉平衡树AVL">二叉平衡树AVL</h2>
<ul>
<li>
<p>定义</p>
<p>二叉平衡树或者是空树，或者是满足以下条件的树：</p>
<ol>
<li>平衡二叉树的左右子树都是平衡二叉树</li>
<li>左右子树的高度差不超过1。</li>
</ol>
<p>即：以树中所有结点为根的树的左右子树高度之差不超过1。</p>
</li>
<li>
<p>平衡因子</p>
<p>一个结点的平衡因子为其左子树的高度减去右子树高度的差。</p>
<p>对于平衡二叉树，树中的所有结点的平衡因子的取值只能是-1、0 、1 三个值。</p>
</li>
<li>
<p><strong>平衡二叉树的查找</strong></p>
<p>任意关键字的查找，比较次数不超过AVL树的高度。</p>
<p>设N~h~表示高度为h的平衡二叉树所含有的最少结点数，则有：N~0~=0，N~1~=1，N~2~=2，N~3~=4，N~5~=7，……，N~h~=N~h-2~+N~h-1~+1。</p>
<p>这个结论也可以反过来求给定结点数的AVL树的查找所需要的最多比较次数（或树的最大高度）。</p>
</li>
<li>
<p>平衡调整</p>
<p>建立平衡二叉树的过程和建立二叉排序树的过程基本一 样，都是将关键字逐个插入空树中的过程。不同的是，在建立平衡二叉树的过程中，每插入一 个新的关键字都要进行检查，看是否新关键字的插入会使得原平衡二叉树失去平衡，即树中出现平衡因子绝对值&gt;1的结点。如果失去平衡则需要进行<strong>平衡调整</strong>。平衡二叉树的重点就是平衡调整。</p>
</li>
<li>
<p><strong>平衡调整的方法</strong></p>
<p>假定向平衡二叉树中插入一 个新结点后破坏了平衡二叉树的平衡性：</p>
<ol>
<li>首先要找出插入新结点后失去平衡的最小子树</li>
<li>调整这棵子树，使之成为平衡子树。最小不平衡子树调整后，整个树恢复平衡。</li>
</ol>
<p>最小不平衡子树是指距离插入结点最近，且以平衡因子绝对值大于1的结点作为根的子树，又称为最小不平衡子树。</p>
</li>
</ul>
<h3 id="二叉平衡树的平衡调整">二叉平衡树的平衡调整</h3>
<p>主要分为四种情况：LL右单旋转，RR左单旋转，LR先左后右双旋转，RL先右后左双旋转。</p>
<p>这里的L与R是对不平衡状态的描述：比如LL，就是指结点A的<strong>左孩子</strong>的<strong>左子树</strong>上插入了新结点导致A失去平衡。</p>
<ol>
<li>
<p>LL调整：某时刻在a的左孩子b的左子树Y上插入 一 个结点，导致 a 的左子树高度为 h+2 , 右子树高度为h，发生不平衡。</p>
<p>此时应把b向右旋转代替a成为根结点，这一过程称为右单旋转。</p>
<p>具体操作为：将a下移一 个结点高度，b 上移一 个结点高度，也就是将 b 从 a 的左子树取下，然后将b的右子树挂在a的左子树上，最后将a挂在b的右子树上以达到平衡。</p>
</li>
<li>
<p>RR调整：情况与LL调整类似，对称处理<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/7fd308748d5e2023cc950abff7e0ffd0.png" alt="请添加图片描述"><br>
即可。</p>
</li>
<li>
<p>LR调整：某时刻在a的左孩子b的右子树Y上插入一 个结点（不管是插在Y的左孩子还是右孩子，做法一样）导致不平衡。</p>
<p>需要做两次旋转，先左旋c后右旋b。</p>
<p>具体操作为：将c作为a和b两棵子树的根，b为左子树，a为右子树，c原来的左子树U作为b的右子树，c原来的右子树V作为a的左子树以达到平衡。这就是LR调整，也叫先左后右双旋转调整，因为调整的过程可以看成是先左旋c后右旋b。</p>
</li>
<li>
<p>RL调整：如果b在a的右子树上，且插入的结点在b的左子树上，即与图9-8a对称的情况，则此时只需将上述过程做左右对称处理即可。这种调整叫RL调整，也叫先右后左双旋转调整。</p>
</li>
</ol>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/33ef29bdcf93333fffb1b94ddc42e2d6.png" alt="请添加图片描述"></p>
<h1>典型例题</h1>
<h2 id="二叉树的性质相关">二叉树的性质相关</h2>
<ol>
<li>
<p>一颗完全二叉树有1001个结点，其中叶子结点的个数为（501）个。</p>
<blockquote>
<p>分析：完全二叉树一定是由一颗满二叉树从下到上，从右到左，挨个删除结点所得到的。</p>
<p>也就是说，一颗完全二叉树，度为1（分支为1）的结点一定是1或者0，如果有度为1的结点，它的孩子一定是二叉树最后一层最后一个结点。</p>
<p>假设度为1的结点数位1，即n~1~=1，那么n=n~0~+n~1~+n~2~=n~0~+1+n~0~-1=2n~0~=1001，n~0~=500.5，显然错误。</p>
<p>假设度为1的结点数为0，即n~1~=0，那么此时二叉树中只有度为0和度为2的结点，则n=n~0~+n~2~，根据性质2，又有n~0~=n~2~+1，则n=n~0~+n~2~=n~0~+n~0~-1=2n~0~-1=1001，得n~0~=501。</p>
</blockquote>
</li>
<li>
<p>假设高度为h的二叉树中只有度为0和2的结点，那么此类二叉树中所包含的结点数<strong>最少</strong>为（2h-1）个。</p>
<blockquote>
<p>要求度只有0和2，且结点最少，那么必然是类似二叉赫夫曼数的构造。</p>
<p>除了第一层只有1个根结点以外，其余每一层都只有2个结点，则结点数为2h-1。</p>
<p>如果题目要求结点最多，那么自然是满二叉树，此时结点数是2^h^-1。</p>
</blockquote>
</li>
<li>
<p>设树的度为4，其中度为1、2、3、4的结点个数分别为4、2、1、1，则树中的叶子结点个数为（8）个。</p>
<blockquote>
<p>根据性质4：n~0~=1+n~2~+2n~3~+…+(m-1)n~m~=1+2+2*1+3*1=8</p>
</blockquote>
</li>
<li>
<p>有n个叶子结点的二叉赫夫曼树的结点总数是（2n-1）个。</p>
</li>
<li>
<p>n个结点的线索二叉树含有的线索数为（n+1）。</p>
<blockquote>
<p>线索二叉树的线索数等于原二叉树中的空指针数=总结点数+1</p>
</blockquote>
</li>
<li>
<p>一颗具有1025个结点的二叉树的高度h的范围为（11~1025）。</p>
<blockquote>
<p>高度最高：每层只有一个结点，则高度为1025</p>
<p>高度最低：完全二叉树，根据性质10，h=[log~2~(1025+1)]向上取整，h=11</p>
</blockquote>
</li>
<li>
<p>在度为m的赫夫曼树中，叶子结点的个数为n，则非叶子结点的个数为（ ⌈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n-1}{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>⌉）个。</p>
<blockquote>
<p>在构造度为m的赫夫曼树的过程中，每次把m个叶子结点合并为一个父结点 （第一 次合并可能少于 m 个子结点），每次合并减少 m -1个结点。加入第一次合并了m个结点，为了统一计算给n-1，把第一次合并看成m-1个结点，共需要 ⌈(n-1)/(m-1)⌉次合并，向上取整是因为最后不一定能整除，此时会人为的补上结点形成最后一次合并，每次合并增加一 个非叶子结点。下图展示了度为3，则叶子结点个数为8的赫夫曼三叉树的合并过程，橙色的为人为补上的结点。</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/9bfe00ac282e5a616cb8d33ac8d5a4e4.png" alt="image-20210717221854178"></p>
</blockquote>
</li>
<li>
<p>已知一棵完全二叉树的第6层（设根为第1层）有8个叶子结点，则该完全二叉树的结点个数最多是（111）个。</p>
<blockquote>
<p>需要注意的是，树不一定是6层，不要陷入思维惯性，看到第6层有8个叶子结点，就下定论树只有6层。实际上，结点个数最多的情况下树有7层，第6层的8个叶子结点在第7层均没有孩子，即7层的满二叉树从7层右边往左去掉8*2=16个结点形成的完全二叉树。前6层为满二叉树，共有2^6^-1=63个结点，第7层有2^7-1^-16=48个结点，共计111个结点。</p>
</blockquote>
</li>
<li>
<p>已知一棵有2011个结点的树，它的叶子结点为116个，则该树转换成的二叉树中没有右孩子的结点个数为（1896）个。</p>
<blockquote>
<p>考虑极端情况：</p>
<p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ab426d38b7fe3f8268cacf7705f49274.png" alt="image-20210717223732140"></p>
<p>按照“左孩子，右兄弟”的规则构成二叉树，最后一个叶子结点加上上面1895个中间结点必然没有右孩子。</p>
</blockquote>
</li>
<li>
<p>高度为6的平衡二叉树，所有非叶结点的平衡因子均为1，则该平衡二叉树的结点总数为（N~6~=20）</p>
<blockquote>
<p>根据性质11可推得，高度为6的平衡二叉树的结点最少为20个，实际上，题目所有非叶结点的平衡因子均为1，暗含的信息也是指结点最少的极端情况，当所有非叶结点的平衡因子均为1时，此时增加一个结点，会使得某个结点的平衡因子变为0，而不影响平衡性。这也就是构成平衡二叉树结点最少的情况。</p>
</blockquote>
</li>
<li>
<p>n和m为一颗二叉树的两个结点，在中序遍历时，n在m前的条件是n在m的左边。(对)</p>
</li>
<li>
<p><strong>对于二叉树来说，不管是前序、中序、后序遍历，叶子结点在遍历序列中的先后顺序是相同的</strong>。（对）</p>
</li>
<li>
<p>一颗二叉树的先序序列和后续序列正好相反，则该二叉树的高度一定等于其结点数。（对）</p>
</li>
</ol>
<h2 id="算法题">算法题</h2>
<h3 id="求二叉树的总结点数">求二叉树的总结点数</h3>
<ol>
<li>
<p>采用中序、先序、后序任意一种方式遍历树来计算；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums = <span class="number">0</span>;	<span class="comment">//全局变量，一个计数器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nums++;	<span class="comment">//每次经过一个结点，计数器+1</span></span><br><span class="line">		<span class="built_in">getNodeNums</span>(bt-&gt;lchild);</span><br><span class="line">		<span class="built_in">getNodeNums</span>(bt-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>采用另外一种递归思路：如果树空，返回0；如果树非空，求其左子树的的结点数n1，右子树的结点数n2，返回n1+n2+1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n1, n2;</span><br><span class="line">	<span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		n1 = <span class="built_in">getNodeNums</span>(bt-&gt;lchild);</span><br><span class="line">		n2 = <span class="built_in">getNodeNums</span>(bt-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> n1 + n2 + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="求二叉树的叶子结点数">求二叉树的叶子结点数</h3>
<p>给上一题加上限制条件：左右孩子非空即可。</p>
<ul>
<li>
<p>方法一:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nums++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">getNodeNums</span>(bt-&gt;lchild);</span><br><span class="line">		<span class="built_in">getNodeNums</span>(bt-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n1, n2;</span><br><span class="line">	<span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;	<span class="comment">//空树返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)&#123;	<span class="comment">//如果是叶子结点，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		n1 = <span class="built_in">getNodeNums</span>(bt-&gt;lchild);	<span class="comment">//既不是空树也不是叶子结点，求它的左子树的叶子结点数</span></span><br><span class="line">		n2 = <span class="built_in">getNodeNums</span>(bt-&gt;rchild);	<span class="comment">//求它的右子树的叶子结点数</span></span><br><span class="line">		<span class="keyword">return</span> n1 + n2 ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="把二叉树的叶子结点从左到右串成链表">把二叉树的叶子结点从左到右串成链表</h3>
<p>具体要求就是修改叶子结点的rchild指针，指向它右边的叶子结点。用head和tail分别指向链表的表头和表尾。</p>
<p>分析：这里要用到一个非常重要的性质：不管是先序遍历、中序遍历还是后序遍历，在它们的遍历过程中叶子结点被访问的先后顺序都是不变的，都是从左往右。任选一种，修改visit函数即可，这里采用先序遍历的模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkNodes</span><span class="params">(BTNode *bt, BTNode *&amp;head, BTNode *&amp;tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否是叶子结点</span></span><br><span class="line">		<span class="keyword">if</span> (bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//开始串接链表</span></span><br><span class="line">            <span class="comment">//head为空，说明bt是表头，表尾指针和表头指针同时指向它</span></span><br><span class="line">			<span class="keyword">if</span> (!head) &#123;</span><br><span class="line">				head = bt;</span><br><span class="line">				tail = bt;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//bt不是表头，就把它接在表尾，同时挪动表尾指针</span></span><br><span class="line">				tail-&gt;rchild = bt;</span><br><span class="line">				tail = bt;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="built_in">linkNodes</span>(bt-&gt;lchild, head, tail);</span><br><span class="line">		<span class="built_in">linkNodes</span>(bt-&gt;rchild, head, tail);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带有指向父结点指针的二叉树">带有指向父结点指针的二叉树</h3>
<ol>
<li>
<p>修改数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode_p</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTNode_p</span> *lchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTNode_p</span> *rchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BTNode_p</span> *parent;	<span class="comment">//增加父亲指针</span></span><br><span class="line">&#125;BTNode_p;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>遍历二叉树，给每个结点都设立父结点，我们需要两个参数，当前结点和它的父结点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历二叉树设立父结点</span></span><br><span class="line"><span class="comment">//传入根结点和它的父结点NULL即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setParentTree</span><span class="params">(BTNode_p *btp, BTNode_p *par)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (btp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		btp-&gt;parent = par;</span><br><span class="line">		btp = par;</span><br><span class="line">		<span class="built_in">setParentTree</span>(btp-&gt;lchild, btp);</span><br><span class="line">		<span class="built_in">setParentTree</span>(btp-&gt;rchild, btp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="将一颗满二叉树的先序序列转换为后序序列">将一颗满二叉树的先序序列转换为后序序列</h3>
<p>假设先序序列存储在数组pre[L1,…,R1]中，请把后序序列存储到post[L2,…,R2]数组中。</p>
<p>分析：根据满二叉树的特性可知，满二叉树具有一个重要的特性就是左右子树的结点数目是相等的，利用这一特性，我们可以很自然的根据先序序列唯一的满二叉树：序列的第一个元素就是根结点，然后将剩余的元素等分为两份，则分别为左子树序列和右子树序列。那如何把先序序列转换为后序序列呢？根据先序遍历和后序遍历的特性，它们的叶子结点的相对位置都是相同的，我们只需要递归地把先序序列中根结点的位置放到序列的末尾即可。但是，这种方法只适合于满二叉树，正是因为是满二叉树，我们才能每次正确的找到子树的根结点。</p>
<p>这里的主要难点就在于左右子树的下标问题，假设先序序列为pre[L1,…,R1]，后序序列将存储在post[L2,…,R2]中，那么：</p>
<p>左子树的下标：</p>
<ul>
<li>
<p>L1+1：在pre数组中除去第一个元素（根结点），剩下的第一个就是左子树下标的开始位置</p>
</li>
<li>
<p>(L1 + 1 + R1) / 2：在pre数组中L1+1到R2的中间位置就是左子树的末端下标</p>
</li>
<li>
<p>L2——0：在post数组中左子树的序列的开始位置始终在数组开始位置</p>
</li>
<li>
<p>R2——(L2 + R2 - 1) / 2：在post数组中L2到R2-1的中间位置就是左子树的末端下标</p>
</li>
</ul>
<p>左子树的下标：</p>
<ul>
<li>(L1 + 1 + R1) / 2 + 1：在pre数组中左子树的末端下标+1就是右子树的开始位置</li>
<li>R1：在pre数组中从右子树的开始位置一直到pre数组的末端都是右子树的结点</li>
<li>(L2 + R2 - 1) / 2 + 1：在post数组中左子树的末端下标+1就是右子树的序列的开始位置</li>
<li>R2 - 1：在post数组中从右子树的开始位置一直到post数组的倒数第二个位置（倒数第一是根结点）都是右子树的结点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把先序序列pre数组中下标L1到R1的元素转换为后序序列存到post数组中的L2到R2位置上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preToPost</span><span class="params">(<span class="type">char</span> pre[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">char</span> post[], <span class="type">int</span> L2, <span class="type">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//L1&gt;R1为递归结束的条件</span></span><br><span class="line">	<span class="keyword">if</span> (L1 &lt;= R1) &#123;	</span><br><span class="line">        <span class="comment">//将根结点放到后序序列的最后一位</span></span><br><span class="line">		post[R2] = pre[L1];</span><br><span class="line">        <span class="comment">//递归转换左子树</span></span><br><span class="line">		<span class="built_in">preToPost</span>(pre, L1 + <span class="number">1</span>, (L1 + <span class="number">1</span> + R1) / <span class="number">2</span>, post, L2, (L2 + R2 - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//递归转换右子树</span></span><br><span class="line">		<span class="built_in">preToPost</span>(pre, (L1 + <span class="number">1</span> + R1) / <span class="number">2</span> + <span class="number">1</span>, R1, post, (L2 + R2 - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>, R2 - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树的深度">求二叉树的深度</h3>
<blockquote>
<p>写一个算法求二叉树的深度，二叉树以二叉链表的形式存储。</p>
</blockquote>
<p>分析：假设这棵树的左子树的深度为ld，右子树的深度为rd，那这棵二叉树的深度等于ld和rd中的较大者再加一（根结点本身），采用递归的思想，先求左子树的深度，再求右子树的深度，最后返回二者中的较大者+1，按照&quot;左右中&quot;的遍历顺序，这不就正好是后序遍历吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二叉树的深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ld, rd;</span><br><span class="line">	<span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;						<span class="comment">//作为递归结束标志，空树的深度自然为0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ld = <span class="built_in">getDepth</span>(bt-&gt;lchild);			<span class="comment">//递归求得左子树的深度</span></span><br><span class="line">		rd = <span class="built_in">getDepth</span>(bt-&gt;rchild);			<span class="comment">//递归求得右子树的深度</span></span><br><span class="line">		<span class="keyword">return</span> (ld &gt; rd ? ld : rd) + <span class="number">1</span>;		<span class="comment">//返回二者中的较大者+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树的宽度">求二叉树的宽度</h3>
<blockquote>
<p>写一个算法，求出二叉树的宽度（结点数最多的那一层上的结点个数），二叉树以二叉链表的形式存储。</p>
</blockquote>
<p>分析：直接在二叉树中求最大宽度显然不是一件容易的事情，如果我们能把树中的元素都存到线性表（队列）里，并记录下每一个结点所在的层数，直接遍历线性表就可以得到最大宽度了。那么我们要做的事情就变成了：</p>
<ol>
<li>遍历二叉树，求得树中每个结点所在的层数，并把信息存到队列里。</li>
<li>遍历队列，找出层数相同的最大结点个数</li>
</ol>
<p>根结点的层数显然为1，根结点的孩子的层数就为1+1。这就说明，只要我们当前结点的层数，就能知道它的孩子所在的层数。那该采取哪种二叉树遍历方式呢？显然是层次遍历，我们当然希望把结点一层一层的从左往右逐个放到线性表里，那么在同一层的结点就是相邻的，这样只需要一次遍历就能求得最大宽度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据我们的需求，定义队列中元素的结构体：结点+层数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	BTNode *node;	<span class="comment">//结点指针</span></span><br><span class="line">	<span class="type">int</span> lno;		<span class="comment">//结点所在层数</span></span><br><span class="line">&#125;St;		</span><br><span class="line"><span class="comment">//求二叉树的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化队列</span></span><br><span class="line">	St que[maxSize];				<span class="comment">//队列尽可能的大，能放下树中的所有结点</span></span><br><span class="line">	<span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//定义两个临时变量用于接收每次出队元素保存的信息</span></span><br><span class="line">	BTNode *q;</span><br><span class="line">	<span class="type">int</span> Lno = <span class="number">0</span>;										</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//根结点入队，它所在的层数是1</span></span><br><span class="line">		que[++rear].node = bt;					</span><br><span class="line">		que[++rear].lno = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//队列非空时循环</span></span><br><span class="line">		<span class="keyword">while</span> (front != rear) &#123;						</span><br><span class="line">			<span class="comment">//出队</span></span><br><span class="line">			q = que[++front].node;					</span><br><span class="line">			Lno = que[++front].lno;	</span><br><span class="line">			<span class="comment">//左右孩子入队</span></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;				<span class="comment">//如果出队结点q有左孩子，则左孩子入队，它所在的层数是q所在的层数+1</span></span><br><span class="line">				que[++rear].node = q-&gt;lchild;</span><br><span class="line">				que[++rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;				<span class="comment">//如果出队结点q有右孩子，则右孩子入队，它所在的层数是q所在的层数+1</span></span><br><span class="line">				que[++rear].node = q-&gt;rchild;</span><br><span class="line">				que[++rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        最后一个结点出队后，Lno就保存的是树中的最大层数;</span></span><br><span class="line"><span class="comment">        上面所说的出队，并没有将元素从队列中删除，只是挪动了队头指针;</span></span><br><span class="line"><span class="comment">        遍历队列，求得最大宽度:</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> maxWidth = <span class="number">0</span>;								<span class="comment">//宽度</span></span><br><span class="line">	<span class="type">int</span> num;										<span class="comment">//计数器</span></span><br><span class="line">	<span class="type">int</span> last=<span class="number">0</span>;										<span class="comment">//last用来保存每次查找下一层结点时的开始位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lno; i++)					<span class="comment">//分别查找第一层、第二层...第Lno层的结点个数</span></span><br><span class="line">	&#123;</span><br><span class="line">		num = <span class="number">0</span>;	</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>  j = last; j &lt; rear; j++)			<span class="comment">//从last位置开始统计第i层结点的个数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (que[j].lno == i) &#123;					<span class="comment">//每发现一个第i层的结点，计数器+1</span></span><br><span class="line">				num++;</span><br><span class="line">				<span class="keyword">if</span> (num &gt; maxWidth) maxWidth = num;	<span class="comment">//刷新最大宽度值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (que[j+<span class="number">1</span>].lno &gt; i) &#123; <span class="comment">//下一个结点不是第i层（必然是i+1层），就记录下次开始的位置并跳出循环找下一层</span></span><br><span class="line">				last = j + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxWidth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于树中结点时按照一层一层从左往右的顺序存放的，那么层数相同的结点在队列中必然是相互挨着的，所以我们可以设置一个结束标志last，当发现下一个元素的层数不是i时，就直接跳出循环，下一次，找i+1层的元素时就直接从last开始找。所以，只需要遍历一次队列就够了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="求二叉树指定结点所在的层数">求二叉树指定结点所在的层数</h3>
<p>方法一：利用层次遍历，把结点和它所在的层数信息保存在一个新的数据结构中（跟上一题求最大宽度是的做法一样），然后保存在一个队列中，遍历队列即可解决问题。</p>
<p>方法二：利用递归遍历，定义一个全局变量层数L，初始值为1，每次遍历左孩子的时候就L+1，每次遍历完右孩子的时候将要返回根结点时就给L-1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> L = <span class="number">1</span>;	<span class="comment">//全局变量L表示层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leno</span><span class="params">(BTNode* p, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == x) &#123;		<span class="comment">//如果p-&gt;data==x，就输出层数L</span></span><br><span class="line">			cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		++L;					<span class="comment">//每次遍历左孩子前就给层数+1</span></span><br><span class="line">		<span class="built_in">leno</span>(p-&gt;lchild,x);</span><br><span class="line">		<span class="built_in">leno</span>(p-&gt;rchild,x);</span><br><span class="line">		--L;					<span class="comment">//每次遍历完右孩子放回根结点前，就给层数-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据先序序列和中序序列构造二叉树">根据先序序列和中序序列构造二叉树</h3>
<blockquote>
<p>二叉树的先序序列存储在一维数组pre[L1,…,R1]中，中序序列存储在一维数组in[L2,…,R2]中，（L1,L2,R1,R2均表示了数组中元素的下标范围，元素为char型），假设二叉树中各结点中数据值不相同，请给出由pre[L1,…,R1]和in[L2,…,R2]构造二叉树的算法。</p>
</blockquote>
<p>分析：根据先序序列和中序序列构建二叉树：</p>
<ol>
<li>
<p>根据先序序列的第一个结点找到根结点</p>
</li>
<li>
<p>在中序序列中找到根结点的位置i，i左边就是左子树，i右边就是右子树：</p>
<p>在in中，从L2到i-1就是左子树，i+1到R2就是右子树</p>
<p>与之对应的左子树在pre的位置是L1+1到L1+（i-L2）,右子树的位置是L1+（i-L2）+1到R1</p>
</li>
<li>
<p>重复1，2两步，递归地构建左右子树，当L1-R1&lt;0（表示待处理序列的长度&lt;0）时递归结束</p>
</li>
</ol>
<p>这个算法的关键是确定左右子树的序列在pre和in数组中的下标。给出实例结合代码分析。</p>
<p>先序遍历pre：ABDECFG：（A（B（D）（E））（C（F）（G）））</p>
<p>中序遍历in：DBEAFCG：（（（D）B（E））A（（F）C（G）））</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由pre[L1,...,R1]和in[L2,...,R2]构造二叉树</span></span><br><span class="line"><span class="function">BTNode *<span class="title">createBT</span><span class="params">(<span class="type">char</span> pre[], <span class="type">char</span> in[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//L1&gt;R1说明处理的序列长度小于0，返回NULL，是递归结束的条件</span></span><br><span class="line">    <span class="keyword">if</span> (L1 &gt; R1) 	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//构造根节点</span></span><br><span class="line">	BTNode *bt;				</span><br><span class="line">	bt = (BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">	bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//查找pre[L1]在in数组中的位置，用i记录下来</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = L2;i &lt;= R2;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (in[i] == pre[L1])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//给bt的各参数赋值</span></span><br><span class="line">	bt-&gt;data = in[i];	</span><br><span class="line">    <span class="comment">//递归构建bt的左右子树</span></span><br><span class="line">    <span class="comment">//pre[L1 + 1,...,L1 + i - L2]是左子树先序序列，pre[L1 + i - L2 + 1,..., R1]是右子树的先序序列</span></span><br><span class="line">    <span class="comment">//in[L2,..., i - 1]是左子树的中序序列，in[i + 1,..., R2]是右子树的中序序列</span></span><br><span class="line">	bt-&gt;lchild = <span class="built_in">createBT</span>(pre, in, L1 + <span class="number">1</span>, L1 + i - L2, L2, i - <span class="number">1</span>);</span><br><span class="line">	bt-&gt;rchild = <span class="built_in">createBT</span>(pre, in, L1 + i - L2 + <span class="number">1</span>, R1, i + <span class="number">1</span>, R2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建完成后返回根节点</span></span><br><span class="line">	<span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1，每次遍历完右孩子的时候将要返回根结点时就给L-1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> L = <span class="number">1</span>;	<span class="comment">//全局变量L表示层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leno</span><span class="params">(BTNode* p, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data == x) &#123;		<span class="comment">//如果p-&gt;data==x，就输出层数L</span></span><br><span class="line">			cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		++L;					<span class="comment">//每次遍历左孩子前就给层数+1</span></span><br><span class="line">		<span class="built_in">leno</span>(p-&gt;lchild,x);</span><br><span class="line">		<span class="built_in">leno</span>(p-&gt;rchild,x);</span><br><span class="line">		--L;					<span class="comment">//每次遍历完右孩子放回根结点前，就给层数-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据先序序列和中序序列构造二叉树-2">根据先序序列和中序序列构造二叉树</h3>
<blockquote>
<p>二叉树的先序序列存储在一维数组pre[L1,…,R1]中，中序序列存储在一维数组in[L2,…,R2]中，（L1,L2,R1,R2均表示了数组中元素的下标范围，元素为char型），假设二叉树中各结点中数据值不相同，请给出由pre[L1,…,R1]和in[L2,…,R2]构造二叉树的算法。</p>
</blockquote>
<p>分析：根据先序序列和中序序列构建二叉树：</p>
<ol>
<li>
<p>根据先序序列的第一个结点找到根结点</p>
</li>
<li>
<p>在中序序列中找到根结点的位置i，i左边就是左子树，i右边就是右子树：</p>
<p>在in中，从L2到i-1就是左子树，i+1到R2就是右子树</p>
<p>与之对应的左子树在pre的位置是L1+1到L1+（i-L2）,右子树的位置是L1+（i-L2）+1到R1</p>
</li>
<li>
<p>重复1，2两步，递归地构建左右子树，当L1-R1&lt;0（表示待处理序列的长度&lt;0）时递归结束</p>
</li>
</ol>
<p>这个算法的关键是确定左右子树的序列在pre和in数组中的下标。给出实例结合代码分析。</p>
<p>先序遍历pre：ABDECFG：（A（B（D）（E））（C（F）（G）））</p>
<p>中序遍历in：DBEAFCG：（（（D）B（E））A（（F）C（G）））</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由pre[L1,...,R1]和in[L2,...,R2]构造二叉树</span></span><br><span class="line"><span class="function">BTNode *<span class="title">createBT</span><span class="params">(<span class="type">char</span> pre[], <span class="type">char</span> in[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//L1&gt;R1说明处理的序列长度小于0，返回NULL，是递归结束的条件</span></span><br><span class="line">    <span class="keyword">if</span> (L1 &gt; R1) 	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//构造根节点</span></span><br><span class="line">	BTNode *bt;				</span><br><span class="line">	bt = (BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">	bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//查找pre[L1]在in数组中的位置，用i记录下来</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = L2;i &lt;= R2;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (in[i] == pre[L1])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//给bt的各参数赋值</span></span><br><span class="line">	bt-&gt;data = in[i];	</span><br><span class="line">    <span class="comment">//递归构建bt的左右子树</span></span><br><span class="line">    <span class="comment">//pre[L1 + 1,...,L1 + i - L2]是左子树先序序列，pre[L1 + i - L2 + 1,..., R1]是右子树的先序序列</span></span><br><span class="line">    <span class="comment">//in[L2,..., i - 1]是左子树的中序序列，in[i + 1,..., R2]是右子树的中序序列</span></span><br><span class="line">	bt-&gt;lchild = <span class="built_in">createBT</span>(pre, in, L1 + <span class="number">1</span>, L1 + i - L2, L2, i - <span class="number">1</span>);</span><br><span class="line">	bt-&gt;rchild = <span class="built_in">createBT</span>(pre, in, L1 + i - L2 + <span class="number">1</span>, R1, i + <span class="number">1</span>, R2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建完成后返回根节点</span></span><br><span class="line">	<span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zyw9825.github.io">zyw9825</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">https://zyw9825.github.io/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zyw9825.github.io" target="_blank">晃在云淡风轻</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/" title="数据结构六——图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构六——图</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构四——数组、矩阵与广义表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构四——数组、矩阵与广义表</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="数据结构一——线性表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">数据结构一——线性表</div></div></a></div><div><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E2%80%94%E2%80%94%E4%B8%B2/" title="数据结构三——串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">数据结构三——串</div></div></a></div><div><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="数据结构二——栈与队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">数据结构二——栈与队列</div></div></a></div><div><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/" title="数据结构六——图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">数据结构六——图</div></div></a></div><div><a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构四——数组、矩阵与广义表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">数据结构四——数组、矩阵与广义表</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20230408141525.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zyw9825</div><div class="author-info__description">你且迷这风浪永远二十赶朝暮</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zyw9825"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zyw9825" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zyw_9825@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=765830653&amp;website=www.oicqzone.com" target="_blank" title="添加QQ好友"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_44238142?spm=1010.2135.3001.5421" target="_blank" title="csdn"><i class="fa-solid fa-blog"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果图片或评论无法正常加载，请使用魔法上网</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">树的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">二叉树的主要性质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">二叉树深度优先遍历算法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">6.2.</span> <span class="toc-text">层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%86%99%E5%87%BA%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">快速写出遍历序列的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">根据遍历序列确定二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">二叉树遍历算法的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.</span> <span class="toc-text">二叉树深度优先遍历算法的非递归实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.2.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">线索二叉树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">7.2.2.</span> <span class="toc-text">中序线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">7.2.3.</span> <span class="toc-text">先序线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">7.2.4.</span> <span class="toc-text">后序线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%9F%A5%E6%89%BE%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7"><span class="toc-number">7.2.5.</span> <span class="toc-text">手动查找线索二叉树中的前驱与后继</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">树、森林和二叉树的相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.1.</span> <span class="toc-text">树转换为二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="toc-number">8.2.</span> <span class="toc-text">二叉树转换为树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">森林转换为二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">8.4.</span> <span class="toc-text">二叉树转换为森林</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.5.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.6.</span> <span class="toc-text">森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">9.1.</span> <span class="toc-text">赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.1.1.</span> <span class="toc-text">赫夫曼二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">9.1.2.</span> <span class="toc-text">赫夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-number">9.1.3.</span> <span class="toc-text">赫夫曼多叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91BST"><span class="toc-number">9.2.</span> <span class="toc-text">二叉排序树BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91AVL"><span class="toc-number">9.3.</span> <span class="toc-text">二叉平衡树AVL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4"><span class="toc-number">9.3.1.</span> <span class="toc-text">二叉平衡树的平衡调整</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">典型例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">10.1.</span> <span class="toc-text">二叉树的性质相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%BB%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">10.2.1.</span> <span class="toc-text">求二叉树的总结点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">求二叉树的叶子结点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E4%B8%B2%E6%88%90%E9%93%BE%E8%A1%A8"><span class="toc-number">10.2.3.</span> <span class="toc-text">把二叉树的叶子结点从左到右串成链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E6%8C%87%E5%90%91%E7%88%B6%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.2.4.</span> <span class="toc-text">带有指向父结点指针的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E9%A2%97%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97"><span class="toc-number">10.2.5.</span> <span class="toc-text">将一颗满二叉树的先序序列转换为后序序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">10.2.6.</span> <span class="toc-text">求二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6"><span class="toc-number">10.2.7.</span> <span class="toc-text">求二叉树的宽度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E6%89%80%E5%9C%A8%E7%9A%84%E5%B1%82%E6%95%B0"><span class="toc-number">10.2.8.</span> <span class="toc-text">求二叉树指定结点所在的层数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.2.9.</span> <span class="toc-text">根据先序序列和中序序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-2"><span class="toc-number">10.2.10.</span> <span class="toc-text">根据先序序列和中序序列构造二叉树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/" title="数据结构六——图">数据结构六——图</a><time datetime="2023-04-09T12:15:47.000Z" title="发表于 2023-04-09 20:15:47">2023-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构五——树与二叉树">数据结构五——树与二叉树</a><time datetime="2023-04-09T12:14:47.000Z" title="发表于 2023-04-09 20:14:47">2023-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="数据结构四——数组、矩阵与广义表">数据结构四——数组、矩阵与广义表</a><time datetime="2023-04-09T12:13:47.000Z" title="发表于 2023-04-09 20:13:47">2023-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E2%80%94%E2%80%94%E4%B8%B2/" title="数据结构三——串">数据结构三——串</a><time datetime="2023-04-09T12:12:47.000Z" title="发表于 2023-04-09 20:12:47">2023-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="数据结构二——栈与队列">数据结构二——栈与队列</a><time datetime="2023-04-09T12:11:47.000Z" title="发表于 2023-04-09 20:11:47">2023-04-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By zyw9825</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-test-eoihet3sd-zyw9825.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div class="aplayer no-destroy" data-lrctype="2" data-id="922753585" data-order="random" data-listmaxheight="200px" data-theme="#2980b9" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>