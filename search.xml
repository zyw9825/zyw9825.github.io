<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小波变换</title>
      <link href="/2025/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"/>
      <url>/2025/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="小波变换到底变换什么？">小波变换到底变换什么？</h1><p>在信号处理中，数学变换通常应用于信号，以获取原始信号中不容易获得的更多信息。</p><p>这里得原始信号是指<strong>时域信号</strong>。当我们绘制绝大多数信号时，横轴往往是<strong>时间</strong>，而纵轴往往是<strong>振幅</strong>。</p><p>这种<strong>时间-振幅</strong>的信号表示方法，并不总是最合适的，很多时候，最重要的信息隐藏在信号的<strong>频率</strong>内容中。比如：</p><ul><li>生物医学信号 ：如心电图（ECG）、脑电图（EEG）等，通过频谱分析可以检测异常的生理状态。</li><li>电力信号 ：电网中的电流通常是 50Hz 或 60Hz 的正弦波，如果出现其他频率成分，可能意味着电路故障。</li></ul><p>频率表示单位时间内某个周期性事件发生的次数，单位是周期/秒，也称为<strong>赫兹 Hz</strong>。在信号处理中，频率通常用来描述信号的变化速度。如果一个变量快速变化，我们说它是<strong>高频</strong>的，如果一个变量缓慢变化，即平滑地变化，我们说它是<strong>低频</strong>的。信号的<strong>频谱</strong>显示了该信号中存在哪些<strong>频率</strong>。</p><p>信号的频率成分要怎么测量呢？</p><p>要测量信号的频率成分，最常用的方法是使用<strong>傅里叶变换（Fourier Transform, FT）</strong> 。傅里叶变换的基本思想是：任何复杂的信号都可以分解为多个不同频率的正弦波的叠加。</p><p>傅里叶变换的结果是一个<strong>频率-振幅图</strong> ，横轴是频率，纵轴是对应频率的振幅值。振幅越大，表示该频率成分在信号中越显著。这个频率-振幅图就被称为<strong>频谱</strong>（Frequency Spectrum），它揭示了信号中包含的<strong>频率成分</strong>及其<strong>强度</strong>。换句话说，<em>它告诉我们哪些频率存在，以及它们的相对强度如何</em>。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/FFT-Time-Frequency-View_hu24c1c8fe894ecd0dad24174b2bed08c9_99850_800x0_resize_lanczos_2.png" alt="时域和频域的傅里叶变换|500"></p><p>如今，傅里叶变换 FT 在许多领域被广泛使用，尤其是在电气工程和信号处理领域，但它并不是唯一可以用来分析信号的数学变换。实际上，还有许多其他变换技术，它们各自有特定的应用场景、优势和局限性。</p><p>那么，傅里叶变换的局限性是什么呢？</p><p>傅里叶变换是一种可逆变换（WT 也是），也就是说，它可以将信号从一个域转换到另一个域，并且也可以通过<strong>逆变换</strong>将信号还原回原来的域，而不会丢失原始信息。但关键在于，傅里叶变换只能显示信号中<em>有哪些频率</em>，但无法告诉我们这些<em>频率什么时候出现</em> 。</p><p>对于**平稳信号（**Stationary Signals）来说，它的频率内容不随时间变化，所有频率成分存在于整个信号持续期间内。比如，100Hz 和 50Hz 交替出现，</p><p>对于<strong>非平稳信号</strong>（Non-stationary Signals）来说，频率内容会随时间变化。比如，前 300ms 是 100Hz，后 300ms 是 50Hz 等。</p><p>对这两个信号做傅里叶变换，得到的频谱图几乎<strong>完全相同</strong>，傅里叶变换只会告诉你有两个频率成分，但是我们无法知道这些频率出现的时间信息。对于平稳信号，我们并不需要时间信息，但是对于非平稳信号，时间信息就非常重要。</p><p>当需要对频率进行时间定位时，就需要对信号进行时频变换。小波变换就是这种类型的变换，还有其他一些变换也能提供这种信息，如短时傅里叶变换、维格纳分布等。</p><p><strong>小波变换适合用来分析非平稳信号，而傅里叶变换适合用来分析平稳信号。</strong></p><p>在了解小波变换之前，有必要对傅里叶变换与短时傅里叶变换有一定的了解。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/v2-f734c97d6bb838ef53edc475409825ba_1440w.jpg" alt="img"></p><h1 id="傅里叶变换与短时傅里叶变换">傅里叶变换与短时傅里叶变换</h1><h2 id="傅里叶变换">傅里叶变换</h2><p>19 世纪，法国数学家傅里叶提出了傅里叶级数（Fourier Series），用于表示<strong>周期函数</strong>，他证明了：</p><blockquote><p>“一个周期函数可以分解为无穷多个正弦波和余弦波的叠加，这些波具有不同的频率、振幅和相位。 ”</p></blockquote><p>后来，傅里叶的思想被扩展到<strong>非周期函数</strong> 上，从而诞生了<strong>傅里叶变换</strong> （Fourier Transform）。后来，快速傅里叶变换（FFT）的提出，使得 FT 变得更加流行。</p><p>傅里叶变换将一个非周期信号从时域转换到频域以揭示其频率成分。</p><p>正向傅里叶变换：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">X(f) = \int_{-\infty}^{\infty} x(t) e^{-j2\pi ft} dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>逆傅里叶变换：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>X</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mi>j</mi><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">x(t) = \int_{-\infty}^{\infty} X(f) e^{j2\pi ft} df</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span></span></span></span></span></p><p>在上式中，各部分的含义如下：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>：原始信号，时域函数（以时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 为自变量）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>：频域函数，表示信号在频率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 上的“能量”或“贡献”</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>：频率，单位通常为 Hz（赫兹）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>：虚数单位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>j</mi><mn>2</mn></msup><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j^2 = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e^{-j2\pi f t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>：复指数函数，用来提取信号在频率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 上的成分</li></ul><p>前面将，<strong>任何一个复杂的信号都可以看成由许多不同频率的正弦波（或余弦波）叠加而成，傅里叶变换的作用就是找出这些正弦波的频率和强度</strong>。</p><p>在正向傅里叶变换中，把信号 $ x(t) $ 和某个特定频率 $ f $ 的复指数函数（$ e^{-j2\pi ft} $）相乘，并在整个时间范围内积分。这实际上是在做一种“匹配”或“相似性检测”操作：</p><ul><li>如果信号中包含频率为 $ f $ 的成分，那么这个积分的结果就会比较大；</li><li>如果不包含这个频率，结果就接近于零；</li></ul><p>所以，这个积分的结果告诉我们：在信号中有多大的“能量”或“成分”对应频率 $ f $。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的负指数函数可以写成：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi></mrow></msup><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><mi>j</mi><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e^{-j2\pi ft} = \cos(2\pi ft) - j\sin(2\pi ft)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span></p><p>它由实部（余弦）和虚部（正弦）组成。因此，傅里叶变换实际上是将信号与不同频率的正弦和余弦波进行比较。信号 $ x(t) $ 和（$ e^{-j2\pi ft} $）相乘，其实就是在测试信号中是否包含频率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的成分，当信号中含有某个特定频率  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的成分时，这个成分就会和对应的正弦波（或余弦波）高度匹配，它们的乘积在整个时间范围内积分后，会得到一个较大的数值。这个数值代表的就是该频率成分在信号中的“强度”或“存在程度”。</p><p>可以看到，傅里叶变换是一个<strong>积分过程</strong> ，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">t=−∞</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">t=+∞</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span> 对整个信号进行分析，每个频率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 都要进行一次这样的积分运算，最终的结果是一个关于频率的函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>，即频域表示。</p><p>积分覆盖了整个时间范围，也就是说，不管某个频率成分是在信号的早期、中期还是晚期出现，都会被同等对待。这也证明，<strong>傅里叶变换并不关心这些频率成分出现在什么时候，只关心它们是否存在以及有多强，它没有时间定位能力</strong>。这也是为什么傅里叶变换只适用于平稳信号。</p><p>那么，非平稳信号又该用什么工具来处理呢？</p><h2 id="短时傅里叶变换">短时傅里叶变换</h2><p>短时傅里叶变换（STFT）被用来处理非平稳信号，解决了傅里叶变换无法提供时间定位信息的缺点。相比普通傅里叶变换只能给出整个信号的整体频谱，<strong>STFT 能展示不同时间段的频谱</strong>。</p><p>STFT 的思想来自于一个基本的假设：我们能否假设非平稳信号中的某些部分是平稳的？答案是肯定的。</p><p>在 STFT 中，将非平稳信号看作由多个局部平稳的小段组成，并在每一段上使用傅里叶变换。</p><ol><li><p>选择一个合适的窗函数  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>；</p></li><li><p>从信号起点开始（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）滑动窗函数；</p></li><li><p>在每个窗口位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 上：</p><ul><li><p>用窗函数截取信号的一部分；</p></li><li><p>对这部分信号进行傅里叶变换；</p></li><li><p>得到当前时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 下的频谱；</p></li></ul></li><li><p>将所有窗口的结果组合起来，形成一个完整的时频图。</p></li></ol><p>短时傅里叶变换的数学定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>STFT</mtext><mi>x</mi></msub><mo stretchy="false">(</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>w</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\text{STFT}_x(t&#x27;, f) = \int_{-\infty}^{\infty} x(t) \cdot w^*(t - t&#x27;) \cdot e^{-j2\pi ft} dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">STFT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>：原始时域信号；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>：窗函数；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>：窗函数的时间平移（即滑动的位置）；</li></ul><p>这个公式实际上是在每一个时间点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 上，取一个小窗口，对这个窗口内的信号做傅里叶变换；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mi>t</mi><mtext>′</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w^{*}(t−t′)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord">′</span><span class="mclose">)</span></span></span></span> 是整个 STFT 的关键操作。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(t-t&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 是一个以为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 中心的窗口函数，用于在时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">t&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> ​ 处截取信号的一小段，* 表示复共轭。它将信号限制在一个局部区间内，并假设该区间内的信号是平稳的。</p><p>输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>S</mi><mi>T</mi><mi>F</mi><mi>T</mi></mrow><mi>x</mi></msub><mo stretchy="false">(</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{STFT}_x(t&#x27;, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">STFT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> 是一个二维函数，可以进一步绘制为三维图，描述在时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 时刻，频率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的成分强度。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/stft2.gif" alt="Wavelet Tutorial - Part 2"></p><p>STFT 的局限性在于时间分辨率和频率分辨率的权衡问题。</p><ul><li><p>在 FT 中，我们可以精确地知道信号中有哪些频率成分，它的频率分辨率是完美的，但是我们不知道这些频率成分是在什么时候出现的，即时间分辨率为 0。</p></li><li><p>在原始的时域信号中，我们知道每个时间点的信号值，它的时间分辨率是完美的，但是我们不知道不知道这些值对应的频率信息，即频率分辨率为 0。</p></li></ul><p>所以说：<strong>FT 没有时间分辨率，而时域信号没有频率分辨率。</strong></p><p>STFT 的本质是在 FT 的基础上加了一个滑动窗函数，每次只分析一小段信号，看看这一小段信号里有哪些频率。STFT 的窗口长度是有限的，只能覆盖信号的一小部分，我们只能看到当前窗口内的信号内容，不能像 FT 那样精确地识别出每一个频率成分，所以，频率分辨率下降了。由于窗口有限，某个频率成分是否真的存在、它的具体数值是多少，都会变得模糊，我们只能知道这个频率附近的一个<strong>频率区间</strong> （频率带）是否存在能量。可见，STFT 使用“有限长”的窗口，牺牲了频率精度来换取时间定位能力。</p><p>任何想要使用 STFT 的人，都要面临这个分辨率的问题。到底该使用什么样的窗口呢？</p><ul><li><p><strong>窄窗口：时间分辨率好，频率分辨率差；</strong></p></li><li><p><strong>宽窗口：频率分辨率好，时间分辨率差。</strong></p></li></ul><p><strong>时间越精细，频率越模糊；频率越清楚，时间越模糊</strong>。这也被称为<strong>海森堡不确定性原理</strong>在信号处理中的体现，也就是说，好的时间分辨率和好的频率分辨率不可兼得。这不是算法做得不好，而是物理规律的限制，别的数学变换也存在这个问题。</p><p>对于高频成分，需要窄窗口才能捕捉到快速变化，对于低频成分，需要宽窗口才能看清它的频率。但 STFT 只用了一个<strong>固定大小的窗口</strong>，也就是它的时间分辨率和频率分辨率是固定的，<strong>无法适应不同频率成分对时间或频率精度的不同需求。</strong></p><p>小波变换 (WT) 在一定程度上解决了分辨率的难题，它和 STFT 类似，但窗口可以随着频率自动调整。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250519165827251.png" alt="image-20250519165827251"></p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250519170038726.png" alt="image-20250519170038726"></p><h1 id="连续小波变换-CWT">连续小波变换 CWT</h1><h2 id="多分辨率分析">多分辨率分析</h2><p>上面讲到，时间分辨率和频率分辨率的问题是一种物理规律，无论使用什么变换都会存在。但人们很快想出了更聪明地解决方法——多分辨率分析（Multiresolution Analysis, MRA）。</p><p>多分辨率分析的核心思想很简单，不同频率成分应有不同的时间-频率分辨率。高频成分变化快，需用窄窗口精确捕捉其出现时间，而低频成分变化慢，需用宽窗口提高频率精度。</p><ul><li>高频部分：采用<strong>高时间分辨率 + 低频率分辨率</strong>；</li><li>低频部分：采用<strong>高频率分辨率 + 低时间分辨率</strong>。</li></ul><p>这种分析方法很适合短时间内具有高频成分，而在长时间内具有低频成分的信号，如图所示。幸运的是，现实生活中，绝大多数的信号往往都属于这种类型。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517171725531.png" alt="image-20250517171725531|500"></p><h2 id="小波变换的数学定义">小波变换的数学定义</h2><p>连续小波变换（Continuous Wavelet Transform, CWT）是作为短时傅里叶变换的替代方法出现，以解决分辨率的问题。它与 STFT 分析类似，信号与一个函数（即小波）相乘，然后针对信号的不同片段分别计算变换结果。这个小波函数类似于 STFT 中的窗函数。STFT 与 CWT 最大的区别在于</p><ol><li><p><strong>不进行傅里叶变换，直接将信号与一个小波函数相乘并积分；</strong></p></li><li><p><strong>CWT 中窗口宽度随频谱分量改变。</strong></p></li></ol><p>小波变换的本质是：<strong>用一系列伸缩和平移的小波函数去匹配信号局部特征</strong>，从而提取出时间和频率的局部信息。</p><p>CWT 的定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>CWT</mtext><mi>x</mi></msub><mo stretchy="false">(</mo><mi>τ</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>s</mi></msqrt></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>ψ</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>τ</mi></mrow><mi>s</mi></mfrac><mo fence="true">)</mo></mrow><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\text{CWT}_x(\tau, s) = \frac{1}{\sqrt{s}} \int_{-\infty}^{\infty} x(t) \cdot \psi^*\left( \frac{t - \tau}{s} \right) dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">CWT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.3097em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">s</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2921em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>  ：原始信号；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>  ：母小波；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>  ：平移参数，对应时间，控制小波在时间轴上的位置；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>  ：尺度参数，与频率成反比（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∝</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">f \propto 1/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal">s</span></span></span></span>  ），控制小波的宽度；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span>  ：复共轭；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msqrt><mi>s</mi></msqrt></mrow><annotation encoding="application/x-tex">1/\sqrt{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">s</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>  ：能量归一化因子，保证不同尺度下的能量一致。</li></ul><p>可以看到，变化后的信号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 这两个变量的函数，分别对应translation和scale参数。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 是变换函数，也被称为<strong>母小波</strong>（the mother wavelet）。</p><ul><li>母：表示变换过程中使用的不同的小波（窗口）都是由母小波经过<strong>平移</strong>（translation）和<strong>伸缩</strong>（dilation）生成的；</li><li>小：表示函数长度有限，适合局部化分析；</li><li>波：表示函数是振荡的，可以匹配信号中的波动特征；</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ψ</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>τ</mi></mrow><mi>s</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi^*\left( \frac{t - \tau}{s} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8246em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span> 表示缩放和平移母小波，从而构造出一个“时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span> 附近、尺度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 的小波”，这个小波将会和信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>​ ​相乘并积分。</p><h2 id="尺度-scale-的概念">尺度 scale 的概念</h2><p>在小波分析中，scale 参数与频率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 成反比关系，即：</p><ul><li>尺度越大 → 对应频率越低；</li><li>尺度越小 → 对应频率越高；</li></ul><p>和地图中的尺度一样，高尺度（低频率）对应于信号的全局信息，而低尺度（高频率）对应于信号中隐藏的细节信息（持续时间很短）。</p><p>尺度操作实质上是对信号进行<strong>压缩或拉伸</strong>：</p><ul><li>尺度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>：压缩信号（对应高频）；</li><li>尺度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>：拉伸信号（对应低频）；</li></ul><p>如图所示是不同尺度的余弦信号。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517175901401.png" alt="image-20250517175901401"></p><h2 id="小波变换的工作流程">小波变换的工作流程</h2><ol><li>选择一个母小波（如 Morlet 小波、Mexican Hat 小波）；</li><li>从尺度 <em>s</em>=1 开始，逐步增大尺度；</li><li>在每个尺度 <em>s</em>上：<ul><li>将母小波拉伸为当前尺度；</li><li>将该尺度的小波滑动（平移）到信号各个位置 <em>τ</em>；</li><li>计算信号与小波函数的内积，即积分结果；</li><li>得到一个变换系数，代表当前时间和尺度下的信号强度；</li></ul></li><li>所有尺度和平移组合形成一个二维的“时间-尺度平面”（time-scale plane）；</li><li>最终得到信号的<strong>时间-频率表示（TFR）</strong> ，但<strong>以平移来代替时间，以尺度代替频率</strong>。</li></ol><p>根据待分析的信号的不同，通常不需要进行全部的变换。在所有实际应用中,信号都是有频带限制的，因此通常只需计算有限刻度区间的变换即可。</p><p>CWT 的输出是一个二维图像：</p><ul><li><strong>横轴：平移（translation），反映时间；</strong></li><li><strong>纵轴：尺度（scale），反映频率；</strong></li><li><strong>颜色：变换系数的绝对值（代表能量/强度）</strong>；</li></ul><p>可以进一步转化为三维图像，用高度表示能量。</p><p>如图所示，是一个非稳态的信号的时域图，信号由 30 Hz、20 Hz、10 Hz 和 5 Hz 四个频率分量组成。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517181550072.png" alt="image-20250517181550072|500"></p><p>经过 CWT 后：</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517181927215.png" alt="image-20250517181927215|500"></p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517181958593.png" alt="image-20250517181958593|500"></p><p>请注意，横坐标是平移（translation），纵坐标是尺度（scale），高度表示能量值。</p><p>平移可以视为时间，平移参数 <em>τ</em> 表示小波函数沿时间轴滑动的位置。100 个点对应 1000 毫秒，意味着每个点代表 10 毫秒；这就是说，我们在每 10 毫秒计算一次小波系数。平移参数决定了时间分辨率。</p><p>而尺度参数 <em>s</em> 与频率成反比（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∝</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">f∝1/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal">s</span></span></span></span>），尺度越小，频率越大。尺度轴上 150 个点覆盖 40 Hz 的频率范围，但由于尺度是对数分布的，所以实际频率间隔不是线性的。尺度参数决定频率分辨率。</p><p>从图中可以看到，频率最大（30 Hz）的分量（scale 轴较小处）出现在 translation 轴 0~30 处，对应原时间 0~300ms，与预期一致。</p><h2 id="WT-的频率自适应特性">WT 的频率自适应特性</h2><p>回到最开始，我们讲 WT 和 STFT 的最大区别是，WT 在一定程度上解决了 SEFT 固定时间分辨率和固定频率分辨率的问题。那么，WT 究竟是怎么做到这一点的呢？</p><p>上面讲，尺度对应频率，平移对应时间。从下面两个图中，可以体会一下这个对应关系：</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517185403372.png" alt="image-20250517185403372|500"></p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250517185535124.png" alt="image-20250517185535124|500"></p><p>平移参数 <code>τ</code> 决定了小波函数在时间轴上滑动的位置，在计算 CWT 时，对于每一个尺度 <code>s</code>，我们都将母小波沿时间轴滑动，每次移动一小段 <code>Δτ</code>，然后进行积分运算。τ 的采样步长通常是固定的，不随尺度变化。</p><p><strong>虽然 τ 的采样通常是固定的，但真正影响时间分辨率的是小波函数本身的“宽度”。而小波函数的宽度正是通过尺度 <code>s</code> 来控制的。</strong></p><p>从图中可以看到，小尺度对应的小波函数变得更“窄”，意味着窄窗口，时间定位能力变强，此时时间分辨率较高，频率分辨率较差，适合分析高频信号。</p><p>相对地，大尺度对应的小波函数变得更“宽”，意味着宽窗口，频率识别能力变强，此时时间分辨率较差，而频率分辨率较高，适合分析低频信号。</p><p>也就是说，我们实际上控制的是不同频率对应的窗长（即时域分辨率），频率分辨率是通过海森堡测不准原理自动变化的，从而达到了动态分辨率。</p><p>这正是 CWT 的“自适应分辨率”机制。</p><table><thead><tr><th>尺度</th><th>时间分辨率</th><th>频率分辨率</th></tr></thead><tbody><tr><td>低尺度（s 小）</td><td>好（窄小波）</td><td>差（宽频带）</td></tr><tr><td>高尺度（s 大）</td><td>差（宽小波）</td><td>好（窄频带）</td></tr></tbody></table><h1 id="离散小波变换-DWT">离散小波变换 DWT</h1><h2 id="连续小波变换的离散化：小波序列">连续小波变换的离散化：小波序列</h2><p>虽然连续小波变换（CWT）提供了非常丰富的时频信息，但它在数学上是连续的，即其时间参数（平移参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>）和尺度参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 在时-尺度平面上取连续值，无法直接用于计算机处理。因此，我们需要对 CWT 进行离散化，得到一个<strong>可计算且信息保留较好的形式</strong> —— 小波序列（Wavelet Series）。</p><p>最直观的方法就是简单地<strong>对时频图（或称为平移-尺度图）进行采样</strong>。在对 CWT 进行离散化时，并不一定要采用均匀采样，我们可以根据尺度的特性来优化采样策略。</p><p>我们的目的并不只是单纯的采样，还要要求能够还原信号。在 CWT 中，当然可以通过逆变换还原信号，但是如果我们对尺度参数 <em>s</em> 和平移参数 <em>τ</em> 进行离散采样，那么，还能重新还原信号吗？答案是肯定的，但需要满足一定的条件（容许条件、正交性等），这部分暂且不提，先来看怎么优化采样策略。</p><p>奈奎斯特采样定理指出，**为了准确重建一个原始的连续时间信号，采样频率必须至少是该信号中最高频率成分的两倍。**这个最小的采样率被称为奈奎斯特采样率。</p><p>根据奈奎斯特定理，在<strong>较高的尺度（较低的频率）下，可以降低采样率</strong>，这意味着使用计算机计算时，可以节省大量计算时间。</p><table><thead><tr><th>尺度</th><th>频率</th><th>时间分辨率</th><th>频率分辨率</th><th>所需采样点数</th></tr></thead><tbody><tr><td>小</td><td>高频</td><td>高</td><td>低</td><td>多</td></tr><tr><td>大</td><td>低频</td><td>低</td><td>高</td><td>少</td></tr></tbody></table><p>小波序列可以视为离散化的 CWT，离散化的思路是：<strong>首先，尺度参数 s 按照对数网格离散化，然后时间参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span> 根据尺度参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 进行离散化。</strong></p><p>即：</p><ul><li>尺度按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></mrow><annotation encoding="application/x-tex">s = s_0^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> 离散化（通常是指数形式）；</li><li>平移按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup><mo>⋅</mo><msub><mi>τ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\tau = k \cdot s_0^j \cdot \tau_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 离散化（每个尺度下的平移步长随尺度增大而增加）；</li></ul><p>参数解释：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：基础尺度因子，用于控制尺度增长的速度。要求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_0&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，一般取 2，此时这种离散方式称为二进离散（dyadic discretization）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>：尺度参数，表示尺度层级。通过改变 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 的值，我们可以获得一系列不同尺度的小波函数，这些函数可以覆盖不同的频率范围；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\tau_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：初始平移步长，每个尺度下的最小平移距离，通常取为 1 ；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>：平移参数，决定某一尺度下信号滑动的具体位置；</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">s_0 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 时，尺度按 2 的幂次增加：$$s = 2^j \Rightarrow j=0: s=1,\quad j=1: s=2,\quad j=2: s=4,\quad j=3: s=8,\dots$$ 然后，根据尺度轴的离散化对时间轴进行离散化，尺度每增加一倍，频率下降一倍，时间采样率可以下降一倍。这样就形成了所谓的<strong>二进制网格（dyadic grid）</strong>，这是后面介绍的 DWT 的标准采样方式。借助这种方式，即可实现<strong>在不同的尺度下使用不同的时间采样密度</strong>。</p><p>现在，将离散化的尺度和平移参数代入 CWT 的公式中，得到离散化的母小波函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ψ</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></msqrt></mfrac><mi>ψ</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>k</mi><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup><msub><mi>τ</mi><mn>0</mn></msub></mrow><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi_{j,k}(t) = \frac{1}{\sqrt{s_0^j}} \psi\left( \frac{t - k s_0^j \tau_0}{s_0^j} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.48em;vertical-align:-1.73em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.3231em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3231em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.2831em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.88em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5169em;"><span></span></span></span></span></span></span></span><span style="top:-3.5531em;"><span class="pstrut" style="height:3.3231em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.0001em;"><span class="pstrut" style="height:3.3231em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.73em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6196em;"><span style="top:-2.1674em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0989em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 是母小波，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 分别控制尺度和平移。类比 CWT 的原母小波函数：</p><ul><li>伸缩（scaling） ：由尺度参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 控制， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></mrow><annotation encoding="application/x-tex">s = s_0^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> ；</li><li>平移（shifting） ：由平移参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 控制， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup><mo>⋅</mo><msub><mi>τ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\tau = k \cdot s_0^j \cdot \tau_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ；</li><li>归一化（normalization） ：由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msqrt><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></msqrt></mrow><annotation encoding="application/x-tex">1/\sqrt{s_0^j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.5169em;"></span><span class="mord">1/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3231em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.2831em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.88em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5169em;"><span></span></span></span></span></span></span></span></span> ​ 实现能量一致化。</li></ul><p>然后，我们就可以得到 CWT 的离散版本——小波序列。小波序列的系数通过信号与离散小波函数的内积计算：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>W</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></msqrt></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>ψ</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>k</mi><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup><msub><mi>τ</mi><mn>0</mn></msub></mrow><msubsup><mi>s</mi><mn>0</mn><mi>j</mi></msubsup></mfrac><mo fence="true">)</mo></mrow><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">W_x(j, k) = \frac{1}{\sqrt{s_0^j}} \int_{-\infty}^{\infty} x(t) \cdot \psi^*\left( \frac{t - k s_0^j \tau_0}{s_0^j} \right) dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1443em;vertical-align:-1.73em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.3231em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3231em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.2831em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.88em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5169em;"><span></span></span></span></span></span></span></span><span style="top:-3.5531em;"><span class="pstrut" style="height:3.3231em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.0001em;"><span class="pstrut" style="height:3.3231em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.73em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6196em;"><span style="top:-2.1674em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9426em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0989em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 是尺度参数（scale parameter）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是平移参数（translation parameter）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_0 &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 是尺度的基底（base value），通常取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">s_0 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\tau_0 &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 是时间步长，通常取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\tau_0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 是母小波函数；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ψ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi^*(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 表示复共轭。</li></ul><p>小波序列是对连续小波变换（CWT）进行有限离散化的结果，这意味这我们在分析过程中不再像 CWT 那样对所有的尺度和平移进行积分。尽管我们只计算有限个系数（即有限个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>），但小波序列仍然假设原始信号是一个数学上的连续函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> ​​，即这些系数依然是基于对连续信号与母小波函数的积分得到的，因此它仍然是针对<strong>连续时间信号</strong>而非<strong>离散数字信号</strong>的分析工具。</p><p>我们知道，现实中，实际采样信号往往具有两个特点：</p><ol><li><strong>离散性</strong>：信号是一个一个采集的，数据不连续，并不能直接用连续函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 来表示，只能用序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x[t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 来表示。</li><li><strong>有限性</strong>：虽然理想的 CWT 是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(−∞,+∞)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span></span></span></span> 进行积分的，但是实际信号往往实在一个区间内 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 的。</li></ol><p>离散小波变换（DWT）就是用来解决这个问题的，DWT 真正适用于数字信号处理，同时支持计算机处理。</p><table><thead><tr><th>变换</th><th>输入信号</th><th>参数是否离散</th><th>是否适合计算机处理</th></tr></thead><tbody><tr><td><strong>CWT</strong></td><td>连续信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></td><td>不离散</td><td>否</td></tr><tr><td><strong>Wavelet Series（小波序列）</strong></td><td>连续信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></td><td>尺度和平移部分离散</td><td>部分适合</td></tr><tr><td><strong>DWT</strong></td><td>离散信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span></td><td>完全离散</td><td>是</td></tr></tbody></table><h2 id="离散小波变换的工作原理">离散小波变换的工作原理</h2><p>就像傅里叶级数是从连续傅里叶变换（FT）发展而来的一样，小波序列也是从 CWT 发展而来的。更进一步地，就像离散傅里叶变换（DFT）是从傅里叶级数发展而来一样，离散小波变换（DWT）则是从小波序列发展而来的。</p><p>尽管离散化的连续小波变换（wavelet series）可以通过计算机计算，但它本质上只是对 CWT 的采样，仍然不是真正的离散变换。CWT 提供的信息对于信号重构来说高度冗余，这导致计算时间和资源需求较大。</p><p>DWT 通过减少冗余，确保提供足够的信息用于信号的分析和重构，显著降低了计算复杂度，且 DWT 在实现上比 CWT 更简单，非常适合计算机处理。</p><p>与 CWT 类似，DWT 通过数字滤波技术获得信号的时-频（或时-尺度）表示，但使用离散的滤波器和采样操作。DWT 将信号分解为不同频率带的粗略近似（低频部分）和细节信息（高频部分），并通过上采样和下采样操作改变信号的分辨率和尺度。</p><p>一个典型的 DWT 步骤如下：</p><ol><li><p><strong>半子带滤波</strong>：原始信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 通过一对半带滤波器：<strong>高通滤波器</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 和<strong>低通滤波器</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>；</p><ul><li><p>高通滤波器提取信号中的<strong>高频细节成分</strong>（detail coefficients）；</p></li><li><p>低通滤波器提取信号中的<strong>低频近似成分</strong>（approximation coefficients）；</p></li></ul></li><li><p><strong>下采样</strong>：对上一步得到的两路输出信号进行<strong>下采样</strong>（通常为 2 倍下采样），从而减少数据量；</p></li><li><p><strong>递归</strong>：对<strong>低频部分</strong>继续进行同样的滤波和下采样操作，形成多级分解。</p></li></ol><h3 id="半子带滤波">半子带滤波</h3><p><strong>带通滤波器</strong>是一种允许特定范围内的频率通过而阻止其他频率的滤波器。</p><p>半子带滤波是指使用一对互补的数字滤波器（一个低通滤波器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 和一个高通滤波器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>）将输入信号的频谱分割为两个<strong>分成两个频段</strong>：</p><ul><li><p><strong>低通滤波器</strong>：保留信号中低于某截止频率（通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><msub><mi>f</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">0.5f_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0.5</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的频率成分，滤除高频部分。</p></li><li><p><strong>高通滤波器</strong>：保留信号中高于该截止频率的频率成分，滤除低频部分。</p></li></ul><p>因为每个滤波器只保留原信号的一半频率范围，故称为“半子带”。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/v2-9fbbe34fc34617034c7b50e910852694_1440w.jpg" alt="img"></p><p>假设输入信号的最高频率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（对应离散信号的奈奎斯特频率，采样率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>f</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">2f_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），半子带滤波将信号频谱分为：</p><ul><li><strong>低通子带</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>f</mi><mtext>max</mtext></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, f_{\text{max}}/2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/2</span><span class="mclose">]</span></span></span></span></li><li><strong>高通子带</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>f</mi><mtext>max</mtext></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><msub><mi>f</mi><mtext>max</mtext></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[f_{\text{max}}/2, f_{\text{max}}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li></ul><p>这两个子带的频率范围互补，覆盖整个信号频谱。</p><h3 id="下采样与上采样">下采样与上采样</h3><table><thead><tr><th>操作</th><th>目的</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>下采样</strong>（Decimation）</td><td>减少采样率</td><td>每隔 n 个样本取一个值</td><td>x[n] → x[0], x[2], x[4], …（n=2）</td></tr><tr><td><strong>上采样</strong>（Interpolation）</td><td>增加采样率</td><td>在每两个样本之间插入 (n−1) 个零或插值样本</td><td>x[n] → x[0], 0, x[1], 0, x[2], …（n=2）</td></tr></tbody></table><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/v2-a6729893d2bd1d0f170ee1ca2cd5d92c_1440w.jpg" alt="img"></p><h3 id="离散小波分解">离散小波分解</h3><p><strong>一次半子带滤波 + 一次 2 倍下采样称为一层小波分解。</strong></p><p>假设原采样信号有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>，带宽为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>F</mi><mi>s</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, F_s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，信号最高频率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">F_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><ul><li><p>一次高通滤波后，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>F</mi><mi>s</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{2} , F s \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 的部分，也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个点，再经过一次 2 倍下采样，变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点。这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点称为<strong>小波分解的高频系数</strong>。</p></li><li><p>一次低通滤波后，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. 0 , \frac{F s}{2} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 的部分，也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个点，再经过一次 2 倍下采样，变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点。这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点称为<strong>小波分解的低频系数</strong>。</p></li></ul><p>可以发现，可以经过一层小波分解的信号，它的总长度加起来，还是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，是不变的，但信息已经被分成了两部分。</p><p>现在，我们已经对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mi>F</mi><mi>s</mi><mo fence="true">)</mo><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\left(\right. 0 , F s \left.\right) , N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个点的原信号进行了第一层小波分解，得到：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>F</mi><mi>s</mi><mo fence="true">)</mo><mo separator="true">,</mo><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{2} , F s \left.\right) , \frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点的高频系数和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo fence="true">)</mo><mo separator="true">,</mo><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\left(\right. 0 , \frac{F s}{2} \left.\right) , \frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点的低频系数。这个过程成为第 1 层小波分解。这个过程可以继续下去，形成多层分解。</p><p>我们保持高通滤波得到的高频系数不变，而将低通滤波得到的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo fence="true">)</mo><mo separator="true">,</mo><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\left(\right. 0 , \frac{F s}{2} \left.\right) , \frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点的低频系数，再次作为高通滤波器和低通滤波器的输入，然后同样进行 2 倍下采样，于是可以进一步得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>4</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo fence="true">)</mo><mo separator="true">,</mo><mfrac><mi>N</mi><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{4} , \frac{F s}{2} \left.\right) , \frac{N}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点的高频系数和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>4</mn></mfrac><mo fence="true">)</mo><mo separator="true">,</mo><mfrac><mi>N</mi><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\left(\right. 0 , \frac{F s}{4} \left.\right) , \frac{N}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个点的低频系数。这个过程就成为第 2 层小波分解。经过 2 层小波分解，信号的总长度还是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，是不变的。</p><p>依此类推，我们可以进行第 3 层，第 4 层小波分解。如图所示，直到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">l o g_{2} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 层小波分解。在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">l o g_{2} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>​ 层小波分解，由于不断的下采样，低频系数和高频系数都只剩 1 个数了，小波分解无法进行下去了。</p><p>因此，小波分解的原始信号个数一般也需要是<strong>2的幂次</strong>。不过，在各种数学计算软件里，如果输入不是2的幂次，它会自动帮你补零到2的幂次。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/v2-7c00c28d15db697a75e77a442b60e468_1440w.jpg" alt="img"></p><p>取4层小波分解的结果进行分析：</p><p>在频域上，我们得到的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>F</mi><mi>s</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{2} , F s \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>4</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{4} , \frac{F s}{2} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>8</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>4</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{8} , \frac{F s}{4} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>16</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>8</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{16} , \frac{F s}{8} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>16</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. 0 , \frac{F s}{16} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>频域区间的系数。</p><p>在时域上，由于不断的2倍下采样，不断地丢弃数据，所以最后一层分解得到的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>16</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>8</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{16} , \frac{F s}{8} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>16</mn></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. 0 , \frac{F s}{16} \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>的时间分辨率最差（样本数最少），第一层分解保留的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>F</mi><mi>s</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>F</mi><mi>s</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\right. \frac{F s}{2} , F s \left.\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>时间分辨率最好（样本数最多）。相对地，最后一层分解的频率分辨率最好（频率范围最小），第一层分解的频率分辨率最差（频率范围最大）。</p><p>也就是说：</p><ul><li><strong>第1层（高频）：时间分辨率高 ⇒ 更适合捕捉突变事件（细节）</strong>；</li><li><strong>第4层（低频）：频率分辨率高 ⇒ 更适合识别长期趋势（近似）</strong>；</li></ul><p>这种分辨率分配策略，是小波变换成为分析非平稳信号的关键。这和我们前面提到的多分辨率分析的思想一致：</p><ul><li>高频部分：采用<strong>高时间分辨率 + 低频率分辨率</strong>；</li><li>低频部分：采用<strong>高频率分辨率 + 低时间分辨率</strong>。</li></ul><p>这就是离散小波变换的快速算法之一——Mallet算法，<strong>通过不断的半子带滤波和下采样，控制不同频率成分的频域分辨率，进而达到动态分辨率。</strong></p><p>下面这张图展示了小波分解的完整过程：</p><p><img src="https://pic4.zhimg.com/v2-245a290abed4a909522312c6cc841a0f_1440w.jpg" alt="img"></p><p>输入信号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>，其频率范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mn>0</mn><mo>∼</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">f = 0 \sim \pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>（归一化频率，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> 为最高频率）。图中展示了多级分解，包括 Level 1、Level 2、Level 3 等，每一级分解都会将信号分解为高频部分（通过高通滤波器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>）和低频部分（通过低通滤波器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>）。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↓</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\downarrow 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↓</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>​ 是下采样符号，每一级分解后，信号都会被下采样（downsampling）2 倍，即保留一半的样本点。</p><p>每一级分解后，保留高频系数（高通滤波器+下采样后得到），然后低频系数（低通滤波器+下采样得到）继续进入下一级分解，直到达到所需的分解层数。</p><p>第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>层高频系数的频率范围和系数个数（样本数）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>频率范围</mtext><mo>=</mo><mrow><mo fence="true">(</mo><mfrac><msub><mi>F</mi><mi>s</mi></msub><msup><mn>2</mn><mi>j</mi></msup></mfrac><mo separator="true">,</mo><mfrac><msub><mi>F</mi><mi>s</mi></msub><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mspace width="1em"/><mtext>样本数</mtext><mo>=</mo><mfrac><mi>N</mi><msup><mn>2</mn><mi>j</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">\text{频率范围} = \left( \frac{F_s}{2^j}, \frac{F_s}{2^{j-1}} \right), \quad \text{样本数} = \frac{N}{2^j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">频率范围</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord cjk_fallback">样本数</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>层低频系数的频率范围和系数个数（样本数）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>频率范围</mtext><mo>=</mo><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><msub><mi>F</mi><mi>s</mi></msub><msup><mn>2</mn><mi>j</mi></msup></mfrac><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mspace width="1em"/><mtext>样本数</mtext><mo>=</mo><mfrac><mi>N</mi><msup><mn>2</mn><mi>j</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">\text{频率范围} = \left( 0, \frac{F_s}{2^j} \right), \quad \text{样本数} = \frac{N}{2^j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">频率范围</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord cjk_fallback">样本数</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>DWT多级分解后得到的是<strong>一组高频系数</strong>（Detail Coefficients）和<strong>最后一层的低频系数</strong>（Approximation Coefficient）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>W</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>J</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">DWT(x[n])=[d_1,d_2,...,d_j,a_J]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p><p>所有系数的总长度仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>length</mtext><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>length</mtext><mo stretchy="false">(</mo><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mtext>length</mtext><mo stretchy="false">(</mo><msub><mi>d</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>length</mtext><mo stretchy="false">(</mo><msub><mi>a</mi><mi>J</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\text{length}(d_1) + \text{length}(d_2) + \cdots + \text{length}(d_j)+\text{length}(a_J) = N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">length</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">length</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">length</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">length</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p><p><strong>这表明DWT 是一种无冗余的变换，它将信号分解为了多个频段，并保持总数据量不变。</strong></p><h3 id="小波系数">小波系数</h3><p>系数这个词来自于线性代数的概念，它表示信号在某个基函数下的投影，即信号与该基函数之间的相似程度。</p><p>我们把信号当做一个函数，它可以由一系列“基函数（basis functions）”组合而成，每个基函数前的乘数就是“系数”，代表该基函数对信号的贡献大小。</p><p>傅里叶证明了：<strong>任何周期函数都可以表示为正弦和余弦函数的线性组合。</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></munderover><msub><mi>c</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>j</mi><mn>2</mn><mi>π</mi><mi>k</mi><msub><mi>f</mi><mn>0</mn></msub><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x(t) = \sum_{k=-\infty}^{\infty} c_k e^{j2\pi k f_0 t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0118em;vertical-align:-1.3604em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3604em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">πk</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，$ c_k $ 就是傅里叶系数，它表示该频率成分在信号中的“权重”，也就是信号与该复指数函数的“匹配程度”。</p><p>傅里叶变换，就是在求这些傅里叶系数。</p><p>小波变换的思想与此非常相似，只不过它的基函数不是正弦波，而是<strong>小波函数</strong> （wavelet functions）。连续小波变换（CWT）公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>W</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>τ</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>s</mi></msqrt></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>ψ</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>τ</mi></mrow><mi>s</mi></mfrac><mo fence="true">)</mo></mrow><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">W_x(\tau, s) = \frac{1}{\sqrt{s}} \int_{-\infty}^{\infty} x(t) \cdot \psi^*\left( \frac{t - \tau}{s} \right) dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.3097em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">s</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2921em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span> 是母小波函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ψ</mi><mrow><mi>τ</mi><mo separator="true">,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>s</mi></msqrt></mfrac><mi>ψ</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>τ</mi></mrow><mi>s</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi_{\tau,s}(t) = \frac{1}{\sqrt{s}} \psi\left( \frac{t - \tau}{s} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.388em;vertical-align:-0.538em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.6259em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8059em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mathnormal mtight">s</span></span></span><span style="top:-2.7659em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2341em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8246em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span> 是经过伸缩和平移后的小波函数。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>τ</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W_x(\tau, s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> 就是求出来的小波系数，它本质上是原始信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>​ 和当前小波函数之间的内积（inner product）；</p><p>**换句话说：**小波系数表示信号在某一小波基函数上的“投影”。</p><ul><li>如果这个系数很大，说明信号在这个时间点和尺度下与该小波很“像”；</li><li>如果这个系数很小或接近于零，说明信号在这个时间和尺度下几乎没有这种结构；</li></ul><p>小波序列对CWT中的尺度参数和时间参数进行了离散化，把尺度 $ s = 2^j $，平移 $ \tau = k \cdot 2^j $，带入到 CWT 公式中，就会得到一系列的小波基函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ψ</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><msup><mn>2</mn><mi>j</mi></msup></msqrt></mfrac><mi>ψ</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>k</mi><mo>⋅</mo><msup><mn>2</mn><mi>j</mi></msup></mrow><msup><mn>2</mn><mi>j</mi></msup></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi_{j,k}(t) = \frac{1}{\sqrt{2^j}} \psi\left( \frac{t - k \cdot 2^j}{2^j} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4517em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.1497em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9603em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9203em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0797em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5017em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>这在DWT中，我们并不直接使用这些小波基函数进行内积或积分运算去生成投影，而是通过滤波器组，离散地、高效地、隐式地完成了这个过程。我们在DWT中使用的高通滤波器和低通滤波器并不是随意设计的，它是小波基的离散化表示，而且要满足一定的条件。</p><p>DWT核心操作就是使用<strong>一对滤波器（低通 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 和 高通 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>）</strong>，对信号进行滤波和下采样，从而得到一系列 detail（细节）和 approximation（近似）信号。这些 detail 和 approximation 信号其实就是<strong>信号在基函数下的展开系数</strong>，可以用于还原信号：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><munder><mo>∑</mo><mi>k</mi></munder><msub><mi>d</mi><mi>j</mi></msub><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>⋅</mo><msub><mi>ψ</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>+</mo><munder><mo>∑</mo><mi>k</mi></munder><msub><mi>a</mi><mi>J</mi></msub><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>⋅</mo><msub><mi>ϕ</mi><mrow><mi>J</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x[n] = \sum_{j=1}^{J} \sum_k d_j[k] \cdot \psi_{j,k}[n] + \sum_k a_J[k] \cdot \phi_{J,k}[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2421em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3521em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ψ</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\psi_{j,k}[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>：离散小波函数；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\phi_{j,k}[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>：离散尺度函数（与低通滤波器相关）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d_j[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>：第 j 层 detail 系数；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>J</mi></msub><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a_J[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>​：最粗尺度下的 approximation 系数；</li></ul><p>滤波器组（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h[n],g[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>）隐式定义了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ϕ(t),ψ(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>。这个公式说明：<strong>原始信号是所有 detail 和 approximation 系数与基函数的线性组合，所以，DWT 系数确实是这些基函数的展开系数。</strong></p><h3 id="小波系数有什么用">小波系数有什么用</h3><p>WT多级分解后得到的是<strong>一组高频系数</strong>（Detail Coefficients）和<strong>最后一层的低频系数</strong>（Approximation Coefficient）。它们分别代表：</p><table><thead><tr><th>类型</th><th>含义</th><th>用途</th></tr></thead><tbody><tr><td><strong>Detail Coefficients（d₁, d₂, …, dₙ）</strong></td><td>每一层的高频成分，表示该频段内的局部细节信息，如突变、噪声、边缘等；</td><td>去噪、边缘检测、瞬态识别</td></tr><tr><td><strong>Approximation Coefficient（aₙ）</strong></td><td>最后一层的低频成分，表示信号的整体趋势或平滑部分；</td><td>信号压缩、趋势提取、平滑滤波</td></tr></tbody></table><p>高频系数由高通滤波器生成，捕获信号的高频成分（细节信息或瞬态部分）。高频系数反映了信号的快速变化或突变，对应时域图中的“尖峰”。</p><p>高频系数的作用举例：</p><ul><li><p><strong>噪声分离</strong>：高频子带常包含噪声，通过阈值处理可去除噪声。</p></li><li><p><strong>细节分析</strong>：用于检测信号中的异常、边缘或局部特征，广泛应用于图像边缘检测、故障诊断。</p></li><li><p><strong>特征提取</strong>：高频系数可作为<strong>局部特征</strong>，用于时间-频率分析或模式识别。</p></li></ul><p>低频系数由低通滤波器生成，捕获信号的低频成分（趋势或平滑部分）。近似系数通常包含信号的大部分能量，代表信号的整体趋势或低频背景。</p><p>低频系数的作用举例：</p><ul><li><p><strong>数据压缩</strong>：由于能量集中，保留这些系数即可近似重构信号，丢弃高频噪声或不显著成分。</p></li><li><p><strong>特征提取</strong>：低频系数可作为信号的<strong>全局特征</strong>，用于分类或回归任务。</p></li></ul><blockquote><p><strong>归一化频率</strong>？</p><p><strong>归一化频率</strong>（Normalized Frequency）是一种将实际频率值除以采样率后得到的无量纲量。数学表达式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>d</mi><mo>=</mo><mfrac><mi>f</mi><msub><mi>F</mi><mi>s</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">  fnormalized=\frac{f}{F_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ma</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2074em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></blockquote><blockquote><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>：原始频率，单位为 Hz；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">F_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：采样率，单位也是 Hz；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mtext>normalized</mtext></msub></mrow><annotation encoding="application/x-tex">f_{\text{normalized}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">normalized</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：归一化频率，通常范围在 [0, 0.5] 或者 [-0.5, 0.5] 区间内；</li></ul><p>在数字信号处理中，有时也用<strong>弧度</strong>表示归一化频率，即单位为 rad/s；</p><ul><li>此时公式为：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p></li></ul></blockquote><h1 id="小波变换的变体">小波变换的变体</h1><p>除了 CWT（连续小波变换） 和 DWT（离散小波变换），小波变换还有多种变体和扩展形式，每种形式针对特定应用或问题进行了优化。</p><h2 id="平稳小波变换-SWT">平稳小波变换 SWT</h2><p>SWT（Stationary Wavelet Transform，平稳小波变换 ），在每一层使用和DWT同样的滤波器 <em>h</em>[<em>n</em>] 和 <em>g</em>[<em>n</em>]，但<strong>不进行下采样</strong> ，因此每一层的输出长度与输入相同，每一层分解后的 detail 和 approximation 系数都保留了完整的时域信息。</p><p>每一层分解后，SWT 的系数数量与原始信号相同；多层分解后，总系数数量远大于原始信号长度。所以 SWT 又被称为 “冗余小波变换（Redundant Wavelet Transform）”。这样做的好处是保留更多地局部信息，且更适合用于重构和复原信号，缺点就是计算复杂度高。</p><p>SWT的最大特点是“平移不变性”。DWT 在每一层分解后都会进行下采样，导致对信号的起始位置敏感，而 SWT 不进行下采样，因此对于同一信号的不同起始位置（平移），其系数分布是一致的，这个特性在去噪和模式识别中非常重要。通俗的理解就是如果你把一个信号整体向右移动几个样本点，DWT 的结果可能会发生较大变化，但 SWT 的结果几乎不变。</p><h2 id="小波包变换（WPT）">小波包变换（WPT）</h2><p>WPT（Wavelet Packet Transform）是 DWT 的扩展，它不仅对低频部分继续分解，也对高频部分进行进一步分解，从而形成一个完整的<strong>小波包树结构（wavelet packet tree）</strong> 。</p><p>这样做的好处是WPT提供了比DWT更精细地划分频带，形成一棵完整的分解树，用户可以自由选择根据哪一层的小波包系数来重构信号或提取特征。</p><h2 id="其它">其它</h2><table><thead><tr><th><strong>变换类型</strong></th><th><strong>定义</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>CWT</strong> (Continuous Wavelet Transform)</td><td>连续小波变换，使用连续平移和尺度参数分析信号。</td><td>- 连续系数，高冗余<br /> - 提供高分辨率时频分析 <br />- 计算复杂</td></tr><tr><td><strong>DWT</strong> (Discrete Wavelet Transform)</td><td>离散小波变换，使用离散参数分解信号。</td><td>- 降采样，高效，无冗余 <br />- 正交小波 <br />- 无平移不变性</td></tr><tr><td><strong>SWT</strong> (Stationary Wavelet Transform)</td><td>非降采样离散小波变换，保留所有样本。</td><td>- 无降采样，平移不变 <br />- 高冗余，计算量中等</td></tr><tr><td><strong>WPT</strong> (Wavelet Packet Transform)</td><td>DWT 扩展，递归分解高频和低频子带。</td><td>- 灵活时频划分 <br />- 增加冗余和计算量<br /> - 可选最佳基</td></tr><tr><td><strong>MWT</strong> (Multiwavelet Transform)</td><td>使用多个小波和尺度函数分解信号。</td><td>- 多滤波器组<br /> - 兼具对称性、正交性、高消失矩</td></tr><tr><td><strong>Complex Wavelet Transform</strong></td><td>使用复值小波，提供幅度和相位信息。</td><td>- 方向性和平移不变性强 <br />- 冗余 (2:1 或 4:1) <br />- 双树结构</td></tr><tr><td><strong>Lifting Wavelet Transform</strong></td><td>基于提升方案的时域小波变换。</td><td>- 高效、可逆<br />- 支持整数变换<br />- 自适应滤波器</td></tr><tr><td><strong>Second-Generation Wavelet Transform</strong></td><td>在非规则网格上定义的小波变换。</td><td>- 适合非均匀采样 <br />- 不依赖平移和尺度 <br />- 实现复杂</td></tr><tr><td><strong>Curvelet Transform</strong></td><td>捕捉图像中曲线和边缘的变换。</td><td>- 方向性和各向异性 <br />- 稀疏表示 <br />- 优于 2D DWT</td></tr><tr><td><strong>Contourlet Transform</strong></td><td>结合多尺度和方向滤波器，捕捉轮廓。</td><td>- 多方向表示 <br />- 可控冗余 <br />- 类似金字塔结构</td></tr><tr><td><strong>Shearlet Transform</strong></td><td>通过剪切操作实现多尺度、多方向分析。</td><td>- 高效稀疏表示 <br />- 边缘和各向异性特征 <br />- 可选平移不变性</td></tr></tbody></table><h2 id="自适应小波变换">自适应小波变换</h2><p>CWT通过将输入信号与小波基函数（wavelet basis function, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span>）进行卷积来分析信号的时频特性，其公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>CWT</mtext><mi>x</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow></msqrt></mfrac><mo>∫</mo><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>ψ</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mi>b</mi></mrow><mi>a</mi></mfrac><mo fence="true">)</mo></mrow><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\text{CWT}_x(a, b) = \frac{1}{\sqrt{|a|}} \int x(t) \psi\left(\frac{t - b}{a}\right) dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">CWT</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.58em;vertical-align:-1.13em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.175em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.13em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>：尺度参数，控制小波的伸缩，影响分析的频率范围（低尺度对应高频，高尺度对应低频）。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>：位移参数，控制小波在时间轴上的平移，决定分析的时间位置。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>：输入信号。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span>​：小波基函数。</li></ul><p>尺度参数、位移参数和小波基函数都需要预先设定好。比如：</p><ul><li><strong>尺度参数a</strong>：用户需要指定一组离散的尺度值（例如，a=1,2,4,…），以覆盖感兴趣的频率范围。</li><li><strong>位移参数b</strong>：通常以固定时间步长（如信号采样间隔）在时间轴上移动，以分析信号在不同时间点的特征。</li></ul><hr><p>文献《Advanced Fault Diagnosis Method for DC–DC Converters: Leveraging the Temporal Continuity of Electrical Signals》提到了作者自己提出的自适应小波变换，旨在解决传统连续小波变换在处理直流-直流（DC-DC）变换器输出信号时，因固定尺度参数无法适应信号连续变化而导致的局限性。</p><p>这些参数的选择依赖于用户的经验或信号的预知特性（如频率范围或时间分辨率需求）。CWT不会根据信号的实时变化自动调整，缺乏根据信号实时特性自动调整的能力。</p><p>而作者提出的 AWT通过引入动态参数调整机制，结合经验模态分解（Empirical Mode Decomposition, EMD）和希尔伯特-黄变换（Hilbert-Huang Transform, HHT），实现尺度参数（scale parameter）和位移参数（translation parameter）的自适应调整，从而更精确地捕获信号的时频特性。</p><ul><li><p>动态尺度调整：AWT基于经验模态分解（EMD）和希尔伯特-黄变换（HHT），根据信号的瞬时频率Fc(t)动态计算尺度参数a(t)，使之适应信号的频率变化： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>α</mi><mrow><msub><mi>F</mi><mi>c</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">a(t) = \frac{\alpha}{F_c(t)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2154em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p>动态位移调整：AWT根据信号的局部能量变化El(t)动态调整位移参数b(t)，以更好地对齐信号的突变点： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mo>−</mo><mi>β</mi><mo>⋅</mo><mtext>sgn</mtext><mrow><mo fence="true">(</mo><mfrac><mrow><mi>d</mi><msub><mi>E</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><msqrt><mrow><mi mathvariant="normal">∣</mi><msub><mi>E</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">b(t) = t - \beta \cdot \text{sgn}\left(\frac{dE_l(t)}{dt}\right) \cdot \sqrt{|E_l(t)|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord text"><span class="mord">sgn</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0576em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.305em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span></span></span></span></p></li></ul><hr><p>文献《ECGAN: An Efficient Diagnostic Strategy for Hidden Deterioration in DC-DC Converters》中，作者提到在传统的故障诊断中，使用的小波基函数通常是固定的，例如 Morlet 小波、Mexican Hat 小波等。然而，这些固定基函数可能无法很好地匹配复杂多变的电气信号特性，尤其是在面对 DC-DC 转换器的输出电压信号时，这些信号具有周期性和非平稳性特征。为了解决这一问题，作者提出了 AWT 方法，它能够根据输入信号的局部特征动态调整小波基函数的参数（如带宽 fb 和中心频率 fc），从而更精确地捕捉信号中的故障特征。</p><p>AWT基于复杂Morlet小波（complex Morlet wavelet, cmor），因其对时频定位和相位信息的高灵敏度而被选为基函数。AWT通过以下步骤实现自适应优化：</p><ol><li><p><strong>信号分段</strong> ：将输入信号分为初、中、末三段，有助于分析信号在不同时间段内的变化趋势，并分别评估每个部分与小波基函数的匹配程度。</p></li><li><p><strong>计算 δ</strong> ：对每一段时间段计算 δ，反映小波基函数与信号局部特征的匹配度。该系数基于峰值检测方法计算得出：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>δ</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>α</mi><mi>i</mi></msub><msubsup><mi>m</mi><mi>i</mi><mn>2</mn></msubsup><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\delta = \sum_{i=1}^{k} \alpha_i m_i^2 S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>：相似系数，表示小波基函数与信号的匹配度。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：取绝对值后小波基函数的第 i 个峰值区域。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：取绝对值后第 i 个峰值的最大值。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：权重系数，定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>m</mi><mi>i</mi></msub><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\alpha_i = \frac{m_i}{\max(m_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2315em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7115em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>：取绝对值后小波基函数的峰值数量。</li></ul><p>通过计算初始段、中间段和最终段的 δ 值（记为 δs、δm、δf），并将其相加得到整体的匹配系数 Δ，从而判断当前小波基函数是否适合当前信号。</p></li><li><p><strong>构建 Δ</strong> ：将三段的 δ 值相加，得到全局匹配系数。</p></li><li><p><strong>参数搜索</strong> ：在 fb 和 fc 的合理范围内搜索使 Δ 最大的参数组合。</p></li><li><p><strong>确定最优参数</strong> ：选择 Δ 最大的参数组合作为最终的小波基函数参数。实验结果显示，最佳的小波基函数参数集中在 fb = 5 或 6，fc ≈ 7 左右。</p></li></ol><h1 id="将小波变换应用于图像">将小波变换应用于图像</h1><p>小波变换不仅可以用于一维信号（如音频、时间序列等），还可以扩展到<strong>二维信号</strong> ，比如图像。在图像处理中，小波变换被广泛应用于图像压缩、去噪、特征提取等领域。</p><p>图像本质上是一个二维信号，可以用一个二维函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 表示，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>​ 是空间坐标。</p><p>图像的小波变换是对这个二维信号进行分解的过程，类似于一维信号的小波变换，但需要考虑两个方向（水平和垂直）。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250519182818729.png" alt="image-20250519182818729"></p><p>具体做法如下：</p><ol><li><strong>水平方向滤波</strong>：</li></ol><ul><li>对图像的每一行使用低通滤波器和高通滤波器，应用一维小波变换，结果生成两个子图像：<ul><li><strong>低频部分</strong>（L）：由低通滤波器生成，表示水平方向的平滑信息。</li><li><strong>高频部分</strong>（H）：由高通滤波器生成，表示水平方向的细节（如边缘）。</li></ul></li></ul><ol start="2"><li><strong>垂直方向滤波</strong>：</li></ol><ul><li>对上一步生成的两个子图像（L 和 H）的每一列再次应用一维小波变换，同样使用低通和高通滤波器。这会将每个子图像进一步分解为两个部分，生成四个子带：<ul><li><strong>LL</strong>（低-低）：水平和垂直方向都经过低通滤波，包含图像的平滑（低频）信息，通常是图像的主要能量所在。</li><li><strong>LH</strong>（低-高）：水平低通、垂直高通，捕获垂直方向的细节。</li><li><strong>HL</strong>（高-低）：水平高通、垂直低通，捕获水平方向的细节。</li><li><strong>HH</strong>（高-高）：水平和垂直方向都高通，捕获对角线方向的细节。</li></ul></li></ul><p>在每次滤波后，通常会进行降采样（downsampling by 2），以减少数据量。 这意味着每个子带的尺寸是原始图像的1/4（宽高各减半）。</p><p>降采样后，四个子带的总像素数等于原始图像的像素数，保持了信息的完整性。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20250519183054393.png" alt="image-20250519183054393"></p><p>小波变换通过不同尺度的分解（由 scaling 参数控制）可以同时分析图像的全局结构（低频）和局部细节（高频）。这种分解支持多分辨率分析、稀疏表示和方向性分析，使其非常适合图像处理任务，如压缩、边缘检测、去噪和模式识别。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 信号处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小波变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础暴力算法</title>
      <link href="/2025/04/15/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/"/>
      <url>/2025/04/15/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="线性枚举">线性枚举</h1><p>线性枚举（Linear Enumeration）是一种暴力枚举的方法，它逐一检查每个可能的解，适用于搜索和枚举问题。</p><p>其核心思路是：对问题的所有可能情况逐一进行遍历，并针对每种情况判断是否满足条件，从而得到解答。</p><p>线性枚举是一种顺序搜索算法，从线性表的第一个元素开始，根据特定的判断条件，做出相应的行为。变种比较多，最常见的就是求最值、求和等等。比如：</p><ol><li><p>求最大值，伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最大值 = 非常小的数</span><br><span class="line">for 当前元素 in 给定的线性表:</span><br><span class="line">    if 当前元素 &gt; 最大值:</span><br><span class="line">        最大值 = 当前元素</span><br><span class="line">返回 最大值 的值</span><br></pre></td></tr></table></figure></li><li><p>求和，伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求和 = 0</span><br><span class="line">for 当前元素 in 给定的线性表:</span><br><span class="line">    求和 = 求和 + 当前元素</span><br><span class="line">返回 求和 的值</span><br></pre></td></tr></table></figure></li></ol><h2 id="时间复杂度">时间复杂度</h2><p>线性枚举需要遍历列表中的每个元素。</p><p>线性枚举的时间复杂度为 O (nm)，其中 n 是线性表的长度，m 是每次操作的量级。</p><p>对于求最大值和求和来说，因为操作比较简单，所以 m 为 1，则整体的时间复杂度是 O (n) 的。</p><p>线性枚举是一种简单而有效的算法思想，它可以用于解决许多基本的算法问题。虽然它的时间复杂度较高，但在处理小型数据集时仍然是一种常用的算法。</p><h2 id="线性枚举的优化">线性枚举的优化</h2><p>对于线性枚举，有很多优化算法：</p><ol><li>二分查找：如果线性表已经排序，可以使用二分搜索来提高搜索效率。</li><li>哈希表：可以使用哈希表来存储已经搜索过的元素，避免重复搜索。</li><li>前缀和：可以存储前 i 个元素的和，避免重复计算。</li><li>双指针：可以从两头开始搜索，提升搜索效率。</li><li>…</li></ol><h2 id="实战">实战</h2><h3 id="存在连续三个奇数的数组">存在连续三个奇数的数组</h3><p><a href="https://leetcode.cn/problems/three-consecutive-odds/description/">力扣链接</a></p><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,6,4,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,2,34,3,4,5,7,23,12]</span><br><span class="line">输出：true</span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h4 id="题解">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器：记录连续的奇数个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] % <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">// 取模判断是否为奇数</span></span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 当计数器为3时直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">0</span>; <span class="comment">// 遇到偶数重置计数器</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="官方题解">官方题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &amp; <span class="number">1</span>) &amp;&amp; (arr[i + <span class="number">1</span>] &amp; <span class="number">1</span>) &amp;&amp; (arr[i + <span class="number">2</span>] &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Note">Note</h4><ul><li><strong>判断奇数可以用按位与运算符 <code>&amp;</code></strong>，<code>arr[i] &amp; 1</code>：如果 <code>arr[i]</code> 是奇数，则其最低位是 <code>1</code>，因此 <code>arr[i] &amp; 1</code> 结果为 <code>1</code>（真）；如果是偶数，则结果为 <code>0</code>（假）。</li></ul><h3 id="最大连续-1-的个数">最大连续 1 的个数</h3><p>给定一个二进制数组 <code>nums</code> ，计算其中最大连续 <code>1</code> 的个数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,0,1,1,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,1,0,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>.</li></ul><h4 id="官方题解-2">官方题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxCount = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxCount = <span class="built_in">max</span>(maxCount, count);<span class="comment">// 刷新最大计数</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数组末位为1不会触发刷新最大计数，需要手动刷新一次最大计数</span></span><br><span class="line">        maxCount = <span class="built_in">max</span>(maxCount, count);</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有序数组中的单一元素">有序数组中的单一元素</h3><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p><p>请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums =  [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h4 id="题解-2">题解</h4><p>暴力求解很简单，但时间复杂度不满足要求，没想出标准答案。数组有序，复杂度要求为 O (logn)，就是在暗示用二分法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历前n-1个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认返回数组最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="官方题解-3">官方题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先找规律：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">1</span>),<span class="number">2</span>,(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>) <span class="comment">// 索引</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>),<span class="number">2</span>,(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">8</span>,<span class="number">8</span>) <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure><p>数组有序，且两两为一对。可以观察到，在单身狗 2 的左侧，每一对相同元素的前一个元素的索引都是偶数（规律 1）, 比如 0；直到单身狗打破规律，因为它是单独的一个，没有人和它一对，所以从这个单身狗以后的右侧，每一对相同元素的前一个元素的索引就变成了奇数（规律 2），比如 3，5，7。</p><p>假设要找的数的索引为 x，我们把符合规律 1 的称为”正常的“，这些数全在 x 的左边，那么”不正常的“就是符合规律 2 的，这些数全在 x 的右边。</p><p>使用二分查找，目标是找到 x：</p><ul><li><p>如果 mid 是偶数，就比较 <code>nums[mid]</code> 和 <code>nums[mid+1]</code>，如果相等，说明是正常的符合规律 1，x 在 mid 的右边，此时更新 low=mid；如果不相等，说明规律 1 被打破，那么 x 就在 mid 的左边，此时更新 high=mid。</p></li><li><p>如果 mid 是奇数，就比较 <code>nums[mid-1]</code> 和 <code>nums[mid]</code>，如果相等，说明是正常的符合规律 1，x 在 mid 的右边，此时更新 low=mid；如果不相等，说明规律 1 被打破，那么 x 就在 mid 的左边，此时更新 high=mid。</p></li></ul><p>这样，不断缩小区间，直到 low=high，就是 x 的索引。</p><h4 id="细节">细节</h4><p>官方题解中没有分奇偶数考虑比较的数，而是使用了 <code>nums[mid] == nums[mid ^ 1]</code>。按位异或运算符 <code>^</code> 是一个二元运算符，它对两个操作数的每一位进行比较。如果两个对应的位不同，则结果为 <code>1</code>；如果相同，则结果为 <code>0</code>。</p><ol><li><p><strong>当 <code>mid</code> 是偶数时，<code>mid + 1 = mid ^ 1</code></strong></p><ul><li><p>如果 <code>mid</code> 是偶数，它的二进制表示的最低位是 <code>0</code>。</p></li><li><p><code>mid ^ 1</code> 会将最低位从 <code>0</code> 变成 <code>1</code>，而其他位保持不变。</p></li><li><p>这等价于将 <code>mid</code> 加上 <code>1</code>。</p></li></ul></li><li><p><strong>当 <code>mid</code> 是奇数时，<code>mid - 1 = mid ^ 1</code></strong></p><ul><li>如果 <code>mid</code> 是奇数，它的二进制表示的最低位是 <code>1</code>。</li><li><code>mid ^ 1</code> 会将最低位从 <code>1</code> 变成 <code>0</code>，而其他位保持不变。</li><li>这等价于将 <code>mid</code> 减去 <code>1</code>。</li></ul></li></ol><h1 id="模拟">模拟</h1><h2 id="前言">前言</h2><p>模拟算法是一类通过模仿自然现象或物理过程来解决复杂问题的计算方法。</p><p>模拟算法其实就是根据题目做，题目要求什么，就做什么。一些复杂的模拟题其实还是把一些简单的操作组合了一下，所以模拟题是最锻炼耐心的，也是训练编码能力的最好的暴力算法。</p><h2 id="数据结构">数据结构</h2><p>​      对于模拟题而言，最关键的其实是数据结构，看到一个问题，选择合适的数据结构，然后根据问题来实现对应的功能。模拟题的常见数据结构主要就是：数组、字符串、矩阵、链表、二叉树 等等。</p><p><strong>1、基于数组</strong></p><p>​      利用数组的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/build-array-from-permutation/">1920.基于排列构建数组</a>、<a href="https://leetcode.cn/problems/create-target-array-in-the-given-order/">1389.按既定顺序创建目标数组</a>、<a href="https://leetcode.cn/problems/design-parking-system/">1603.设计停车系统</a>、<a href="https://leetcode.cn/problems/rearrange-array-elements-by-sign/">2149.按符号重排数组</a>、<a href="https://leetcode.cn/problems/find-triangular-sum-of-an-array/">2221.数组的三角和</a></p><p><strong>2、基于字符串</strong></p><p>​      利用字符串的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/">2011.执行操作后的变量值</a>、<a href="https://leetcode.cn/problems/find-maximum-number-of-string-pairs/">2744.最大字符串配对数目</a>、<a href="https://leetcode.cn/problems/nGK0Fy/">LCP 17.速算机器人</a>、<a href="https://leetcode.cn/problems/complex-number-multiplication/">537.复数乘法</a></p><p><strong>3、基于链表</strong></p><p>​      利用链表的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/merge-nodes-in-between-zeros/">2181.合并零之间的节点</a>、<a href="https://leetcode.cn/problems/find-the-winner-of-the-circular-game/">1823.找出游戏的获胜者</a></p><p><strong>4、基于矩阵</strong></p><p>​      利用矩阵的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">2120.执行所有后缀指令</a>、<a href="https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/">1252.奇数值单元格的数目</a>、<a href="https://leetcode.cn/problems/flipping-an-image/">832.翻转图像</a>、<a href="https://leetcode.cn/problems/robot-return-to-origin/">657.机器人能否返回原点</a>、<a href="https://leetcode.cn/problems/game-of-life/">289.生命游戏</a>、<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59.螺旋矩阵 II</a>、<a href="https://leetcode.cn/problems/spiral-matrix-iii/">885.螺旋矩阵 III</a></p><p><strong>5、基于栈</strong></p><p>​      利用栈的数据结构，如：<a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441.用栈操作构建数组</a></p><p><strong>6、基于队列</strong></p><p>​      利用队列的数据结构，如：<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700.无法吃午餐的学生数量</a></p><h2 id="算法技巧">算法技巧</h2><p>​      模拟时一般会用到一些算法技巧，或者说混合算法，比如 排序、递归、迭代 等等。</p><p><strong>1、排序</strong></p><p>​      排序后，干一件事情，如：<a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/">950.按递增顺序显示卡牌</a></p><p><strong>2、递归</strong></p><p>​      需要借助递归来实现，如：<a href="https://leetcode.cn/problems/count-of-matches-in-tournament/">1688.比赛中的配对次数</a> 、<a href="https://leetcode.cn/problems/count-operations-to-obtain-zero/">2169.得到 0 的操作数</a>、<a href="https://leetcode.cn/problems/add-digits/">258.各位相加</a></p><p><strong>3、迭代</strong></p><p>​      不断迭代求解，其实就是利用 while 循环来实现功能，如：<a href="https://leetcode.cn/problems/incremental-memory-leak/">1860.增长的内存泄露</a>、<a href="https://leetcode.cn/problems/add-digits/">258.各位相加</a></p><h2 id="实战-2">实战</h2><h3 id="交换数字">交换数字</h3><p><a href="https://leetcode.cn/problems/swap-numbers-lcci/description/">交换数字</a></p><p>编写一个函数，不用临时变量，直接交换<code>numbers = [a, b]</code>中<code>a</code>与<code>b</code>的值。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [1,2]</span><br><span class="line">输出: [2,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>numbers.length == 2</code></li><li><code>-2147483647 &lt;= numbers[i] &lt;= 2147483647</code></li></ul><h4 id="题解-3">题解</h4><p>不正确的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">swapNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[<span class="number">1</span>] - numbers[<span class="number">0</span>];</span><br><span class="line">        numbers[<span class="number">1</span>] = numbers[<span class="number">1</span>] - numbers[<span class="number">0</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[<span class="number">1</span>] + numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最直接的想法就是使用加减法，通过记录两个数的和或者差来消除中间变量。可以通过绝大多数测试用例，但是有溢出风险，如果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers = [-2147483647,2147483647]</span><br></pre></td></tr></table></figure><p>对这两个数进行加减就会溢出，需要强转类型。</p><p>实际上这个题的考点在于按位异或<code>^</code>的巧用，异或即：相同为0，不同为1，那么一个数异或上它自己就是0，即：<code>a ^ a = 0; </code></p><p>正确解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">swapNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">        numbers[<span class="number">1</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>]; <span class="comment">// 此时number[1] = number[0]</span></span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>STEP</th><th>numbers[0]</th><th>numbers[1]</th></tr></thead><tbody><tr><td>1</td><td>numbers[0] ^ numbers[1]</td><td>numbers[1]</td></tr><tr><td>2</td><td>numbers[0] ^ numbers[1]</td><td>numbers[0] ^ (numbers[1] ^ numbers[1])= <strong>numbers[0]</strong></td></tr><tr><td>3</td><td>numbers[0] ^ numbers[1] ^ <strong>numbers[0]</strong> =  numbers[1]</td><td><strong>numbers[0]</strong></td></tr></tbody></table><h3 id="位1的个数">位1的个数</h3><p><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/description/">位1的个数</a></p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 <a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><h4 id="题解-4">题解</h4><h5 id="解法一">解法一</h5><p>和整数按位取值的思路一样，当n不为0时（不为0说明一定有1在），取出低位进行判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) count++;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解法二">解法二</h5><p>直接循环检查给定整数 <em>n</em> 的二进制位的每一位是否为 1。当检查第 i 位时，我们可以让 n 与 $2^i $ 进行与运算，根据结果判断这一位是否为1，如果这一位是1，那么与运算的结果就是1，反之为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="找到数组的中间位置">找到数组的中间位置</h3><p><a href="https://leetcode.cn/problems/find-the-middle-index-in-array/description/">找到数组的中间位置</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，请你找到 <strong>最左边</strong> 的中间位置 <code>middleIndex</code> （也就是所有可能中间位置下标最小的一个）。</p><p>中间位置 <code>middleIndex</code> 是满足 <code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code> 的数组下标。</p><p>如果 <code>middleIndex == 0</code> ，左边部分的和定义为 <code>0</code> 。类似的，如果 <code>middleIndex == nums.length - 1</code> ，右边部分的和定义为 <code>0</code> 。</p><p>请你返回满足上述条件 <strong>最左边</strong> 的 <code>middleIndex</code> ，如果不存在这样的中间位置，请你返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,-1,8,4]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">下标 3 之前的数字和为：2 + 3 + -1 = 4</span><br><span class="line">下标 3 之后的数字和为：4 = 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,-1,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">下标 2 之前的数字和为：1 + -1 = 0</span><br><span class="line">下标 2 之后的数字和为：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">不存在符合要求的 middleIndex 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">下标 0 之前的数字和为：0</span><br><span class="line">下标 0 之后的数字和为：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h4 id="题解-5">题解</h4><h5 id="解法一：暴力求解">解法一：暴力求解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMiddleIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历数组，检查是否满足左侧和等于右侧和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;<span class="comment">// 计算 i 的左侧和</span></span><br><span class="line">                l += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i<span class="number">+1</span>; k &lt; num.<span class="built_in">size</span>(); ++k)&#123;<span class="comment">// 计算 i 的右侧和</span></span><br><span class="line">                r += nums[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( l == r)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果没有找到中间索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解法二：前缀和</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMiddleIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>, leftSum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算数组的总和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;totalSum += num;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组，检查是否满足左侧和等于右侧和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 右侧和 = 总和 - 左侧和 - 当前元素</span></span><br><span class="line">            <span class="type">int</span> rightSum = totalSum - leftSum - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (leftSum == rightSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftSum += nums[i]; <span class="comment">// 更新左侧和</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果没有找到中间索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="递推">递推</h1><p><strong>递推算法</strong>是一种通过已知条件和特定递推关系式，逐步推导出问题结果的算法。它通常以一个明确的初始条件（或边界条件）开始，然后通过递推公式逐步求解后续结果。</p><h2 id="递推算法的结构"><strong>递推算法的结构</strong></h2><ol><li><strong>初始条件</strong><ul><li>给定问题的边界或起点。</li></ul></li><li><strong>递推关系</strong><ul><li>根据问题规律，确定如何通过前面的结果推导当前结果。</li></ul></li><li><strong>终止条件</strong><ul><li>决定何时停止递推。</li></ul></li></ol><h2 id="经典示例：斐波那契数列"><strong>经典示例：斐波那契数列</strong></h2><p>斐波那契数列的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0</span><br><span class="line">F(1) = 1</span><br><span class="line">F(n) = F(n−1) + F(n−2) (n≥2)</span><br></pre></td></tr></table></figure><p>采用递推算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prev1 = <span class="number">0</span>, prev2 = <span class="number">1</span>; <span class="comment">// 初始化 F(0) 和 F(1)</span></span><br><span class="line">    <span class="type">int</span> current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        current = prev1 + prev2; <span class="comment">// F(i) = F(i-1) + F(i-2)</span></span><br><span class="line">        prev1 = prev2;</span><br><span class="line">        prev2 = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归算法也可以，更容易理解，但有重复计算，可能会超时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战-3">实战</h2><h3 id="爬楼梯">爬楼梯</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h4 id="题解-6">题解</h4><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Fjm-lp7smYIBcwH5PvFxvhyuk4qp.gif" alt="img|500"></p><p>这道题其实是斐波那契数列的变形。</p><p>由于每次可以只能爬1个或2个台阶，所以，如果处在第 i 阶台阶，那么它只能是从第 i-1或者第i-2阶台阶爬上来的，那么就有 f(i) = f(i-1) + f(i-2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>, f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> f1;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            f = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="杨辉三角">杨辉三角</h3><p><a href="https://leetcode.cn/problems/pascals-triangle/description/">杨辉三角</a></p><p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h4 id="题解-7">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ret</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            ret[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);<span class="comment">// 每一行有 i+1 个元素</span></span><br><span class="line">            ret[i][<span class="number">0</span>] = ret[i][i] = <span class="number">1</span>;<span class="comment">// 首尾固定为 1</span></span><br><span class="line">            <span class="comment">// 处理中间元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                ret[i][j] = ret[i - <span class="number">1</span>][j] + ret[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 递推关系式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础暴力算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-1计算机系统漫游</title>
      <link href="/2023/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
      <url>/2023/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CSAPP-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>课程资源汇总：</p><ul><li><a href="https://www.bilibili.com/video/BV1iW411d7hd?vd_source=b27c2033e113f55ac2c4b0336ebb8e03">CSAPP视频课</a></li><li><a href="http://csapp.cs.cmu.edu/">课程网址</a></li><li><a href="https://pan.baidu.com/s/1JKj7WUeB7opqcvbp0WtEnw?pwd=qnnj">书籍下载</a></li></ul><hr><h1 id="计算机系统漫游">计算机系统漫游</h1><h2 id="信息就是位-上下文">信息就是位+上下文</h2><ul><li><p>hello.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> O;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>hello 程序的生命周期是从一个<font color="#c00000">源程序</font>（或者说<font color="#c00000">源文件</font>）开始的，即程序员通过<font color="#245bdb">编译器</font>创建并保存的<font color="#245bdb">文本文件</font> hello.c。</p><ul><li>源程序实际上由 0 和 1 组成的<font color="#245bdb">比特序列</font>，每 8 位称为一个<font color="#c00000">字节</font>。每个字节表示程序中的某些文本字符。</li><li>大部分现代计算机系统都是用 <font color="#245bdb">ASCII</font> 标准来表示文本字符，即用唯一的一个单字节大小（8bit）表示的整数来表示每一个字符。</li><li>hello.c 程序<font color="#00b050">以字节序列的方式</font>存储在文件中。</li><li>像 hello.c 这样只由 ASCII 字符构成的文件称为<font color="#c00000">文本文件</font>，其余的所有文件都称为<font color="#c00000">二进制文件</font>。</li><li>计算机系统中的所有文件——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网上传送的数据，都是由一串比特表示的。</li></ul></li></ul><hr><h2 id="程序的编译过程">程序的编译过程</h2><ul><li><p>为了能够在系统中运行 hello.c 程序，每条 C 语句都必须经其他程序转化为一系列的<font color="#245bdb">低级机器语言指令</font>，并以<font color="#245bdb">可执行目标程序</font>的格式打包好，再以<font color="#245bdb">二进制磁盘文件</font>的形式存放起来。目标程序也称为<font color="#245bdb">可执行目标文件</font>。</p></li><li><p>Unix 系统上将源文件转换为目标文件要借助<font color="#245bdb">编译驱动程序</font>：<code>linux&gt; gcc -o hello hello.c</code>，GCC 驱动程序读取源程序文件 hello.c，并将其翻译成一个可执行文件 hello。</p></li><li><p><mark style="background: #BBFABBA6;">编译系统=预处理器+编译器+汇编器+链接器：</mark></p><ul><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230422000704347.png" alt="image-20230422000704347"></li></ul><ol><li><font color="#245bdb">预处理阶段</font>：预处理器 cpp 根据以字符 <code>#</code> 开头的命令，修改原始的 C 程序，得到一个新程序 hello.i。</li><li><font color="#245bdb">编译阶段</font>：编译器 ccl 将修改后的源程序 hello.i 翻译成汇编语言程序 hello.s。</li><li><font color="#245bdb">汇编阶段</font>：汇编器 as 将 hello.s 翻译成机器语言指令，打包成<font color="#c00000">可重定位目标程序</font>（relocatable object program）的格式，保存在 hello.o 中。hello.o 是一个二进制文件。</li><li><font color="#245bdb">链接阶段</font>：因为 hello 程序调用了 print 库函数（保存在一个名叫 print.o 的目标文件中），而链接器负责将 print.o 合并到 hello.o 程序中，得到一个可执行文件 hello（默认名叫 a.out），可执行文件可以被加载到内存中，由系统执行。</li></ol></li><li><p>编译系统的主要作用：</p><ol><li>优化程序性能</li><li>理解链接时出现的错误。</li><li>避免安全漏洞</li></ol></li></ul><h2 id="系统的硬件组成">系统的硬件组成</h2><ul><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230422012153546.png" alt="image-20230422012153546"></li></ul><ol><li><font color="#c00000">总线</font>：贯穿整个系统的一组电子管道，负责在各个部件之间传递字节信息。<ul><li>总线通常被设计为传递定长的字节块，即<font color="#245bdb">字（word）</font>。字中包含的字节数（字长）是一个基本的系统参数，一般有 4 个字节（32 位）和 8 个字节（64 位）之分。</li></ul></li><li><font color="#c00000">I/O 设备</font>：系统与外界传递信息的通道。<ul><li><u>键盘</u>、<u>鼠标</u>、<u>显示器</u>、<u>磁盘</u>等</li><li>每个 I/O 设备都通过一个<font color="#245bdb">控制器</font>或<font color="#245bdb">适配器</font>与 I/O 总线相连</li><li>控制器与适配器的区别在于它们的封装方式，它们的功能都是在 I/O 总线与 I/O 设备之间传递信息。</li></ul></li><li><font color="#c00000">主存</font>：是一个临时存储设备，在处理执行程序时用来存放程序与数据。<ul><li>物理上，主存是由一组动态<font color="#245bdb">随机存取存储器 DRAM</font> 芯片组成；</li><li>逻辑上，<font color="#245bdb">一个线性的字节数组</font>，每个字节都有唯一的地址（数组索引）。</li></ul></li><li><font color="#c00000">处理器</font>：<font color="#245bdb">中央处理单元 CPU</font>，解释或执行机器指令（存储在主存中）的引擎。<ul><li>处理器的核心是一个大小为一个字的寄存器，称为<font color="#245bdb">程序计数器 PC</font>；</li><li><mark style="background: #BBFABBA6;">程序计数器永远保存着下一条将要执行的指令的地址。</mark></li><li>处理器的任务就是不间断地读取 PC 指向的指令，对其进行解释并执行相应的简单操作，再更新程序计数器。</li><li>简单操作一般围绕主存、寄存器文件（register file）、算术逻辑单元 ALU 进行。</li></ul></li></ol><h2 id="运行-hello-程序">运行 hello 程序</h2><ul><li><p>要想在 Unix 系统上运行该可执行目标文件 hello，只需要在 shell 中输入文件名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">./hello</span></span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure></li><li><p><font color="#92d050">shell 是一个命令行解释器</font>，它输出一个提示符，等待用户输入一个命令行，然后执行这个命令。如果这个命令不是 shell 内置的命令，shell 就会认为这是一个可执行文件的名字，它就会加载并运行这个文件。</p></li><li><p>当我们在键盘上输入字符串 <code>./hello</code> 后，shell 会执行一系列指令来加载 hello，将 hello 的代码和数据从磁盘复制到主存。此时，CPU 就开始执行 main 中的机器语言指令，这些指令会将 <code>hello, world\n</code> 字符串中的字节从主存再复制到寄存器文件，再从寄存器文件复制到现实设备，最终显示到屏幕上。</p></li></ul><h2 id="高速缓存">高速缓存</h2><ul><li>从上面可以看出，系统花费了大量的时间把信息从一个地方挪到另一个地方。</li><li>根据机械原理，大的存储设备比小的存储设备运行得慢，而快速设备的造价远高于同类的低俗设备。</li><li>寄存器中的读取比主存中的读取速度要快几乎 100 倍，并且这个差距还在不断加大。</li><li>针对<font color="#245bdb">处理器</font>和<font color="#245bdb">主存</font>之间的差异，设计人员采用了<font color="#c00000">高速缓存存储器（cache memory）</font>，简称 <font color="#c00000">cache</font> 或者<font color="#c00000">高速缓存</font>。</li><li>cache 作为暂时的集结区域，存放处理器近期可能用到的信息。</li><li>L1 高速缓存位于处理器芯片上，访问速度几乎和寄存器文件一样快。</li><li>L2 高速缓存通过一条特殊的总线连接到处理器，L2 高速缓存容量更大，但速度不及 L1 高速缓存，但仍然比直接访问主存要快很多。</li><li>L1 和 L2 高速缓存时通过<font color="#245bdb">静态随机访问存储器（SRAM）</font>的硬件技术实现的。</li><li>高速缓存利用了局部性原理，即<font color="#92d050">程序具有访问局部区域里的数据和代码的趋势。</font></li></ul><h2 id="操作系统管理硬件">操作系统管理硬件</h2><ul><li><p>程序不直接访问键盘、显示器、磁盘或者主存，它们依靠操作系统提供的<font color="#245bdb">服务</font>（API）。</p></li><li><p><mark style="background: #BBFABBA6;">可以把操作系统看成是<font color="#245bdb">应用程序和硬件之间</font>插入的一层<font color="#245bdb">软件</font>，所有程序对硬件的操作尝试都必须通过操作系统。</mark></p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230422155919602.png" alt="image-20230422155919602"></p></li><li><p>操作系统的两个功能：</p><ol><li>防止硬件被失控的程序滥用；</li><li>向应用程序提供简单一致的机制来控制低级硬件设备。</li></ol></li><li><p>操作系统通过几个几本的抽象来实现这两个功能：</p><ul><li><font color="#245bdb">文件</font>是对 I/O 设备的抽象表示；</li><li><font color="#245bdb">虚拟内存</font>是对主存和磁盘 I/O 设备的抽象表示；</li><li><font color="#245bdb">进程</font>是对处理器、主存和 I/O 设备的抽象表示。</li></ul></li></ul><h3 id="进程">进程</h3><ul><li><font color="#c00000">进程</font>是操作系统对一个正在运行的程序的一种<font color="#c00000">抽象</font>。<ul><li>在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。</li></ul></li><li><font color="#c00000">并发运行</font>：一个进程的指令和另一个进程的指令交错执行。<ul><li>多核处理器同时能够执行多个程序。无论是单核处理器还是多核处理器，单个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程之间快速切换实现的。</li></ul></li><li>操作系统实现这种交错执行的机制称为<font color="#c00000">上下文切换</font>。<ul><li>操作系统保持跟踪进程运行所需要的所有状态信息。</li><li><mark style="background: #BBFABBA6;">状态就是上下文，包括 PC、寄存器的值、主存等。（程序就是状态机）</mark></li><li>在任意时刻，单处理器系统都只能执行一个进程代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换。</li></ul></li></ul><hr><ul><li>示例：以最开始的 hello 程序为例<ol><li>最开始，只有 shell 进程在运行，即等待命令行的输入。</li><li>输入 <code>./hello</code> 并按下回车后，shell 执行<font color="#92d050">一条特殊的指令</font> <code>syscall</code>，即<font color="#c00000">系统调用</font>。</li><li>操作系统保存当前 shell 进程的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程；</li><li>hello 进程执行结束，会再次执行系统调用。操作系统此时会恢复 shell 进程的上下文，并将控制权传回 shell。</li></ol></li><li>从一个进程到另一个进程的切换是由操作系统<font color="#c00000">内核（kernel）</font>管理的。内核是操作系统代码常驻内存的地方。</li><li><mark style="background: #BBFABBA6;">内核不是一个独立的进程，它时系统管理全部进程所有代码和数据结构的集合。</mark></li></ul><h3 id="线程">线程</h3><ul><li>一个进程实际上可以由多个称为<font color="#c00000">线程</font>的执行单元组成，每个线程都运行在进程的上下文当中，并<font color="#92d050">享有同样的代码和全局数据</font>。（线程之间共享同一块主存）</li><li>当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</li></ul><h3 id="虚拟内存">虚拟内存</h3><ul><li><p><font color="#c00000">虚拟内存</font>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在<font color="#92d050">独占</font>主存。</p></li><li><p>每个进程看到的内存都是一样的，称为<font color="#c00000">虚拟地址空间</font>。</p></li><li><p>进程的虚拟地址空间：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230422213317702.png" alt="image-20230422213317702"></p></li><li><p><font color="#245bdb">程序代码和数据</font>。对所有的进程来说，代码都是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</p></li><li><p><font color="#245bdb">堆</font>。代码和数据区在一开始运行时就被指定了大小，与此不同，当调用 malloc 和 free 这样的 C 标准库函数时，<mark style="background: #BBFABBA6;">堆可以在运行时动态地扩展和收缩</mark>。</p></li><li><p><font color="#245bdb">共享库</font>。用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。</p></li><li><p><font color="#245bdb">栈</font>。编译器用<font color="#92d050">用户栈</font>来实现函数调用，用户栈位于用户虚拟地址空间顶部。<mark style="background: #BBFABBA6;">调用函数或从一个函数返回时，用户栈会动态扩展或收缩。</mark></p></li><li><p><font color="#245bdb">内核虚拟内存</font>。地址空间顶部的区域是为内核保留的，应用程序不允许直接访问。</p></li></ul><h3 id="文件">文件</h3><ul><li><mark style="background: #BBFABBA6;">文件就是字节序列。</mark></li><li>每个 I/O 设备，包括磁盘、键盘、显示器、甚至网络，都可以看成是文件。</li><li>系统中所有输入输出都是通过使用一组称为 Unix I/O 的系统函数调用读写文件来实现的。</li><li>文件系统为应用程序提供了一个统一的接口来与这些 I/O 设备传递信息，应用程序不需要关心具体的磁盘技术。</li></ul><h2 id="系统之间利用网络通信">系统之间利用网络通信</h2><ul><li><mark style="background: #BBFABBA6;">从一个单独的系统来看，网络可以视为一个 I/O 设备。</mark></li><li>当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</li></ul><h2 id="重要主题">重要主题</h2><ul><li>系统不仅仅是硬件。<mark style="background: #BBFABBA6;">系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。</mark></li></ul><h3 id="Amdahl-定律">Amdahl 定律</h3><ul><li><p>Amdahl 定律的主要思想：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于<font color="#92d050">该部分的重要性</font>和<font color="#92d050">加速的程度</font>。</p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo fence="true">)</mo></mrow><msub><mi>T</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi></mrow></msub><mo>+</mo><mrow><mo fence="true">(</mo><mi>α</mi><msub><mi>T</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">d</mi></mrow></msub><mo fence="true">)</mo></mrow><mi mathvariant="normal">/</mi><mi>k</mi><mo>=</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi></mrow></msub><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo></mrow><annotation encoding="application/x-tex">T_{\mathrm{new}}=\left(1-\alpha\right)T_{\mathrm{old}}+\left(\alpha T_{\mathrm{odd}}\right)/k=T_{\mathrm{old}}\big[(1-\alpha)+\alpha/k\big]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">odd</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size1">[</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="delimsizing size1">]</span></span></span></span></span></span></p><ul><li>α是系统某部分所需要执行时间占总执行时间的比例；</li><li>k 是该部分的提升比例。</li></ul></li><li><p>由此，可以计算加速比：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi></mrow></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mi mathvariant="normal">/</mi><mi>k</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=T_{\mathrm{old}}/T_{\mathrm{new}}=\frac{1}{(1-\alpha)+\alpha/k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p><mark style="background: #BBFABBA6;">Amdal 的主要观点：要想加速真个系统，必须提升全系统中相当大部分的速度。</mark></p></li><li><p>特殊情况：当 k 趋向∞时（即部分系统可以加速到不需要花费时间）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi mathvariant="normal">∞</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">S_\infty=\dfrac{1}{(1-\alpha)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>Amdal 定律描述了改善任何过程的一般原则，除了用在计算机系统的加速上，还可以用在工厂的成本控制，包括学生的绩点等方面。</p></li></ul><h3 id="并发与并行">并发与并行</h3><ul><li><p>两个需求</p><ol><li>想让计算机做得更多</li><li>想让计算机做得更快<br>当处理器可以同时做更多事情时，这两个因素都会改进。</li></ol></li><li><p>我们用术语<font color="#c00000">并发</font>表示一个同时具有多个活动的系统（强调管理）；而术语<font color="#c00000">并行</font>指的是用并发来使一个系统运行得更快。</p></li></ul><blockquote><ul><li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li><li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li></ul></blockquote><hr><ul><li>并行可以在计算机系统的多个抽象层次上运用。按照系统层析结构中由高到低的顺序重点强调 3 个层次：</li></ul><ol><li><p><font color="#c00000">线程级并发</font></p><ul><li>线程级并发构建在进程这个抽象上。我们甚至可以使用多线程在一个进程中执行多个控制流。</li><li>传统意义上（单处理器系统），这个并发只是模拟出来的，它通过计算机在正在执行的进程之间快速切换来实现。</li><li>随着<font color="#245bdb">多核处理器</font>和<font color="#245bdb">超线程</font>（hyper-threading）的出现，多处理器系统现在非常普遍。</li><li>多核处理器是将多个 CPU 集成到一个集成电路芯片上，每个核都由自己的 L1 和 L2 虚拟高速缓存。L1 高速缓存分为两个部分（哈弗结构）——一个保存最近收到的指令，另一个存放数据。这些核共享更高层次的高速缓存和主存接口。</li><li><font color="#245bdb">超线程</font>，也称<font color="#245bdb">同时多线程</font>（simultaneous multi-threading），是一项允许 CPU 执行多个控制流的技术。</li><li>多处理器的使用可以从两个方面提高系统性能：<ol><li>减少了执行多个任务时模拟并发的需求</li><li>使程序运行得更快（要求程序以多线程方式来书写）</li></ol></li></ul></li><li><p><font color="#c00000">指令级并行</font></p><ul><li>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。</li><li>在<font color="#92d050">流水线</font>（pipelining）中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。这样，可以达到一个时钟周期就可以处理一条指令的执行速率。</li><li>如果处理器可以达到<font color="#92d050">比一个周期一条指令更快</font>的执行速率，就称为<font color="#245bdb">超标量（super-scalar）处理器</font>。</li></ul></li><li><p><font color="#c00000">单指令、多数据执行</font></p><ul><li>在最低的层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，即单指令、多数据执行（SIMD 并行）。</li></ul></li></ol><h3 id="抽象的重要性">抽象的重要性</h3><ul><li><font color="#c00000">抽象</font>的使用是计算机科学中最重要的概念之一。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。</li><li><mark style="background: #BBFABBA6;">文件是对 I/O 设备的抽象；</mark></li><li><mark style="background: #ABF7F7A6;">虚拟内存是对程序存储器的抽象；</mark></li><li><mark style="background: #D2B3FFA6;">进程是对一个正在运行的程序的抽象；</mark></li><li><mark style="background: #FF5582A6;">虚拟机是对整个计算机的抽象，包括操作系统、处理器和程序。</mark></li></ul><h2 id="小结">小结</h2><ul><li>计算机系统是由<font color="#245bdb">硬件</font>和系统<font color="#245bdb">软件</font>组成的，它们共同协作以运行应用程序。</li><li>计算机内部的信息被表示为一组组的比特，同样的比特序列依据<font color="#245bdb">上下文（状态）</font>有不同的解释方式。</li><li>程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被<font color="#245bdb">编译器</font>和<font color="#245bdb">链接器</font>翻译成<font color="#245bdb">二进制可执行文件</font>。处理器读取并解释存放在主存里的二进制指令。</li><li>因为计算机花费了大量的时间在<font color="#245bdb">内存</font>、<font color="#245bdb">I/O 设备</font>和 <font color="#245bdb">CPU 寄存器</font>之间复制数据，所以将系统中的存储设备划分成层次结构一：<ul><li>CPU 寄存器在顶部</li><li>接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。</li><li>在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。</li><li>层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。</li></ul></li><li><mark style="background: #BBFABBA6;">操作系统<font color="#245bdb">内核</font>是应用程序和硬件之间的媒介，它提供三个基本的抽象（文件、虚拟内存、程序）。</mark></li><li>最后，<font color="#245bdb">计算机网络</font>提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP-1操作系统上的程序</title>
      <link href="/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSTEP-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="课程资源">课程资源</h1><ul><li>课程名称：《操作系统：设计与实现》（2022）——南京大学蒋炎岩老师</li></ul><ul><li><a href="http://jyywiki.cn/OS/2022/">课程网站</a></li><li><a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498">课程视频</a></li><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">课程教材</a></li><li><a href="http://jyywiki.cn/OS/2022/">课程作业</a></li></ul><hr><h1 id="读书笔记">读书笔记</h1><ul><li>范围：<ul><li>第 1 章：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-threeeasy.pdf">Dialogue</a></li><li>第 2 章：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf">Introduction to Operating Systems</a></li></ul></li></ul><h2 id="Introduction">Introduction</h2><ul><li><p>当一个程序在运行时到底发生了什么？<br>一个正在运行的程序只做一件非常简单的事情——<font color="#245bdb">执行指令</font>：<br>处理器每秒数百万次或上亿次地从内存中获取指令，对其进行解码（即找出这到底是哪条指令），然后执行之（访问内存、检查条件、跳转函数等）。这条指令执行结束后，处理器就继续抓取下一条指令。重复上述过程直到整个程序结束。</p></li><li><p>什么是<font color="#c00000">操作系统</font>（OS）？<br>操作系统是这样一个软件，它负责让程序运行变得更容易（甚至可以让你看起来同时运行很多程序），允许程序共享内存，允许程序与设备交互等等，它使得系统以易于使用的方式正确和有效地运行。<br>操作系统 OS 早期被称作<font color="#245bdb">监督程序</font>（Supervisor）或者<font color="#245bdb">主控制程序</font>（Master Control Program）。</p></li><li><p>什么是<font color="#c00000">虚拟化</font>（Virtualization）?<br>操作系统主要通过使用虚拟化这一通用技术来实现其自身功能，即操作系统获取物理资源（处理器、内存、磁盘等）并且将其转化为更通用、更强大、更易于使用的虚拟形式。因此，操作系统有时也被称作<font color="#245bdb">虚拟机</font>。<br>操作系统还提供了一些供程序调用的接口（<font color="#245bdb">API</font>）来进行程序运行、访问内存和设备等操作，所以有时也说操作系统为应用程序提供了标准库。<br>虚拟化允许众多程序共享 CPU，共享内存、共享磁盘等，所以操作系统有时也被认为是一个<font color="#245bdb">资源管理器</font>。</p></li></ul><h2 id="虚拟化">虚拟化</h2><ul><li>问题的关键在于：操作系统如何将资源虚拟化？<br>操作系统需要哪些机制和策略来实现虚拟化？如何有效地实现虚拟化？需要哪些硬件支持？</li></ul><h3 id="虚拟化-CPU">虚拟化 CPU</h3><ul><li>将一个 CPU（或一小组 CPU）变成<u>看似</u>无限数量的 CPU，从而允许许多程序<u>看似</u>在同时运行，这就是<font color="#c00000">虚拟化 CPU</font> 。</li></ul><h3 id="虚拟化内存">虚拟化内存</h3><ul><li><p>现代机器的物理内存模型非常简单：<mark style="background: #BBFABBA6;">内存就是一个字节数组</mark>，读取、写入或更改内存必须指明存储地址。</p></li><li><p>只要运行程序，就必然要访问内存。程序里所有数据结构都存储在内存里，程序依靠执行各种指令来访问它们。当然，指令也会保存在内存中，处理器在抓取指令时也要访问内存。</p></li><li><p>操作系统<font color="#c00000">虚拟化内存</font>：每个正在运行的程序都有自己的<font color="#245bdb">私有虚拟地址空间</font>，操作系统以某种方式将其映射到真实的物理内存上。正在运行的多个程序的内存彼此之间不会影响。</p></li></ul><blockquote><p>它使得应用程序认为自己拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p></blockquote><h2 id="并发">并发</h2><ul><li><p><font color="#c00000">并发（Concurrency）</font>这个概念术语用来指代在同一程序中同时（即并发）处理许多事情时出现的、必须解决的一系列问题。</p></li><li><p>并发产生的问题首先出现在操作系统自身内部，而多线程程序也存在同样的问题。</p></li><li><p>你可以将一个线程看作与其他函数运行在同一内存空间中的函数，同一时间内它们至少有一个在运行。</p></li><li><p>多线程程序同时工作在同一块内存空间上，可能会得到一些不正常的结果。事实证明，这些奇怪和不寻常的结果的原因与指令的执行方式有关。比如多个线程共享一个计数器，计数器递增需要三个指令：首先将计数器的值从内存加载到寄存器中，然后执行运算将值递增，最后将值再写入内存。因为这 3 条指令不是以<font color="#245bdb">原子方式</font>（atomically）执行（所有的指令一次性执行）的，所以会发生意想不到的结果。</p></li><li><p>问题的关键在于：如何构建正确的并发程序？<br>当多个线程同时在同一内存空间执行时，我们该如何构建一个正确工作的程序？操作系统需要哪些原语？硬件应该提供何种机制？如何利用它们去解决并发问题？</p></li></ul><h2 id="持久性">持久性</h2><ul><li><p>在系统内存中，数据很容易丢失，许多设备比如 <font color="#245bdb">DRAM (Dynamic Random Access Memory 动态随机存取存储器) </font>以一种不稳定的方式来存储数据。当电源关闭或者系统崩溃时，内存中的所有数据都会丢失。因此，我们需要硬件和软件能够持续存储数据。</p><blockquote><p>DRAM 是一种半导体存储器，利用电容内存储电荷的多少来代表一个二进制比特（bit）是 1 还是 0。现实中晶体管存在漏电现象，导致电容上所存储的电荷数量并不足以正确的判别数据，从而导致数据毁损。 DRAM 必须周期性地充电，由于这种需要定时刷新的特性，因此被称为“动态”存储器。相对来说，静态存储器（SRAM）只要存入数据后，纵使不刷新也不会丢失数据。</p></blockquote></li><li><p>硬件通常以某种输入/输出或 I/O 设备的形式出现，被用来存储长期保存的信息。常见的有<font color="#245bdb">硬盘驱动器</font>和<font color="#245bdb">固态驱动器（SSD）</font>。</p></li><li><p><mark style="background: #BBFABBA6;"> 操作系统中管理磁盘的软件被称为<font color="#245bdb">文件系统</font>，负责以可靠和高效的方式在磁盘上存储任何用户创建的文件。</mark></p></li><li><p>与操作系统为 CPU 和内存提供的<font color="#245bdb">抽象</font>不同，操作系统不会为每个程序都创建专用的虚拟磁盘，而是假设用户需要的是共享文件中的信息。以编写 C 程序为例，首先使用编辑器创建和编辑一个 C 文件，然后用编译器将源代码转换为可执行文件，最后再运行这个可执行文件。在这个过程中，文件在不同的进程之间进行共享。</p></li><li><p>操作系统为了将数据实际写入磁盘到底做了什么？</p><p>文件系统必须做很多工作：首先要确定新数据要存储在磁盘的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这个过程需要向底层存储设备发出 I/O 请求，以读取现有结构或者更新它们。操作系统提供了一个通过系统调用来访问设备的标准和简单方法，使人们不必再深入了解底层设备接口及其语义。所以，OS 有时也被视为<font color="#245bdb">标准库</font>（standard library）。</p></li><li><p>出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如<font color="#245bdb">日志</font>（journaling）或<font color="#245bdb">写时复制</font>（copy-on-write），仔细排序写入磁盘的操作以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。</p></li><li><p>问题的关键在于：如何持久地存储数据？</p><p>文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？</p></li></ul><h2 id="操作系统的设计目标">操作系统的设计目标</h2><ul><li>操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期随全。鉴于我们希望建立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现，甚在必要时进行折中。</li></ul><ol><li><p>一个最基本的目标，是建立一些<font color="#245bdb">抽象</font>（abstraction），让系统方便和易于使用。</p><p>抽象使得编写一个大型程序成为可能，用 C 这样的高级语言编写程序不用考虑汇编，用汇编写代码不用考虑逻辑门，用逻辑门来构建处理器不用太多考虑晶体管。抽象是如此重要，有时我们会忘记它的重要性。</p></li><li><p>设计和实现操作系统的一个目标，是提供高性能（performance）。换言之，我们的目标是最小化操作系统的<font color="#245bdb">开销</font>（minimize the overhead）。</p><p>虚拟化和让系统易于使用不会不计较成本。开销以多种形式出现：<font color="#245bdb">额外时间</font>（更多指令）和<font color="#245bdb">额外空间</font>（内存或磁盘上）。完美并非总是可以实现的，我们应当寻求解决方案，尽量减少其中的一种或者两种。</p></li><li><p>另一个目标是在应用程序之间以及在 OS 和应用程序之间提供保护（protection）。</p><p>当多个程序同时运行时，必须确保某一个程序的不良行为无法损害其他程序。程序也不应损害操作系统本身，这会影响系统上运行的所有程序。保护是操作系统基本原理的一个核心就是<font color="#245bdb">隔离</font>（isolation），让进程彼此隔离是保护的关键。</p></li><li><p>操作系统也必须不间断运行。操作系统往往力求提供高度的可靠性（reliability）。</p></li><li><p>其他目标：能源效率（energy-efficiency）、安全性（security）、移动性（mobility）等。</p></li></ol><h1 id="课堂笔记">课堂笔记</h1><h2 id="什么是操作系统？">什么是操作系统？</h2><ol><li>课本定义：</li></ol><blockquote><p>Operating System: A body of software, in fact, that is responsible for <em>making it easy to run programs</em> (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p></blockquote><ol start="2"><li>“管理软/硬件资源、为程序提供服务”的<u>程序</u>。</li><li>“精准”的定义毫无意义，本课程讨论<font color="#c00000">狭义的操作系统</font>：<ul><li><mark style="background: #BBFABBA6;">对单一计算机硬件系统作出抽象、支撑程序执行的软件系统</mark>；</li><li>学术界谈论 “操作系统” 是更广义的 “System” (例子：OSDI/SOSP)、</li></ul></li><li>操作系统没有传说中那么复杂：<ul><li>应用视角（设计）：一组对象（进程/文件） + API</li><li>硬件视角（实现）：一个 C 程序</li></ul></li></ol><h2 id="理解操作系统">理解操作系统</h2><ol><li>操作系统服务谁？<ul><li><mark style="background: #BBFABBA6;">程序 = 状态机</mark></li></ul></li><li>(设计/应用视角) 操作系统为程序提供什么服务？<ul><li><mark style="background: #BBFABBA6;">操作系统 = 对象 + API</mark></li></ul></li><li>(实现/硬件视角) 如何实现操作系统提供的服务？<ul><li><mark style="background: #BBFABBA6;">操作系统 = C 程序</mark></li></ul></li></ol><h2 id="操作系统上的程序">操作系统上的程序</h2><ul><li>操作系统有三条主线：“软件 (应用)”、“硬件 (计算机)”、“操作系统 (软件直接访问硬件带来麻烦太多而引入的中间件)”。想要理解操作系统，对操作系统的服务对象——应用程序，有精确的理解是必不可少的。</li><li>本次课回答的主要问题：到底什么是程序？</li><li>本次课的主要内容：<ol><li>程序的状态机模型 (和编译器)</li><li>操作系统上的 {最小/一般/图形} 程序</li></ol></li></ul><h3 id="数字电路与状态机">数字电路与状态机</h3><ul><li><p><font color="#c00000">时钟周期</font></p><ul><li>也称为<font color="#245bdb">震荡周期</font>，定义为时钟频率的倒数。<u>更小</u>的时钟周期意味着<u>更高</u>的工作频率。</li><li>时钟周期是计算机中 CPU 工作最基本的、最小的时间单位。</li><li>在一个时钟周期内，CPU 仅能完成一个最基本的动作。</li><li>在单个时钟周期内，逻辑 0 状态与逻辑 1 状态来回切换。</li></ul></li><li><p><font color="#c00000">状态机</font></p><ul><li>状态机由<font color="#245bdb">状态寄存器</font>和<font color="#245bdb">组合逻辑电路</font>组成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。</li><li>状态机就是<font color="#245bdb">状态转移图</font>。它是一个有向图形，由一组节点和一组相应的转移函数组成。状态机通过响应一系列事件而”运行“。这些节点中至少有一个必须是<font color="#245bdb">终态</font>。当到达终态，状态机停止。</li><li>状态机模型：<ul><li>状态：寄存器保存的值</li><li>初始状态：状态机 RESET 后的值</li><li>迁移：组合逻辑电路计算寄存器下一周期的值</li></ul></li></ul></li><li><p><font color="#c00000">数字电路</font></p><ul><li>用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路。由于它具有逻辑运算和逻辑处理功能，所以又称<font color="#245bdb">数字逻辑电路</font>。</li><li><font color="#245bdb">逻辑门</font>是数字逻辑电路的基本单元。<font color="#245bdb">存储器</font>是用来存储二进制数据的数字电路。</li><li>从整体上看，数字电路可以分为<font color="#245bdb">组合逻辑电路</font>和<font color="#245bdb">时序逻辑电路</font>两大类。</li><li>组合逻辑电路由最基本的逻辑门电路组合而成，输出值只与当时的输入值有关，电路没有记忆功能，输出状态随着输入状态的变化而变化。</li><li>时序逻辑电路由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成，输出不仅取决于当时的输入值，而且还与电路过去的状态有关，具有记忆功能。如触发器、锁存器、计数器、移位寄存器、储存器等电路都是时序电路的典型器件。</li></ul></li></ul><h3 id="什么是程序（C-程序的语义）">什么是程序（C 程序的语义）</h3><ul><li><p><mark style="background: #BBFABBA6;">程序就是状态机</mark></p></li><li><p>C 程序的状态机模型：</p><ul><li>状态 = stack frame 的列表 (每个 frame 有 PC) + 全局变量</li><li>初始状态 = 仅有一个 frame: <code>main(argc, argv)</code> ；全局变量为初始值</li><li>迁移 = 执行 top stack frame PC 的语句; PC++<ul><li>函数调用 = push frame (frame. PC = 入口)</li><li>函数返回 = pop frame</li></ul></li></ul></li><li><p>应用：将任何递归程序就地转为非递归</p><ul><li><p>汉诺塔-递归：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, from, to);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    hanoi(n - <span class="number">1</span>, from, via, to);</span><br><span class="line">    hanoi(<span class="number">1</span>,     from, to,  via);</span><br><span class="line">    hanoi(n - <span class="number">1</span>, via,  to,  from);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>汉诺塔-非递归：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pc, n;</span><br><span class="line">  <span class="type">char</span> from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret()     (&#123; top--; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;</span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="keyword">goto</span>(<span class="number">4</span>); &#125; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(n - <span class="number">1</span>, from, via, to);   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(    <span class="number">1</span>, from, to,  via);  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(n - <span class="number">1</span>, via,  to,  from); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>递归版本的汉诺塔是程序设计中的经典例题——理解这个程序可能会遇到困难。这种根本性的困难在于，大家可能并没有建立 “函数调用”、“函数返回” 和 “单步执行” 的正确模型。如果我们清楚地认识到所谓<mark style="background: #BBFABBA6;">单步执行，指的是从顶部的栈帧 PC 取一条指令执行</mark>，就不难用栈模拟递归程序。</p></li><li><p>此外，我们也可以用类似汉诺塔的方法把 C 语言改写成仅包含顺序执行的简单语句和条件跳转 <code>if (cond) goto</code> 的 “简化 C 语言代码”——循环、分支和函数调用都被消灭了。这时候，我们的 C 代码已经可以逐条翻译成汇编指令了。这也是为什么 C 语言被称为 “高级的汇编语言”——我们几乎总是能从 C 语言的语法层面对应到机器指令序列。</p></li></ul><h3 id="什么是程序（机器代码语义）">什么是程序（机器代码语义）</h3><ul><li>汇编代码的状态机模型：<ul><li><mark style="background: #BBFABBA6;"><font color="#245bdb">状态 = 内存 M + 寄存器 R</font></mark></li><li>初始状态 = ABI 规定（例如有一个合法的 %rsp）</li><li>状态迁移 = 执行一条指令</li></ul></li></ul><blockquote><p>ABI：每个操作系统都会为运行在该系统下的应用程序提供<font color="#245bdb">应用程序二进制接口</font>（Application Binary Interface，ABI）。ABI 包含了应用程序在这个系统下运行时必须遵守的编程约定。ABI 总是包含一系列的<font color="#245bdb">系统调用</font>和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。<br>%rsp：栈指针，指向栈最底部 (其实是平常所说的栈顶)元素。</p></blockquote><ul><li><p><mark style="background: #BBFABBA6;">操作系统上的程序绝大多数的指令都是单纯的计算</mark>，即从 (M, R)通过计算得到 (M’, R’)，从一个状态迁移到另一个状态。但仅有这些指令甚至都无法使程序停下来。</p></li><li><p><mark style="background: #BBFABBA6;">一条特殊的指令：<font color="#c00000">syscall</font>（操作系统调用）</mark></p><ul><li>把 (M, R) （所有状态）完全交给操作系统，任其修改；</li></ul><ul><li>实现与操作系统中的其他对象交互：<ul><li>读写文件/操作系统状态 (例如把文件内容写入 M)</li><li>改变进程 (运行中状态机) 的状态，例如创建进程/销毁自己</li></ul></li></ul></li><li><p>对操作系统上程序的一个很重要的理解是<mark style="background: #BBFABBA6;">程序是<font color="#245bdb">计算</font>和<font color="#245bdb">系统调用</font>组成的状态机</mark>；</p><ul><li><mark style="background: #BBFABBA6;"><font color="#c00000">程序 = 计算 + syscall</font></mark></li><li>大部分计算指令都是<font color="#245bdb">确定性</font> (deterministic，在相同环境下执行的结果总是相同) 的</li><li>少部分指令 (如 rdrand 返回随机数) 则有<font color="#245bdb">非确定</font>的结果。</li><li>系统调用指令 syscall 是非确定性的，操作系统可能会将计算机运行环境中的信息，例如来自设备的输入传递到程序中。</li></ul></li><li><p>操作系统上的所有程序本质还是计算，不管是编译器、浏览器、图形界面都是如此。比如你需要用绘图软件创作一张图片，绘图软件实际上要去计算一个二维的 rgb 数组，每个 rgb 的值是可以计算出来的。但是如果想把图片显示出来，这件事情进程本身是做不到的，进程就需要在适当的时候请求操作系统，将内存中的图片显示出来，操作系统具体做了什么来完成这个任务对于程序来说并不重要。</p></li></ul><h3 id="构造最小的-Hello-World">构造最小的 Hello World</h3><ul><li><p>为了理解操作系统上的程序，我们的目标是<font color="#c00000">构造一个能直接被操作系统加载且打印 Hello World 的指令序列。</font></p><ul><li><p>在失败的尝试中，我们直接为 main 函数返回 0，并直接将可执行文件的入口地址设置为 main 的第一条指令。函数可以被执行，但从 main 函数返回会导致 <font color="#245bdb">Segmentation Fault</font>。</p></li><li><p>在成功的尝试中，我们<font color="#245bdb">直接编写汇编代码</font>执行<font color="#245bdb">系统调用</font>。</p></li></ul></li></ul><h4 id="编译器">编译器</h4><ul><li><p>用 C 语言编写程序时，编写的内容被储存在文本文件中，即<font color="#245bdb">源代码文件</font>（source code file），文件名一般以. C 结尾。C 语言编程的基本策略是用程序（<font color="#245bdb">编译器</font>）把源代码文件转换为<font color="#245bdb">可执行文件</font>（可以直接运行的机器语言代码），一般通过<font color="#245bdb">编译</font>和<font color="#245bdb">链接</font>两个步骤来完成这项任务。</p></li><li><p>我们有两种状态机：</p><ul><li>高级语言代码 .c<ul><li>状态：栈、全局变量；</li><li>状态迁移：语句执行；</li></ul></li><li>汇编指令序列 .s<ul><li>状态：(M,R)；</li><li>状态迁移：指令执行；</li></ul></li></ul></li><li><p>编译器是二者之间的桥梁：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi>s</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">.s = compile(.c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi>s</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">.s = compile(.c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> 编译优化的正确性判断：.c 执行中的所有外部观测者可见的行为，必须在.s 中保持一致。</p></li><li><p>现代（与未来的）编译优化：在保证观测一致性（sound）的前提下改写代码（rewriting）</p></li></ul><h4 id="C-语言程序的执行流程：">C 语言程序的执行流程：</h4><ol><li>源代码首先发送到<font color="#245bdb">预处理器</font>（processor），预处理器负责将预处理指令转换为各自的值。预处理器生成<font color="#92d050">扩展的源代码</font>（Expanded source code）。</li><li>扩展的源代码发送到<font color="#245bdb">编译器</font>（Complier），编译代码并将其转换为<font color="#92d050">汇编代码</font>（Assembly code）。</li><li>汇编代码被发送到<font color="#245bdb">汇编器</font>（Assembler），将其转换成<font color="#92d050">目标代码</font>（Object Code），目标代码一般由机器代码组成。目标代码缺少<font color="#92d050">启动代码</font>（startup code），启动代码充当着程序和操作系统之间的接口。目标代码还缺少<font color="#92d050">库函数</font>。</li><li>目标代码被发送到<font color="#245bdb">链接器</font>（linker），链接器的作用是将<u>目标代码</u>、<u>系统的标准启动代码</u>和<u>库函数的代码</u>这三部分合并成一个<font color="#92d050">可执行文件</font>。</li><li>可执行代码发送到<font color="#245bdb">加载器</font>（loader），将其加载到内存中，然后执行，并将输出发送到控制台。</li></ol><ul><li>文件扩展名的转换：.c—.I—.s—.o—.exe（Linux 环境下是.out）</li></ul><h4 id="失败的尝试">失败的尝试</h4><ul><li><p>一个简单的 Hello World 程序 hello.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>直接编译运行它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c &amp;&amp; ./a.out <span class="comment">#a.out是“assembler output”（汇编程序输出）的缩写形式</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></li><li><p>gcc 编译出来的文件不满足 “最小”：</p><ul><li><code>$ gcc --verbose hello.c</code><br>打印出编译连接时的详细信息，会看到 gcc 在编译它时用了很多的编译选项，而且编译和链接的过程非常复杂。</li><li><code>-static</code> 选项可以静态链接程序，即不需要再运行时依赖<font color="#245bdb">动态库</font>（dynamic libraries）</li></ul></li><li><p>查看 hello. C 的汇编代码，使用 <code>gcc -c </code> 就可以仅仅编译程序而不链接，objdump 工具可以查看对应的汇编代码。会看到代码非常短：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64</span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        <span class="comment"># f &lt;main+0xf&gt;</span></span><br><span class="line">   f:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;</span><br><span class="line">  17:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  1c:   5d                      pop    %rbp</span><br><span class="line">  1d:   c3                      ret</span><br></pre></td></tr></table></figure></li><li><p>能不能直接链接这段代码呢？试试<u>强行编译+链接</u>：gcc -c + ld</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o &amp;&amp; ld hello.o</span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000</span><br><span class="line">ld: hello.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.c:(.text+0x13): undefined reference to `puts&#x27;</span></span><br></pre></td></tr></table></figure><p>首先报了一个不能找到汇编程序入口<code>_start</code>的 warning，这个警告其实是可以避免的，需要修改hello.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来试一下：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o &amp;&amp; ld hello.o</span><br><span class="line">ld: hello.o: <span class="keyword">in</span> <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.c:(.text+0x13): undefined reference to `puts&#x27;</span></span><br></pre></td></tr></table></figure><p>还是会提示编译器无法找到 <code>puts</code> 的定义。</p><p>强行编译+链接失败了，这是因为 ld 不知道怎么链接库函数。如果把源代码中的 printf ()函数去掉，只留下一个空的函数呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;Hello World\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c &amp;&amp; objdump -d hello.o &amp;&amp; ld hello.o</span><br><span class="line">$ ./a.out</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>可以看到，只有一个空的函数的 hello.c 程序是可以强行编译+链接而不报错的，但要执行它时，会报一个 <code>Segmentation fault</code>，即<font color="#245bdb">存储器段错误</font>，意思是程序企图访问 CPU 无法定址的存储器区块，也称<font color="#245bdb">访问权限冲突</font>。 <code>Segmentation fault</code> 出现的原因实际上因为<font color="#92d050">进程的初始状态是不能返回的</font>。</p></li><li><p>使用 GDB 调试找出错误的原因：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gdb a.out</span><br><span class="line">(gdb) starti<span class="comment"># 开始执行程序，在第一条指令处会停下来</span></span><br><span class="line">Starting program: /home/imp/a.out</span><br><span class="line"></span><br><span class="line">Program stopped.</span><br><span class="line">0x0000000000401000 <span class="keyword">in</span> _start ()</span><br><span class="line">(gdb) layout asm<span class="comment"># 分割窗口，显示汇编窗口</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230417165516545.png" alt="image-20230417165516545"></p><p>问题出在这条 ret 指令。在 CPU 中，寄存器 <font color="#245bdb">rip</font> 保存下一条执行指令的地址，寄存器 <font color="#245bdb">rbp</font> 保存的是栈中当前执行函数的基本地址，而 <font color="#245bdb">rsp</font> 就是所谓的栈指针，它永远指向一个进程的栈顶。假设函数调用链: <code>A()-&gt;B()-&gt;C()</code>, 并且正在执行函数 <code>C()</code>，则 rsp 和 rbp 指向的位置如图：</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230417171751872.png" alt="image-20230417171751872"></p><p>call 指令执行函数调用，ret 指令则用于从被调用函数返回到调用函数。比如，当 C 函数执行完时，此时 rsp 就会指向 <code>C函数执行完返回B的地址</code>。此时 ret 指令执行，它会把 rsp 的值赋值给 rip，然后使 rsp 的值自增。</p></li><li><p>解决异常退出：让状态机停下来的解决方法：<font color="#c00000">syscall</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  syscall(SYS_exit, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="成功的尝试（汇编代码直接执行系统调用）">成功的尝试（汇编代码直接执行系统调用）</h4><ul><li><p>minimal.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   // write(</span><br><span class="line">  movq $1,         %rdi   //   fd=1,</span><br><span class="line">  movq $st,        %rsi   //   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   //   count=ed-st</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   // exit(</span><br><span class="line">  movq $1,         %rdi   //   status=1</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure></li><li><p>编译+链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi minimal.S</span><br><span class="line">imp@xiaoxin:~$ gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">imp@xiaoxin:~$ ./a.out</span><br><span class="line">Hello, OS World<span class="comment"># 这个Hello, OS World实际会是红色的</span></span><br></pre></td></tr></table></figure></li><li><p>回顾：状态机视角的程序</p><p>程序 = 计算 → syscall → 计算 → syscall …</p></li></ul><h3 id="操作系统中的一般程序">操作系统中的一般程序</h3><ul><li>任何程序=minimal.S=调用 syscall 的状态机</li><li><mark style="background: #BBFABBA6;">操作系统收编了<font color="#245bdb">所有的硬件/软件资源</font>，只能用操作系统允许的方式（API）访问操作系统中的<font color="#245bdb">对象</font>（软硬件资源），这是为”管理多个状态机“所必须的。</mark></li><li>可执行文件<ul><li>与大家日常使用的文件没有本质区别</li><li>操作系统提供 API 打开、读取、改写（需要相应的权限）</li></ul></li><li>查看可执行文件：vim，cat，xxd<ul><li><code>vim</code> 中二进制的部分无法 “阅读”，但可以看到字符串常量</li><li>使用 <code>xxd</code> 可以看到文件以 <code>&quot;\x7f&quot; &quot;ELF&quot;</code> 开头</li><li>vscode 有 binary editor 插件</li></ul></li></ul><hr><ul><li>系统中常见的程序（分三个等级）<ul><li><font color="#245bdb">Core Utilities</font> (coreutils)<ul><li><em>Standard</em> programs for text and file manipulation（文本与文件操作标准程序）</li><li>系统中安装的是 <a href="https://www.gnu.org/software/coreutils/">GNU Coreutils</a>，有较小的替代品 <a href="https://www.busybox.net/">busybox</a></li></ul></li><li><font color="#245bdb">系统/工具程序</font><ul><li>ash, <a href="https://www.gnu.org/software/binutils/">binutils</a>, apt, ip, ssh, vim, tmux, jdk, python</li></ul></li><li><font color="#245bdb">其他各种应用程序</font><ul><li>浏览器、音乐播放器等</li></ul></li></ul></li></ul><hr><h3 id="strace（追踪）"><a href="https://strace.io/">strace</a>（追踪）</h3><ul><li><p><strong><a href="http://man7.org/linux/man-pages/man1/strace.1.html">strace</a></strong> is a diagnostic, debugging and instructional user space utility for Linux. It is used to monitor and tamper with interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state.</p></li><li><p>strace 是一个非常重要的命令行工具，帮助我们 “观测” 应用程序和操作系统的边界。实际上，任何程序的执行就是状态机在计算机上的运行，因此 “用合适的方式观测状态机执行” 就是我们理解程序的根本方法。</p></li><li><p>一个小 Demo：</p><ul><li><p>hello.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br></pre></td></tr></table></figure></li><li><p>利用 strace 查看可执行文件a.out 执行后的系统调用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./a.out</span><br><span class="line">execve(<span class="string">&quot;./a.out&quot;</span>, [<span class="string">&quot;./a.out&quot;</span>], 0x7ffeefaeeb50 /* 27 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x557621d70000</span><br><span class="line">arch_prctl(0x3001 /* ARCH_??? */, 0x7ffded6d0ff0) = -1 EINVAL (Invalid argument)mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3c998a7000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">newfstatat(3, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=16915, ...&#125;, AT_EMPTY_PATH) = 0mmap(NULL, 16915, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f3c998a2000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line"><span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\237\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">pread64(3, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., 784, 64) = 784</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0 \0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&quot;</span>..., 48, 848) = 48</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0i8\235HZ\227\223\333\350s\360\352,\223\340.&quot;</span>..., 68, 896) = 68</span><br><span class="line">newfstatat(3, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=2216304, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">pread64(3, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., 784, 64) = 784</span><br><span class="line">mmap(NULL, 2260560, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f3c9967a000mmap(0x7f3c996a2000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7f3c996a2000</span><br><span class="line">mmap(0x7f3c99837000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7f3c99837000</span><br><span class="line">mmap(0x7f3c9988f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x214000) = 0x7f3c9988f000</span><br><span class="line">mmap(0x7f3c99895000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f3c99895000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3c99677000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7f3c99677740) = 0</span><br><span class="line">set_tid_address(0x7f3c99677a10)         = 857</span><br><span class="line">set_robust_list(0x7f3c99677a20, 24)     = 0</span><br><span class="line">rseq(0x7f3c996780e0, 0x20, 0, 0x53053053) = 0</span><br><span class="line">mprotect(0x7f3c9988f000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x557620169000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x7f3c998e1000, 8192, PROT_READ) = 0</span><br><span class="line">prlimit64(0, RLIMIT_STACK, NULL, &#123;rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY&#125;) = 0</span><br><span class="line">munmap(0x7f3c998a2000, 16915)           = 0</span><br><span class="line">newfstatat(1, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">getrandom(<span class="string">&quot;\x96\x5b\x8b\xcd\xd4\x7d\xdb\x18&quot;</span>, 8, GRND_NONBLOCK) = 8</span><br><span class="line">brk(NULL)                               = 0x557621d70000</span><br><span class="line">brk(0x557621d91000)                     = 0x557621d91000</span><br><span class="line">write(1, <span class="string">&quot;hello world\n&quot;</span>, 12hello world</span><br><span class="line">)           = 12</span><br><span class="line">exit_group(12)                          = ?</span><br><span class="line">+++ exited with 12 +++</span><br></pre></td></tr></table></figure></li><li><p>本质上，所有的程序和 Hello World 类似：程序 = 计算 → syscall → 计算 → syscall …</p><ol><li>被系统加载：通过另一个进程执行 execve 设置为初始状态（可以看上面 strace 后的第一个系统调用就是 execve）</li><li>状态机执行<ul><li>进程管理：fork, execve, exit, …</li><li>文件/设备管理：open, close, read, write, …</li><li>存储管理：mmap, brk, …</li></ul></li><li>直到 _exit (exit_group) 退出</li></ol></li><li><p>所有的程序，包括浏览器、游戏、杀毒软件、病毒等等，都是在调用这些操作系统提供的 API。</p></li></ul></li></ul><hr><p>动手实验：观察程序的执行</p><ul><li><p>工具程序代表：编译器 (gcc)</p><ul><li><p>主要的系统调用：execve, read, write</p></li><li><pre><code class="language-sh">  $ strace -f gcc a.c  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      (gcc 会启动其他进程)</span><br><span class="line"></span><br><span class="line">        - 可以管道给编辑器 `vim -`</span><br><span class="line">        - 编辑器里还可以 `%!grep` (细节/技巧)</span><br><span class="line"></span><br><span class="line">* 图形界面程序代表：编辑器 (xedit)</span><br><span class="line"></span><br><span class="line">    - 主要的系统调用：poll, recvmsg, writev</span><br><span class="line"></span><br><span class="line">    - ```sh</span><br><span class="line">$ strace xedit</span><br></pre></td></tr></table></figure>  - 图形界面程序和 X-Window 服务器按照 X11 协议通信  - 虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Hos</code></pre></li></ul></li></ul><hr><p>各式各样的应用程序都在操作系统 API (syscall) 和操作系统中的对象上构建:</p><ul><li><p>窗口管理器</p><ul><li>管理设备和屏幕 (read/write/mmap)</li><li>进程间通信 (send, recv)</li></ul></li><li><p>任务管理器</p><ul><li>访问操作系统提供的进程对象 (readdir/read)</li><li>参考 gdb 里的 <code>info proc *</code></li></ul></li><li><p>杀毒软件</p><ul><li>文件静态扫描 (read)</li><li>主动防御 (ptrace)</li><li>其他更复杂的安全机制……</li></ul></li></ul><h2 id="总结">总结</h2><p>本次课回答的问题：到底什么是 “程序”？</p><hr><p>Take-away message</p><ul><li>程序 = 状态机<ul><li>源代码 <em>S</em>: 状态迁移 = 执行语句</li><li>二进制代码 <em>C</em>: 状态迁移 = 执行指令</li><li>编译器 C*=compile(*S)</li></ul></li><li>应用视角的操作系统<ul><li>就是一条 syscall 指令</li></ul></li><li>计算机系统不存在玄学；一切都建立在确定的机制上<ul><li>理解操作系统的重要工具：gcc, binutils, gdb, strace</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统导论OSTEP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-6 图</title>
      <link href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/"/>
      <url>/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E2%80%94%E2%80%94%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="图的存储结构">图的存储结构</h1><h2 id="图的顺序存储结构——邻接矩阵">图的顺序存储结构——邻接矩阵</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> no;<span class="comment">//顶点编号，表示它的位置</span></span><br><span class="line"><span class="type">char</span> info;<span class="comment">//顶点的其他辅助信息，没有的话可以删除</span></span><br><span class="line">&#125;VertexType; <span class="comment">//顶点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> edges[maxSize][maxSize];<span class="comment">//顶点之间的相邻关系（无权值：1表示相通，0表示不相通）（有权值：∞表示不相通，其它为权值）</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//总顶点数和总边数</span></span><br><span class="line">VertexType vex[maxSize];<span class="comment">//存放图中的所有顶点</span></span><br><span class="line">&#125;MGraph;<span class="comment">//图</span></span><br></pre></td></tr></table></figure><h2 id="图的链式存储结构——邻接链表">图的链式存储结构——邻接链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边——结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指顶点的位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextArc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line"><span class="type">int</span> info;<span class="comment">//边的补充信息，如权值，没有则省略</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点——结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line"><span class="type">char</span> data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *firstArc;<span class="comment">//指向第一条依附于该顶点边的指针</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接表存储类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AGraph</span> &#123;</span><br><span class="line">VNode adjlist[maxSize];<span class="comment">//邻接表，由顶点表结点组成的数组</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;AGraph;</span><br></pre></td></tr></table></figure><h1 id="图的遍历">图的遍历</h1><h2 id="深度优先搜索遍历">深度优先搜索遍历</h2><p>类似于二叉树的先序遍历。算法执行过程：<strong>访问任一顶点，然后从该顶点出发，递归访问该顶点的所有未被访问的邻接顶点</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[maxSize]; <span class="comment">//全局数组，作为顶点的访问标记，取0表示该位置的顶点未被访问，取1表示该位置的顶点未被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(AGraph *g)</span> </span>&#123;<span class="comment">//深度优先搜索遍历图g</span></span><br><span class="line">    <span class="comment">//初始化标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)&#123;</span><br><span class="line">        visited[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从0顶点开始遍历（连通图只需要从任一顶点出发就能完成遍历，非连通图需要依次从多个顶点出发才能完成遍历，这里假设为非连通图）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[v] == <span class="number">0</span>)<span class="comment">//对每个连通分量调用一次DFS</span></span><br><span class="line"><span class="built_in">DFS</span>(g, v);<span class="comment">//v位置的顶点未被访问过，访问之</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span> </span>&#123;<span class="comment">//从顶点v出发，深度优先遍历G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问顶点v</span></span><br><span class="line">visited[v] = <span class="number">1</span>;<span class="comment">//更改全局数组，表示v已经被访问过</span></span><br><span class="line">    <span class="comment">//递归访问v的所有未被访问过的邻接顶点</span></span><br><span class="line">ArcNode *p = G-&gt;adjlist[v].firstArc;<span class="comment">//p指向顶点v的第一条边</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">DFS</span>(G, p-&gt;adjvex);<span class="comment">//边p另一端的顶点，即v的邻接顶点没被访问过，递归访问之</span></span><br><span class="line">p = p-&gt;nextArc;<span class="comment">//挪动p指向v的下一条边，循环访问v的其他邻接顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深度优先搜索生成树：对<strong>连通图</strong>的深度优先搜索遍历过程中所经历的边保留，其余的边删掉，就会形成一棵树，称为~。</li><li>图的深度优先搜索遍历类似于二叉树的先序遍历。区别在于二叉树的先序遍历对于每个结点要递归地访问两个分支，而图的深度优先搜索遍历则是递归地访问多个分支。</li><li>DFS的空间复杂度：O(n)，n为顶点个数。</li><li>DFS的时间复杂度：<ol><li>图以邻接矩阵表示：查找每个顶点的邻接点所需要的时间为O(n)，有n个顶点，故总的时间复杂度为<strong>O(n^2^</strong>)</li><li>图以邻接表表示：查找所有顶点的邻接点所需要的是时间为O(e)，访问所有顶点为O(n)，故总的时间复杂度为<strong>O(n+e)</strong></li></ol></li></ul><h2 id="广度优先搜索遍历">广度优先搜索遍历</h2><p>类似于二叉树的层次遍历。访问v的所有邻接顶点，再访问v的所有邻接顶点的邻接顶点…以此类推，直到图中所有顶点都被访问。</p><p>广度优先搜索需要借助一个队列：</p><ol><li>任取图中一个结点访问，入队，并标记其已经被访问过</li><li>队列非空时循环执行：出队，依次检查出队结点的所有邻接顶点，如果没被访问过，访问之，然后入队；</li><li>队列非空时跳出循环，结束遍历。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[maxSize]; <span class="comment">//全局数组，作为顶点的访问标记，取0表示该位置的顶点未被访问，取1表示该位置的顶点未被访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对图g进行广度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(AGraph *g)</span> </span>&#123;<span class="comment">//广度优先搜索遍历图g</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++) &#123;</span><br><span class="line">visited[v] = <span class="number">0</span>;<span class="comment">//初始化标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)<span class="comment">//从v=0开始遍历</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[v] == <span class="number">0</span>)<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line"><span class="built_in">BFS</span>(g, v);<span class="comment">//v位置的顶点未被访问过，访问之</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS函数，访问v的所有邻接顶点，再访问v的所有邻接顶点的邻接顶点......</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> que[maxSize], front = <span class="number">0</span>, rear = <span class="number">0</span>;<span class="comment">//定义循环队列作为辅助工具</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问顶点v</span></span><br><span class="line">visited[v] = <span class="number">1</span>;<span class="comment">//更改访问标记</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;<span class="comment">//顶点v入队</span></span><br><span class="line">que[rear] = v;</span><br><span class="line"><span class="type">int</span> j;<span class="comment">//两个临时变量，j用来接收出队顶点，p用来接收出队顶点j的第一条边</span></span><br><span class="line">ArcNode *p;</span><br><span class="line"><span class="comment">//队列非空时执行，完成对v的所有邻接顶点的访问后，再访问v的所有邻接顶点的邻接顶点......</span></span><br><span class="line"><span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line"><span class="comment">//队列非空，出队</span></span><br><span class="line">front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">j = que[front];<span class="comment">//出队顶点</span></span><br><span class="line">p = G-&gt;adjlist[j].firstArc;<span class="comment">//出队顶点的第一条边</span></span><br><span class="line"><span class="comment">//遍历出队顶点j的所有邻接顶点，未被访问过就访问之，并入队</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//如果j的邻接顶点p-&gt;adjvex未被访问过，访问并入队</span></span><br><span class="line"><span class="keyword">if</span> (visited[p-&gt;adjvex] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">visit</span>(p-&gt;adjvex);</span><br><span class="line">visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">que[rear] = p-&gt;adjvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新p指向j的下一条边，检查j的下一个邻接顶点</span></span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//p的所有邻接顶点访问完之后，队列中存有p的所有邻接顶点，再去访问访问它们的邻接顶点，直到队空退出外层循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BFS的时间复杂度：</li></ul><ol><li>图以邻接矩阵表示：查找每个顶点的邻接点所需要的时间为O(n)，有n个顶点，故总的时间复杂度为<strong>O(n^2^</strong>)</li><li>图以邻接表表示：查找所有顶点的邻接点所需要的是时间为O(e)，访问所有顶点为O(n)，故总的时间复杂度为<strong>O(n+e)</strong></li></ol><h2 id="判断无向图G是否是一棵树">判断无向图G是否是一棵树</h2><p>一个无向图是一棵树的条件是有<strong>n-1条边</strong>的<strong>连通</strong>图（n为图中顶点的个数）。</p><p>判读无向图g是否是一棵树需要满足两个条件：</p><ol><li>无向图g是一个连通图；</li><li>无向图有n-1条边，其中n是顶点数；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断无向图是否是一棵树</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">G_isTree</span><span class="params">(AGraph *g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)&#123;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> vn = <span class="number">0</span>, en = <span class="number">0</span>;<span class="comment">//新增两个计数器：vn——已访问顶点数，en——已访问边数</span></span><br><span class="line"><span class="built_in">DFS_isTree</span>(g, <span class="number">0</span>, vn, en);<span class="comment">//从0顶点出发，DFS图g</span></span><br><span class="line"><span class="comment">//判读无向图g是否是一棵树需要满足两个条件：</span></span><br><span class="line"><span class="comment">//1.无向图g是一个连通图：通过一次DFS返回的顶点数是否和g的顶点数相等</span></span><br><span class="line"><span class="comment">//2.无向图有n-1条边，n是顶点数：深度遍历过程中，每条边都会访问2次，所以需要除以2和n-1比较</span></span><br><span class="line"><span class="keyword">if</span> (vn == g-&gt;vexnum &amp;&amp; en / <span class="number">2</span> == (g-&gt;vexnum - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改DFS算法，新增两个计数器：vn——已访问顶点数，en——已访问边数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_isTree</span><span class="params">(AGraph *G, <span class="type">int</span> v, <span class="type">int</span> &amp;vn, <span class="type">int</span> &amp;en)</span> </span>&#123;</span><br><span class="line">vn++;<span class="comment">//访问操作改为：已访问顶点数+1</span></span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line">ArcNode *p = G-&gt;adjlist[v].firstArc;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">en++;<span class="comment">//已访问边数+1</span></span><br><span class="line"><span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">DFS_isTree</span>(G, p-&gt;adjvex, vn, en);</span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顶点i到顶点j是否连通">判断顶点i到顶点j是否连通</h2><p>方法：从顶点i出发遍历图，如果遇到j则说明连通，否则不连通。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断顶点i到顶点j是否连通</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFSTrave</span><span class="params">(AGraph *g, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vexnum; v++)</span><br><span class="line">&#123;</span><br><span class="line">visited[v] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DFS</span>(g, i);</span><br><span class="line">    <span class="comment">//visited[j]等于1，说明被访问过了</span></span><br><span class="line"><span class="keyword">if</span> (visited[j] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图的应用">图的应用</h1><h2 id="最小生成树">最小生成树</h2><ul><li>生成树：一个连通图的最小生成树包含图中的所有顶点，并且只含尽可能少的边。</li><li>砍去生成树的一条边，生成树就会变成非连通图；增加一条边，它就会形成一个回路。</li><li>最小生成树：带权连通无向图中权值之和最小的生成树。</li><li><strong>最小生成树不是唯一的，但不同最小生成树的边权值之和是一样的，而且是最小的</strong>。当图中各边的权值不相等时，最小生成树唯一。</li><li>图的边数比它的顶点数少1，即图本身就是一棵树时，它的最小生成树是它自己。</li><li>最小生成树的边数=顶点数-1。</li></ul><h3 id="普里姆（Prim）算法">普里姆（Prim）算法</h3><p>基本思想：从图中任取一个顶点，把它当做一棵树，然后从与<strong>这棵树相接</strong>的边中选取一条最短（权值最小）的边，将这条边与其连接的顶点一并加入到树中，重复这个过程，直到图中所有顶点都被并入树中，此时得到的数就是最小生成树。</p><p>普里姆算法需要用到两个辅助数组：</p><ol><li>vset[]数组，vset[i]=1表示顶点i已经加入到树中，vset[i]=0说明顶点i还未加入到树中（类似于上面的visited[]，标记数组）。</li><li>lowcost[]数组，存放当前生成树到其余顶点最短边的权值。比如lowcost[j]=4就表示当前生成树到j顶点的最短边的权值是4。</li></ol><p>要注意，lowcost[]数组中存放的当前生成树到其余顶点的最小权值，而非树中结点到顶点的权值。而且，树到其余顶点的边可能有很多条，此时应该选最短的那一条边，记录它的权值。</p><p>从树中任一顶点v0开始，构成最小生成树的算法执行过程：</p><ol><li><p>v0作为树根结点，然后从v0到其他顶点的所有边都作为候选边</p></li><li><p>重复执行以下步骤n-1次，使得其他n-1个顶点被并入到树中：</p><p>(1)从候选边中挑出权值最小的边 ，将与之相连的另一个顶点v并入到树中；</p><p>(2)更新lowcost数组，以新加入的顶点v为出发点，如果其余顶点vi使得(v0，vi)的权值比lowcost[vi]小，就用(v0，vi)的权值覆盖lowcost[vi]。</p></li></ol><p>这里采用的图的存储结构是顺序存储结构——邻接矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100 <span class="comment">//INF是一个已经定义的比图中所有边权值都大的常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普里姆算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph g, <span class="type">int</span> v0, <span class="type">int</span> &amp;sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> min, v;<span class="comment">//min：记录每次新增顶点后的权值增量；v：树新增顶点</span></span><br><span class="line"><span class="type">int</span> lowcost[maxSize], vset[maxSize];</span><br><span class="line">    <span class="comment">//遍历图中顶点，给lowcost[], vset[]赋初始值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">lowcost[i] = g.edges[v0][i];<span class="comment">//开始时，v0自己是一棵树，lowcost数组里放v0到其他边的权值</span></span><br><span class="line">vset[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vset[v0] = <span class="number">1</span>;<span class="comment">//修改v0的标记值，表示v0已经加入到树中</span></span><br><span class="line">sum = <span class="number">0</span>;<span class="comment">//sum用来保存当前生成树的总权值</span></span><br><span class="line"><span class="comment">//循环g.vexnum-1次,将除了v0以外的其他顶点加入到树中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">min = INF;<span class="comment">//INF为已知的比图中所有边的权值都大的常量</span></span><br><span class="line"><span class="comment">//1.选出当前生成树到其余顶点的边中权值最小的那一条</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++)</span><br><span class="line">&#123;<span class="comment">//vest[j]等于0说明未加入树中，lowcost[j]小于min说明树到顶点j的边权值可能是最小的</span></span><br><span class="line"><span class="keyword">if</span> (vset[j] == <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) </span><br><span class="line">&#123;</span><br><span class="line">min = lowcost[j];<span class="comment">//不停地刷新min值，遍历结束，min记录选出的边的权值</span></span><br><span class="line">v = j;<span class="comment">//v记录顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vset[v] = <span class="number">1</span>;<span class="comment">//选出的顶点加入树</span></span><br><span class="line">sum += min;<span class="comment">//刷新当前生成树的总权值</span></span><br><span class="line"><span class="comment">//2.每次加入一个新顶点，树到其他顶点的权值信息会发生变化，所以要刷新lowcost[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum; k++)</span><br><span class="line">&#123;<span class="comment">//从新加入顶点v出发，如果到剩余某个顶点k的权值比lowcost[]中记录的值小，则用其值覆盖lowcost[]</span></span><br><span class="line"><span class="keyword">if</span> (vset[k] == <span class="number">0</span> &amp;&amp; g.edges[v][k] &lt; lowcost[k]) </span><br><span class="line">&#123;</span><br><span class="line">lowcost[k] = g.edges[v][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//完成一个树结点的添加，继续添加下一个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Prim算法不依赖边，它的时间复杂度为<strong>O(n^2^)</strong>。</li><li>因为不依赖边，Prim算法适用于求解<strong>边稠密的图</strong>的最小生成树。</li></ul><h3 id="克鲁斯卡尔（Kruskal）算法">克鲁斯卡尔（Kruskal）算法</h3><p>基本思想：每次找出侯选边中权值最小的边，将其加入到树中。重复这个过程直到所有边都被检测完。</p><p>是否为侯选边：看这条边的并入是否会构成回路作为标准。构成回路就说明这条边两边的顶点都是树中结点。</p><p>算法执行过程：</p><ol><li><p>将图中所有的边按照权值从小到大排序；</p></li><li><p>从权值最小边开始扫描各边，若该边为侯选边，则将其加入到树中，直到所有的树都被检测完。</p></li></ol><p>为了判断侯选边的加入是否会构成回路，我们需要借助并查集。并查集类似于树的双亲存储结构，我们定义一个一维数组，用下标表示顶点的编号，用下标对应的数组值表示它的父结点。这种结构有两个好处：</p><ol><li>可以快速的将两棵树合并为一棵树，只需要找到其中树A的根结点a，a作为树B的任一结点的孩子结点即可。即只需要修改A[a]的值。</li><li>可以很方便的判断两个结点是否属于用一棵树，只需要知道它们各自的根结点，看是否相等即可。</li></ol><p>我们把图的所有顶点放入到并查集中，在算法开始之前，将他们看做一棵棵单独的树，算法执行的过程中，不断地合并两棵树即可。</p><p>我们规定，在并查集V[]中，如果i是某棵树根结点，那么A[i]=i，即根结点的双亲结点是它自己。</p><p>那么将图g中所有顶点存到并查集v中并初始化的代码应该这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)&#123;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，与普里姆算法中针对顶点操作不同，克鲁斯卡尔算法中要不断地针对“边&quot;进行操作，所以我们需要定义新的数据结构来保存和边有关的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Road结构保存了边，权值和它的两个结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> a, b;<span class="comment">//边的两个顶点</span></span><br><span class="line"><span class="type">int</span> w;<span class="comment">//边的权值</span></span><br><span class="line">&#125;Road;</span><br></pre></td></tr></table></figure><p>克鲁斯卡尔算法，假设road[]数组中已经存放了图中所有边，且排序函数sort()已经存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Road road[maxSize];<span class="comment">//定义road[]存放图中所有的边信息</span></span><br><span class="line"><span class="type">int</span> v[maxSize];<span class="comment">//定义并查集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">(MGraph g, <span class="type">int</span> &amp;sum, Road road[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//所有顶点加入并查集并单独作为一棵树，并查集初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)&#123;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//对road数组中所有边信息按照权值从小到大排序，这里没有具体实现sort函数</span></span><br><span class="line"><span class="built_in">sort</span>(road, g.arcnum);</span><br><span class="line">   <span class="comment">//从权值最小边开始扫描各边，若该边为侯选边，则将其加入到树中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.arcnum; j++)</span><br><span class="line">&#123;</span><br><span class="line">a = <span class="built_in">getRoot</span>(road[j].a);<span class="comment">//得到边j的其中一个顶点a在并查集结构中的根结点</span></span><br><span class="line">b = <span class="built_in">getRoot</span>(road[j].b);<span class="comment">//得到边j的其中一个顶点b在并查集结构中的根结点</span></span><br><span class="line">        <span class="comment">//a!=b说明边road[j]的两个顶点属于不同的两棵树，则合并这两棵树，将a作为b的子树</span></span><br><span class="line"><span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">v[a] = b;</span><br><span class="line">sum += road[j].w;<span class="comment">//更新总权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getRoot()方法放回并查集v中的根结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRoot</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (n!=v[n]) <span class="comment">//n不是根结点</span></span><br><span class="line">&#123;</span><br><span class="line">n = v[n];<span class="comment">//从n出发，沿着它的父结点往上找根结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Road存储结构示意图：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/1cfd6803d3d94c328ef8de83f4de5bea.png" alt="在这里插入图片描述"></p></li><li><p>下图右半部分为算法执行之后的并查集结构以及最小生成树的的结构示意图：</p></li></ul><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/b0d891c8dff84c98b17fcb6bd5f810d3.png" alt="在这里插入图片描述"></p><p>Kruskal算法时间花费在排序函数sort()和单层循环中，循环是线性级的，可以认为算法时间主要花费在排序函数中，根据所选排序函数不同，算法的时间复杂度不同。由于排序函数是以图的边数为问题规模的，与顶点数无关，可见Kruskal算法适合于<strong>稀疏图</strong>。</p><ul><li>Prim算法和Kruskal算法都是针对无向图的。</li><li>Prim算法适用于稠密图，而Kruskal适用于稀疏图。</li></ul><h2 id="最短路径">最短路径</h2><ul><li>最短路径：当图是带权图时，把一个顶点v~0~到图中任意一个顶点v~i~的一条路径（非唯一）所经过的边上的权值之和，定义为该路径的带权路径长度，代全路径长度最短的路径就是最短路径。</li></ul><h3 id="迪杰斯特拉（Dijkstra）算法">迪杰斯特拉（Dijkstra）算法</h3><p>迪杰斯特拉（Dijkstra）算法主要用来<strong>求图中任意顶点v~0~到其余各顶点的最短路径</strong>。</p><p>其基本思想是：每次加入的新顶点v~j~，保证v~0~从现有路径到v~j~的路径长度是v~0~到其他剩余顶点中最短的。每次加入新顶点后，重新计算v~0~到剩余顶点的最短路径值。</p><p>需要用到3个辅助数组：</p><ol><li>dist[ vi]表示当前已找到的从v~0~到每个终点 V~i~的最短路径的长度。它的初态为：若从v~0~到 V~i~有边，则dist[vi]为边上的权值，否则置 dist[vi]为∞（算法里为INF，一个比图中任意边权值都大的常数）。</li><li>path[vi]中保存从 v~0~到 V~i~最短路径上 V~i~的前一 个顶点。path[]的初态为：如果 v~0~到 v~i~有边，则 path[vi]=v~0~，否则 path[vi]=-1。</li><li>set[]为标记数组，set[vi]=0表示v~i~还没有被并入最短路径；set[vi]=1表示 v~i~已经被并入最短路径。set[]初态为：set[v0]=1, 其余元素全为0。</li></ol><p>迪杰斯特拉算法执行过程如下：</p><ol><li><p>从当前dist[]数组中选出最小值加入路径，假设为dist[vu]，则需要设置set[vu]=1。</p></li><li><p>新顶点的加入可能会使得从v0到vk的路径长度变得更短，所以可能需要更新dist[k]以及path[k]。循环扫描图中顶点，对每个顶点进行以下检测：</p><p>如果set[vk]=1，说明v~k~已经加入路径，则什么都不用做；</p><p>如果set[vk]=0，说明v~k~还没有加入路径，则比较旧路径v0-vk的长度<code>dist[k]</code>和新路径v0-vu-vk的长度<code>dist[u] + g.edges[u][k]</code>的大小，看是否新路径的长度更短，即是否满足<code>dist[u] + g.edges[u][k] &lt; dist[k]</code>。如果满足，则说明vu的加入使得v0到vk的路径长度更短，所以更新dist[k]为新路径的长度，同时更新path[k]=u。</p></li><li><p>每加入一个新顶点，更新一次dist[k]以及path[k]。重复1,2步骤n-1次，完成从v0到其余各顶点的最短路径。路径保存在path[]数组中，且最短路径长度值保存在dist[]数组中。</p></li></ol><ul><li><p>辅助数组的初始值举例，v~0~为顶点0，dist[]，path[]，set[]三个辅助数组的初始值如下：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/a7268b0c4a8e4e4f973b5a0504fcd585.png" alt="在这里插入图片描述"></p></li><li><p>对上图的算法的执行过程模拟：</p></li></ul><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/c400a9f17f904ca58ce6b090d218591c.png" alt="在这里插入图片描述"></p><ul><li>迪杰斯特拉算法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迪杰斯特拉算法,求v0到其余各顶点的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Dijkstra</span><span class="params">(MGraph g, <span class="type">int</span> v0, <span class="type">int</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> set[maxSize];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="type">int</span> min, u;<span class="comment">//两个辅助变量</span></span><br><span class="line"><span class="comment">//初始化dist[]，path[]，set[]三个辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; g.vexnum;i++) &#123;<span class="comment">//辅助数组赋初始值</span></span><br><span class="line">dist[i] = g.edges[v0][i];<span class="comment">//顶点i与v0单边相连，则dist[i]为边的权值，不相连为INF;</span></span><br><span class="line">set[i] = <span class="number">0</span>;<span class="comment">//所有顶点的标记值初始化为0，表示未加入路径</span></span><br><span class="line"><span class="comment">//path[a]=b表示在路径中，顶点a前一个顶点是b</span></span><br><span class="line"><span class="keyword">if</span> (g.edges[v0][i] &lt; INF) &#123;<span class="comment">//如果vi与v0相连，则path[vi]=v0</span></span><br><span class="line">path[i] = v0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//如果vi与v0不相连，则path[vi]=-1</span></span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set[v0] = <span class="number">1</span>;<span class="comment">//v0加入路径</span></span><br><span class="line">path[v0] = <span class="number">-1</span>;<span class="comment">//v0是路径的起点，规定path[v0]为-1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化结束，算法开始</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum<span class="number">-1</span>; i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//1.在剩余顶点中，从dist[]中选出最小值，表示通过已有路径走到这个顶点的路径是最短的</span></span><br><span class="line">        min = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.vexnum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (set[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">u = j;</span><br><span class="line">min = dist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set[u] = <span class="number">1</span>;<span class="comment">//新加入顶点为Vu</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.如果新顶点的加入使得从v0到vk的路径长度变得更短，则更新dist[k]以及path[k]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g.vexnum; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (set[k] == <span class="number">0</span> &amp;&amp; dist[u] + g.edges[u][k] &lt; dist[k]) &#123;</span><br><span class="line">dist[k] = dist[u] + g.edges[u][k];</span><br><span class="line">path[k] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法结束后，最短路径保存在path[]数组中，且最短路径长度值保存在dist[]数组中。path[]数组如下：</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/f5c9ec1f419a4cf18256912b1c820fb2.png" alt="在这里插入图片描述"></p><p>path[] 数组中其实保存了一棵树，这是一棵用<strong>双亲存储结构存储的树</strong>，通过这棵树可以打印出从源点到任何一个顶点最短路径上所经过的所有顶点。树的双亲表示法只能直接输出由叶子结点到根结点路径上的结点，而不能逆向输出，因此需要借助一个栈来实现逆向输出。</p><ul><li>打印路径函数如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a是目标顶点，输出从v0到a的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> path[], <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> stack[maxSize], top = <span class="number">-1</span>;<span class="comment">//初始化栈</span></span><br><span class="line"><span class="keyword">while</span> (path[a] != <span class="number">-1</span>) &#123;<span class="comment">//从a往上到根结点依次入栈</span></span><br><span class="line">stack[++top] = a;</span><br><span class="line">a = path[a];</span><br><span class="line">&#125;</span><br><span class="line">stack[++top] = a;<span class="comment">//根结点入栈</span></span><br><span class="line"><span class="keyword">while</span> (top != <span class="number">-1</span>) &#123;</span><br><span class="line">cout &lt;&lt; stack[top--] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法的时间复杂度：O(n^2^)</li><li>当图中含有负权值时，迪杰斯特拉算法并不适用。</li></ul><h3 id="弗洛伊德（Floyd）算法">弗洛伊德（Floyd）算法</h3><p>弗洛伊德（Floyd）算法主要用来<strong>求图中任意一对顶点v~i~和v~j~的最短路径</strong>。</p><ol><li>基本思想</li></ol><p>弗洛伊德算法的基本思想是递推n阶方阵，该算法需要用到两个矩阵：A和Path</p><ul><li>矩阵A表示任意两顶点之间的路径长度。比如A~k~[i][j]就表示顶点i到j的路径长度，而k表示以k顶点作为中间顶点的运算步骤。</li><li>矩阵Path表示用来记录当前两顶点最短路径上要经过的中间顶点。</li></ul><p>逐步尝试在原路径中加入顶点k（k=0,1,2,3…n-1）作为中间顶点，若增加中间顶点后，得到的路径比原来的路径长度减少了，则用新路径代替原路径，直到所有顶点加入路径。</p><ol start="2"><li>举例</li></ol><p>对于下图最右边的图来说，写出它的邻接矩阵，得到初始矩阵A~-1~，同时矩阵Path~-1~中元素的初始值为-1，表示没有任意顶点对的路径之间都没有中间顶点：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/56118477af19437f808ee84301363a72.png" alt="在这里插入图片描述"></p><p>对于每次新加入的顶点k，对于任⼀顶点对 (i, j)，<strong>i ≠ j，k ≠ i，v ≠ j</strong>，如果A[i][j] &gt; A[i][k] + A[k][j]，则将 A[i][j] 更新为 A[i][k] + A[k][j] 的值，并且将 Path[i][j] 改为k。</p><ul><li>加入顶点0（k=0），矩阵A和Path不变：</li></ul><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/25b8ca4b73734ad295cb0466b0dee631.png" alt="在这里插入图片描述"></p><ul><li>加入顶点1（k=1），检查所有顶点对（因为i ≠ j，k ≠ i，v ≠ j，实际上不用检查所有顶点对。首先，<strong>主对角线</strong>上的顶点对始终都是0，不需要更新，其次，<strong>第k行</strong>以及<strong>第k列</strong>上的顶点对都不需要检查），所以需要检查的顶点对就是0-2,0-3,2-0,2-1,2-3,3-0,3-1,3-2，发现A[0][2]&gt;A[0][1]+A[1][2]=5+4=9，则将A[0][2]修改为9，同时将Path[0][2]改为1，表示此时0到2中的中间路径是1：</li></ul><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/76c2f55e29d746a1a5a1b4b97da653ee.png" alt="在这里插入图片描述"></p><ul><li><p>加入顶点2（k=2），需要检查的顶点对为0-1,0-3,1-0,1-1,1-3，3-0,3-1,3-3。按照上面的方法，得到A~2~和Path~2~：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/5c020c46fa864fb7bd187aee1ce8cc30.png" alt="在这里插入图片描述"></p></li><li><p>加入顶点3（k=3），得到A~3~和Path~3~：</p></li></ul><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/bc6ad06ce82d48aa93754c4d00b63699.png" alt="在这里插入图片描述"></p><p>至此，所有的顶点都已经加入到路径中，所以A~3~和Path~3~就是最终的矩阵。</p><ul><li><p>通过A矩阵可以找到图中任意两个结点之间的最短路径长度，比如A[1][3]为2，就表示顶点1到顶点3的最短路径长度为2。</p></li><li><p>通过Path矩阵可以写出任意两个结点的最短路径。比如从1到0，Path[1][0]为3，就表示3是中间顶点：</p></li></ul><ol><li>先写出1到3的路径，发现Path[1][3]为-1，表示顶点1到顶点3之间没有中间顶点，则1-&gt;3</li><li>再写3到0的路径，发现Path[3][0]为2，表示顶点3到顶点0之间有中间顶点2</li><li>写3到2的路径，发现Path[3][2]为-1，则3-&gt;2</li><li>再写2到0的路径，发现Path[2][0]=-1，则2-&gt;0</li></ol><p>由此可以得到顶点1到顶点0的最短路径就是1-3-2-0。可以发现这是一个递归的过程，用代码表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> path[][maxSize], <span class="type">int</span> A[][maxSize])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A[i][j] &lt; INF) &#123;</span><br><span class="line"><span class="keyword">if</span> (path[i][j] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//直接输出边&lt;i,j&gt;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = path[i][j];<span class="comment">//中间顶点</span></span><br><span class="line"><span class="built_in">printPath</span>(i, mid, path, A); <span class="comment">//前半段路径</span></span><br><span class="line"><span class="built_in">printPath</span>(mid, j, path, A);<span class="comment">//后半段路径</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>弗洛伊德算法的代码表示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph* g, <span class="type">int</span> Path[][maxSize], <span class="type">int</span> A[][maxSize])</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line">A[i][j] = g-&gt;edges[i][j];</span><br><span class="line">Path[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法的主体部分是一个三重循环,表示将k顶点逐步加入到路径中，并修改A矩阵和Path矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; g-&gt;vexnum; k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vexnum; j++)</span><br><span class="line"><span class="keyword">if</span> (A[i][j] &gt; A[i][k] + A[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">Path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法复杂度：O(n^3^)</li><li>弗洛伊德算法允许图中带有负权值的边存在，但不允许包含带负权值的边组成的回路。</li><li>弗洛伊德算法同样适用于带权无向图。</li><li>也可以使用单源最短路径算法来解决任意顶点之间的最短路径问题，需要对每个顶点都使用一次Dijkstra算法，时间复杂度是O(n^3^)。</li></ul><h2 id="拓扑排序">拓扑排序</h2><ul><li><p>DAG图：即有向无环图。</p></li><li><p>AOV网：即顶点表示活动的网络（Activity On Vertex network），用DAG图表示一个工程，其<strong>顶点表示活动</strong>，用有向<strong>边</strong>&lt;V~i~,V~j~&gt;表示<strong>活动之间的先后关系</strong>。</p></li><li><p>拓扑排序：是对DAG图顶点的一种排序，它使得若存在路径从顶点A到顶点B，则在拓扑排序中顶点B必然出现在A的后面。</p></li><li><p>拓扑排序满足下面的条件：</p><ol><li>每个顶点出现且只出现一次；</li><li>A在B的前面，则图中不存在从B到A的路径。</li></ol></li><li><p>拓扑排序不唯一。</p></li><li><p><strong>拓扑排序的方法：</strong></p><ol><li>从AOV网中选出一个没有前驱（入度为0）的顶点输出；</li><li>删除1中输出的顶点以及和它有关的边；</li><li>重复1和2，直到AOV网为空或者不存在没有前驱（入度为0）的顶点。</li></ol></li><li><p>举例：</p></li></ul><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/86c079e36a6541248117b9df068fafef.png" alt="在这里插入图片描述"></p><p>​ 拓扑排序1：abced</p><p>​ 拓扑排序2：abecd</p><p>​ 拓扑排序3：aebcd</p><ul><li><p>拓扑排序算法</p><p>需要用到一个入度数组indegree[]来记录顶点的入度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> indegree[maxSize];<span class="comment">//入度数组，记录所有顶点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopSort</span><span class="params">(AGraph *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//计数器</span></span><br><span class="line"><span class="type">int</span> stack[maxSize], top = <span class="number">-1</span>;<span class="comment">//初始化栈（不一定是栈，其他容器，比如队列也行，这里并没有对顺序要求）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexnum; i++)<span class="comment">//将所有入度为0的顶点入栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">stack[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关键步骤</span></span><br><span class="line"><span class="keyword">while</span> (top!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = stack[top--];<span class="comment">//栈顶顶点出栈</span></span><br><span class="line">++n;<span class="comment">//计数器+1</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出出栈顶点</span></span><br><span class="line"><span class="comment">//将出栈顶点v指向的所有顶点的入度-1，并将入度减为0的顶点入栈</span></span><br><span class="line">ArcNode *p = g-&gt;adjlist[v].firstArc;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;</span><br><span class="line">indegree[k]--;</span><br><span class="line"><span class="keyword">if</span> (indegree[k] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">stack[++top] = k;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == g-&gt;vexnum) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>算法时间复杂度：由于输出每个顶点的同时还要删除以它为起点的边，所以算法复杂度为O(n+e)</p></li><li><p><strong>逆拓扑排序</strong></p><p>对一个AOV网如下操作进行排序，称之为逆拓扑序列：</p></li></ul><ol><li>在网中任选一个没有后继的顶点（出度为0）输出</li><li>在网中删除和它有关的边（所有指向它的边）</li><li>重复1和2，直到AOV网为空或者不存在没有后继的顶点</li></ol><ul><li>使用<strong>DFS</strong>（深度优先搜索遍历）进行拓扑排序</li></ul><p>当有向图无环时，可以<strong>用DFS（深度优先搜索遍历）先得到逆拓扑序列</strong>，进而得到拓扑序列。</p><p>由于图中无环，当由图中某个顶点出发进行DFS时，最先退出算法的顶点即为出度为0的顶点，就是逆拓扑序列的第一个顶点。所以，按照DFS算法的先后次序记录下的顶点序列即为逆向拓扑序列，将其逆向输出即为拓扑序列。</p><h2 id="关键路径">关键路径</h2><ul><li>AOE网：在带权有向图中，用顶点表示时间，有向边表示活动，权值表示活动进行的时间，则称之为用边表示活动的网络（Activity On Edge network）。</li><li>AOE网和AOV网都是有向无环图，区别在于它们的顶点和边表示的含义不同。</li><li>AOE网的性质<ol><li>只有在某个顶点所表示的事件发生后，从该顶点出发的各有向边代表的活动才能开始；</li><li>只有在所有指向某个顶点的边代表的所有活动都结束后，该顶点代表的事件才会发生；</li></ol></li><li>AOE网中只有一个入度为0的顶点，称为<strong>源点</strong>，代表着整个工程的开始；AOE网中只有一个出度为0的顶点，称为<strong>汇点</strong>，代表整个工程的结束。</li><li>关键路径：从源点到汇点的所有路径中，具有<strong>最大路径长度</strong>的路径称为<strong>关键路径</strong>。</li><li>关键活动：关键路径上的活动。</li><li>关键路径的长度代表完成整个工程所需要的时间，任何一个关键活动不能按时完成，整个工程的完成时间都会延后。所以，只有找到了关键路径，才能得到工程最短完成时间。</li><li>通过加快某些关键活动可以缩短整个工程的工期，但这也可能会导致该关键活动变成非关键活动。</li><li>关键路径并不唯一，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，必须<strong>加快那些包括所有关键路径上的关键活动才能缩短工期</strong>。</li></ul><p>按照下面的步骤可以求得某活动的关键路径与关键活动：</p><ol><li><p><strong>事件v~k~的最早发生时间ve(k)</strong></p><p>从源点v~1~到v~k~的最长路径长度。v~k~的最早发生时间决定了所有从顶点k开始的活动能够开工的最早时间。</p><p>推算方法：对图进行拓扑排序，按照拓扑排序的顺序求ve：</p><blockquote><p>ve(源点)=0;</p><p>ve(k) = Max{ ve(j) + Weight(v~j~,v~k~) }</p></blockquote><p>其中，j是k的任意前驱，Weight(v~j~,v~k~) 表示边&lt;v~j~,v~k~&gt;上的权值。也就是说，在图中可能有多条边指向k（k在图中能有多个直接前驱），而经过直接前驱j到k的这条路径最长，即ve(j)+ Weight(v~j~,v~k~) 最大，则取这个最大值作为ve(k)。</p></li><li><p><strong>事件v~k~的最迟发生时间vl(k)</strong></p><p>在不推迟整个工程完成的前提下，该事件最迟发生的时间。</p><p>推算方法：对图进行逆拓扑排序，按照逆拓扑排序的顺序求vl：</p><blockquote><p>vl(汇点)=ve(汇点)；</p><p>vl(k) = min{ vl(j) - Weight(v~k~,v~j~) }</p></blockquote><p>假设j是k的后继事件（j可能有多个），vl(j)是事件j的最迟发生时间，从事件k到事件j的活动须花费时长Weight(v~k~,v~j~)，所以vl(j) - Weight(v~k~,v~j~)表示相对于事件j来说事件k的最晚的发生时间。j可能有多个，k应该相对尽早地发生，才能满足所有的j在各自的最迟发生时间能发生，所以要取vl(j) - Weight(v~k~,v~j~)最小值，即为k的最迟发生时间。</p></li><li><p><strong>活动a~i~的最早开始时间e(i)</strong></p><p>即该活动的起点事件所发生的最早发生时间。若&lt;v~k~,v~j~&gt;表示活动a~i~，则e(i)=ve(k)。</p></li><li><p><strong>活动a~i~的最迟开始时间l(i)</strong></p><p>即该活动的终点事件的最迟发生时间与该活动所需要的时间之差。若&lt;v~k~,v~j~&gt;表示活动a~i~，则l(i)=vl(j)-Weight(v~k~,v~j~)。</p></li><li><p><strong>活动的剩余时间：l(i)-e(i)</strong></p><p>表示在不延长总工程完成时间的前提下，活动a~i~可以拖延的时间。当某个活动的剩余时间为0时，表示它必须如期完成，否则就会导致整个工期的延后，称这种活动为关键活动。所有关键活动构成的路径就是关键路径。</p></li></ol><p>举例：</p><p>先求拓扑排序和逆拓扑排序：1346和6431。</p><p>按照拓扑排序，从源点处开始，求事件v~k~的最早发生时间ve(k)</p><p>按逆拓扑排序，从汇点处开始，求事件v~k~的最迟发生时间vl(k)。</p><p>规定，源点处的事件的最早发生时间是0，而汇点处的事件的最迟发生时间等于它的最早发生时间。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/886b51c810a34810b428c2416713f8e2.png" alt=""></p><p>求事件的最早发生时间时，如果有多条边指向它，要选“ve(j) + Weight(v~j~,v~k~) ”最长的。</p><p>比如，求ve(6)时，ve(3)+a7=2+6 &lt; ve(4)+a6=1+8=9，选ve(4)+a7</p><p>求事件的最迟发生时间时，如果它指向多条边，要选“vl(j) - Weight(v~k~,v~j~)  ”最短的。</p><p>求vl(1)时，vl(4)-a3=1-1=0 &lt; vl(3)-a2=3-2=1，选k       vl(4)-a3</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/8d103f44b6ed4c958caf64de315ca1af.png" alt="在这里插入图片描述"></p><p>活动的最早开始时间就是引出这项活动的事件的最早发生时间，比如e(a2)=ve(1)，e(a6)=ve(3)</p><p>活动的最迟开始时间就是活动的终点事件的最晚发生时间与活动持续时间的差。</p><p>关键活动是指：活动的最早开始时间=活动的最迟开始时间的活动。这里就是a3和a7。</p><p>关键路径：关键活动组成的路径。它的路径最长，它的持续时间代表了整个工程的最短完成时间。</p><h1 id="例题">例题</h1><ol><li><p>顶点个数为n的无向图最多有n(n-1)/2条边。(C~n~^2^)</p></li><li><p>含有n个顶点的连通无向图最少有n-1条边。</p></li><li><p>含有n个顶点的连通有向图最少有n条边。</p></li><li><p>含有n个顶点的完全有向图含有n(n-1)条边。</p></li><li><p>使用下列（AB）方法可以判断出一个有向图是否有环?</p><p>A. 深度优先遍历</p><p>B. 拓扑排序</p><p>C. 求最短路径</p><p>D. 求关键路径</p><p>在有向图的DFS算法中，如果在遍历没有结束前，出现从孩子结点到父结点的边，自然说明这个有向图有环。</p><p>在拓扑排序中，每次要删除一个没有前驱的结点，如果到最后还有结点</p></li><li><p>当各边权值均相等时，BFS算法可以解决单源最短路径问题。</p></li><li><p>拓扑排序不唯一。</p></li><li><p>在拓扑排序中，如果A出现在B前面，则在图中必不会出现从B到A的路径。</p></li><li><p>无向图的邻接矩阵是对称矩阵。</p></li><li><p>对于无向图的邻接矩阵，顶点i的出度是指<strong>第i行元素之和</strong>，第j列的元素之和表示顶点j的入度。（1表示邻接，0表示不邻接）</p></li><li><p>对于有向图的邻接矩阵，顶点i的出度是指<strong>第i行所有非∞非0元素的个数</strong>，顶点i的入度是指第i列所有非∞非0元素的个数。</p></li><li><p>DFS算法类似于二叉树的先序遍历算法；BFS算法类似于二叉树的层次遍历算法。</p></li></ol><p>这项活动的事件的最早发生时间，比如e(a2)=ve(1)，e(a6)=ve(3)</p><p>活动的最迟开始时间就是活动的终点事件的最晚发生时间与活动持续时间的差。</p><p>关键活动是指：活动的最早开始时间=活动的最迟开始时间的活动。这里就是a3和a7。</p><p>关键路径：关键活动组成的路径。它的路径最长，它的持续时间代表了整个工程的最短完成时间。</p><h1 id="例题-2">例题</h1><ol><li><p>顶点个数为n的无向图最多有n(n-1)/2条边。(C~n~^2^)</p></li><li><p>含有n个顶点的连通无向图最少有n-1条边。</p></li><li><p>含有n个顶点的连通有向图最少有n条边。</p></li><li><p>含有n个顶点的完全有向图含有n(n-1)条边。</p></li><li><p>使用下列（AB）方法可以判断出一个有向图是否有环?</p><p>A. 深度优先遍历</p><p>B. 拓扑排序</p><p>C. 求最短路径</p><p>D. 求关键路径</p><p>在有向图的DFS算法中，如果在遍历没有结束前，出现从孩子结点到父结点的边，自然说明这个有向图有环。</p><p>在拓扑排序中，每次要删除一个没有前驱的结点，如果到最后还有结点</p></li><li><p>当各边权值均相等时，BFS算法可以解决单源最短路径问题。</p></li><li><p>拓扑排序不唯一。</p></li><li><p>在拓扑排序中，如果A出现在B前面，则在图中必不会出现从B到A的路径。</p></li><li><p>无向图的邻接矩阵是对称矩阵。</p></li><li><p>对于无向图的邻接矩阵，顶点i的出度是指<strong>第i行元素之和</strong>，第j列的元素之和表示顶点j的入度。（1表示邻接，0表示不邻接）</p></li><li><p>对于有向图的邻接矩阵，顶点i的出度是指<strong>第i行所有非∞非0元素的个数</strong>，顶点i的入度是指第i列所有非∞非0元素的个数。</p></li><li><p>DFS算法类似于二叉树的先序遍历算法；BFS算法类似于二叉树的层次遍历算法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-5 树与二叉树</title>
      <link href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的基本概念">树的基本概念</h1><ul><li>结点：结点不仅包含数据元素，而且包含指向子树的指针</li><li>结点的度：结点拥有的子树个数或者分支的个数。</li><li>树的度：树中各结点度的最大值。</li><li>叶子结点：又叫作终端结点，指度为0的结点</li><li>孩子：结点的子树的根结点。</li><li>双亲：与孩子的定义相对应。A是B的孩子，那么B就是A的双亲。</li><li>兄弟：同一 个双亲的孩子之间互为兄弟。</li><li>祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。</li><li>树的高度（或者深度）：树中结点的最大层次。</li><li>结点的深度：从根结点到该结点的路径上的结点个数。</li><li>结点的高度：从某结点往下走可能到达多个叶子结点，对应了多条通往这些叶子结点的路径，其中最长的那条路径上结点的个数。</li></ul><h1 id="树的存储结构">树的存储结构</h1><ul><li><p>顺序存储结构：<strong>双亲存储结构</strong></p><p>用一维数组即可实现：用数组下标表示树中的结点，数组元素的内容表示该结点的双亲结点，这样有了结点（下标）以及结点之间的关系（内容），就可以表示一 棵树了。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/2bdf73a2b0fa2165c8110bfe134b7660.png" alt="image-20210715231435883"></p></li><li><p>链式存储结构：</p><ol><li><p><strong>孩子存储结构</strong>：即将每个结点的所有孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表。</p></li><li><p><strong>孩子兄弟存储结构</strong>：又称二叉树表示法，即以二叉链表作为树的存储结构。</p><p>每个结点都包含了三个内容：结点值、指向结点的第一个孩子结点的指针、指向结点的下一个兄弟结点的指针。</p><p>这种存储方法比较灵活，最大的优点是可以方便实现树转化成二叉树的操作，方便查找孩子，但查找双亲比较麻烦，对此，可以采用三叉链表，多加一个指向父结点的指针。</p></li></ol></li></ul><h1 id="二叉树的定义">二叉树的定义</h1><p>将一般的树加上如下两个限制条件就得到了二叉树：</p><ol><li>每个结点最多只有两棵子树，即二叉树中结点的度只能为0、1、2。</li><li>子树有左右顺序之分，不能颠倒。</li></ol><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/37b8e8ed986c5636dae42da5fe930ae6.png" alt="请添加图片描述"></p><h1 id="二叉树的主要性质">二叉树的主要性质</h1><ol><li><p>总结点数=总分支数+1（根结点上面没有分支，其余每一个结点上面对应一个分支）</p></li><li><p>非空二叉树的叶子结点数=双分支结点数+1，即n~0~=n~2~+1（下标表示结点的分支个数）</p><blockquote><p>证明：总结点数=n~0~+n~1~+n~2~ ，总分支数=n~1~+2n~2~ ，又因为树中除了根结点，其余每个结点都对应一个分支，即总结点数=总分支数+1，所以有n~0~+n~1~+n~2~=n~1~+2n~2~+1，整理得n~0~=n~2~+1。</p></blockquote></li><li><p>二叉树中的空指针数=总结点数+1，空指针数也是线索二叉树的线索数</p><blockquote><p>证明：假设所有的空指针都是叶子结点，那么树中的所有结点都变成了双分支结点（n个），根据性质1，那么空指针数=叶子结点数=双分支结点数+1=n+1；</p></blockquote></li><li><p>在一个度为m的树中，度为1的结点数为n~1~，度为2的结点数为n~2~，……，度为m的结点为n~m~，则树中的叶子结点数n~0~=1+n~2~+2n~3~+…+(m-1)n~m~</p><blockquote><p>证明：总结点数n=n~0~+n~1~+…+n~m~，总分支数=n~1~+2n~2~+3n~3~+…+mn~m~，总结点数=总分支数+1，则有n~0~+n~1~+n~2~…+n~m~=1+n~1~+2n~2~+3n~3~+…+mn~m~，整理得：n~0~=1+n~2~+2n~3~+…+(m-1)n~m~</p></blockquote></li><li><p>二叉树的第i层上最多有2^i-1^个结点。（a~0~=1，q=2的等比数列第i项）</p></li><li><p>高度为k二叉树最多有2^k^-1结点（即高度为h的满二叉树）。（a~0~=1，q=2的等比数列前h项和）</p></li><li><p>高度为k二叉树最少有2^k-1^结点（=2^k-1^-1+1）。</p></li><li><p>有n个结点的完全二叉树，对各结点从上到下、从左到右依次编号（1~n）,对于结点a~i~来说：</p><ol><li>a的父结点的为编号为⌊i/2⌋（向下取整）</li><li>如果2i&lt;=n，那么a的左孩子的编号为2i</li><li>如果2i+1&lt;=n，那么a的右孩子编号为2i+1</li></ol></li><li><p>函数Catalan()：给定n个结点，能构成h(n)种不同的二叉树：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><msubsup><mi>C</mi><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">h(n)=\frac{C_{2}^{2n}}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5375em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1341em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0715em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p>具有n（n&gt;=1）个结点的完全二叉树的高度（或深度）为：</p><ul><li>⌊log~2~n⌋ + 1（⌊⌋表示向下取整）</li><li>⌈log~2~(n+1)⌉（⌈⌉表示向上取整）</li></ul></li><li><p>设N~h~表示高度为h的平衡二叉树所含有的最少结点数，则有：N~1~=1，N~2~=2，N~3~=4，N~5~=7，……，N~h~=N~h-2~+N~h-1~+1</p></li></ol><h1 id="二叉树的存储结构">二叉树的存储结构</h1><ul><li><p>顺序存储结构</p><p>即通过一个数组来存储一个二叉树。适用于完全二叉树，用于存储一般的二叉树会浪费大量的空间。</p><p>假如有n个结点的完全二叉树存储在数组a中，根结点的下标为<strong>1</strong>，对于结点<code>a[i]</code>，它的：</p><ol><li>左孩子：如果<code>2*i&lt;=n</code>，则左孩子为<code>a[2*i]</code>，否则没有左孩子</li><li>右孩子：如果<code>2*i+1&lt;=n</code>，则右孩子为<code>a[2*i+1]</code>，否则没有右孩子</li><li>双亲：<code>a[j]</code>，j=取整{i/2}</li></ol><p>假如有n个结点的完全二叉树存储在数组a中，根结点的下标为<strong>0</strong>，对于结点<code>a[i]</code>，它的：</p><ol><li>左孩子：如果<code>2*i+1&lt;=n</code>，则左孩子为<code>a[2*i+1]</code>，否则没有左孩子</li><li>右孩子：如果<code>2*i+2&lt;=n</code>，则右孩子为<code>a[2*i+2]</code>，否则没有右孩子</li><li>双亲：<code>a[j-1]</code>，j=取整{i/2}</li></ol><p><strong>易错点</strong>：注意和树的顺序存储结构区分，在树的顺序存储结构中，数组下标代表结点编号，数组中所存的内容是各结点之间的关系。而在二叉树的顺序存储结构中，数组下标不仅是结点编号，还包含了各结点之间的关系。由于二叉树属于树的一种，所以树的顺序存储结构可以用来存储二叉树，但二叉树的顺序存储结构不能用来存储树。</p></li><li><p>链式存储结构</p><table><thead><tr><th style="text-align:center">lchild</th><th style="text-align:center">data</th><th style="text-align:center">rchild</th></tr></thead></table><ol><li>data表示数据域</li><li>lchild表示左指针域，存储左孩子的位置</li><li>rchild表示右指针域，存储右孩子的位置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树链式存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line"><span class="type">char</span> data; <span class="comment">//默认char，可换</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchild;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchild;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉树的遍历">二叉树的遍历</h1><p>二叉树的遍历主要分为<strong>先序遍历、中序遍历、后序遍历</strong>以及一个<strong>层次遍历</strong>。</p><ul><li>先序遍历（DLR）<ol><li>访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol></li><li>中序遍历（LDR）<ol><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol></li><li>后序遍历（LRD）<ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ol></li></ul><p><strong>这里“序“指的是根结点何时被访问。可以看出三种遍历方式只是访问结点的时机不一样。</strong></p><ul><li><p>层次遍历</p><p>按照从左到右（或从右到左），从上到下逐行遍历结点。</p></li></ul><h2 id="二叉树深度优先遍历算法的实现">二叉树深度优先遍历算法的实现</h2><ul><li><p>三种二叉树深度优先遍历算法的程序模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trave</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="built_in">trave</span>(p-&gt;lchild);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="built_in">trave</span>(p-&gt;rchild);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于树中的每一个结点，不管是采用先序遍历、中序遍历、后序遍历哪一种，每个结点都会被经过<strong>3</strong>次。</p><p>如果统一在第一次经过时访问结点，那就是先序遍历；此时把对结点的访问操作写在1处；</p><p>如果统一在第二次经过时访问结点，那就是中序遍历；此时把对结点的访问操作写在2处；</p><p>如果统一在第三次经过时访问结点，那就是后序遍历。此时把对结点的访问操作写在3处；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//对结点的访问操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">preOrder</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">preOrder</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">inOrder</span>(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//对结点的访问操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">postOrder</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">postOrder</span>(p-&gt;rchild);</span><br><span class="line"></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//对结点的访问操作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//visit()函数是自定义的，根据实际需要，可以用任何针对结点的操作来代替它</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="层次遍历">层次遍历</h2><p>按照从左到右（或从右到左），从上到下逐行遍历结点。</p><p>要进行层次遍历，需要建立一 个队列。先将二叉树头结点入队列，然后出队列，访问该结点，如果它有左子树，则将左子树的根结点入队；如果它有右子树，则将右子树的根结点入队。然后出队列，对出队结点访问。如此反复，直到队列为空为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BTNode *que[maxSize];<span class="comment">//定义一个循环队列</span></span><br><span class="line"><span class="type">int</span>  front = <span class="number">0</span>, rear = <span class="number">0</span>;<span class="comment">//初始化队列，队头与队尾归零</span></span><br><span class="line"></span><br><span class="line">BTNode *q;<span class="comment">//临时变量，用来临时存储出队元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;<span class="comment">//非空树</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">que[rear] = p;<span class="comment">//这两句是循环队列的入队操作，这里表示根结点入队</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (front!=rear)&#123;<span class="comment">//队列非空</span></span><br><span class="line"></span><br><span class="line">front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">q = que[front];<span class="comment">//这两句是循环队列的出队操作，这里表示队头元素出队</span></span><br><span class="line">            </span><br><span class="line"><span class="built_in">visit</span>(q);<span class="comment">//访问结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果当前结点有左孩子，左孩子入队</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">que[rear] = q-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果当前结点有右孩子，右孩子入队</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">que[rear] = q-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是借助了循环队列，乍一看好像很麻烦，其实只是循环队列的初始化、入队、出队看着比较麻烦，如果可以把这些操作写成函数放在外面，会看着简洁一些。但是，不管怎么变化，核心思想是不变的，根据借助的队列类型不同、针对结点的操作不同，可以根据此模板来记忆层次遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOorder</span><span class="params">(BTNode *p)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//1.初始化队列</span></span><br><span class="line"></span><br><span class="line">BTNode *q;<span class="comment">//临时变量，用来临时存储出队元素</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;<span class="comment">//树非空</span></span><br><span class="line">        <span class="comment">//2.根结点入队</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (队列非空)&#123;         </span><br><span class="line"> <span class="comment">//3.出队 (出队元素赋值给q)</span></span><br><span class="line">             <span class="comment">//4.visit(q); 针对结点q的操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//5.如果q有左孩子，左孩子入队</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//6.如果q有右孩子，右孩子入队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层次遍历的模板与下面的二叉树深度优先遍历算法的非递归实现中的先序遍历模板很相似，主要区别是：</p><ol><li>层次遍历借助的是队列，而非递归先序遍历借助的是栈</li><li>层次遍历是左孩子优先于右孩子入队，而非递归先序遍历是右孩子优先于左孩子入栈</li></ol><p>注意不要记混。</p><h2 id="快速写出遍历序列的方法">快速写出遍历序列的方法</h2><p>先看最简单的情况：只有3个结点ABC</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/44a7985c4739e53feed3874930e362a7.png" alt="image-20210713000928775"></p><ul><li>先序遍历：按照DLR的规则：ABC（中左右）</li><li>中序遍历：按照LDR的规则：BAC（左中右）</li><li>后序遍历：按照LRD的规则：BCA（左右中）</li></ul><p>下面看更一般的情况：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vAUFRelu-1626800975200)(<a href="https://i.loli.net/2021/07/18/c8RfDynuWQqdGYh.png">https://i.loli.net/2021/07/18/c8RfDynuWQqdGYh.png</a>)]</p><ol><li><p>先序遍历：ABDECFG</p><p>将其按照（ A（BDE）（CFG））来划分，有没有观察到，BDE刚好是树A左下角以B为根结点的二叉树的先序遍历排列，CFG刚好是数A右下角以C为根结点的二叉树的先序遍历排列。往下还可以再划分，拿BDE来说，BDE又可以分成：（B（D）（E）），那么D自然就是树D的先序遍历了，E就是树E的先序遍历了。到这里就不能再划分了，因为D没有左子树了。有没有发现规律？</p><p>总结一下对A快速写出先序遍历结果的方法，即从大树化小树的方法：</p><ol><li>沿A最左边的分支一路向左下找，找到第一个没有左孩子的结点，这里就是树D</li><li>先完成对树D的先序遍历，这里树D没有右孩子，那遍历结果就是（D）。注意，如果树D有右孩子，把它当成树，依旧按照本方法</li><li>把对树D的先序遍历结果看成一个整体，再完成对树B的先序遍历，即：B（D）（?）。这里的?表示的B的右子树E的先序遍历结果，E没有子树，那么就是（E）。注意，如果E下面还有很多分支，还是按照本方法。那么树B的先序遍历就是（B（D）（E）），即：BDE</li><li>再把整个树B看成一个整体，再完成对树A的先序遍历即：（A（BDE）（?））。?表示的就是右子树C的先序遍历结果，那么就对树C按照上面的方法，沿C最左边的分支一路向左下找到第一个没有左孩子的结点，就是F，再按照上面的方法一次完成对树F，树C的先序遍历，得到数C的先序遍历结果（C（F）（G）），即：CFG，代入？里，得到树A的先序遍历结果（A（BDE）（CFG）），即：ABDECFG</li></ol></li><li><p>中序遍历：DBEAFCG</p><p>方法是类似的，沿A最左边的分支一路向左下找，找到第一个没有左孩子的结点，这里就是树D，依次对树D、树B、树A完成后序遍历即可。即：（（（D）B（E））A（（F）C（G）））</p></li><li><p>后序遍历：DEBFGCA</p><p>方法是类似的，沿A最左边的分支一路向左下找，找到第一个没有左孩子的结点，这里就是树D，依次对树D、树B、树A完成后序遍历列即可。（（（D）E（B））（（F）G（C））A），即：DEBFGCA</p></li></ol><p>本例中举的是最理想的情况，实际的树可能要比这复杂的多，越复杂的树利用这种方法就越方便。只要按照步骤1找到正确的开始结点，大树化小数的方法都是可以完成的（实际上我们写的遍历的递归程序就是这么做的）。熟悉这个过程这也为我们下面写非递归方法提供了思路。</p><h2 id="根据遍历序列确定二叉树">根据遍历序列确定二叉树</h2><ol><li><p>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</p></li><li><p>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树</p></li><li><p><strong>但是已知前序遍历序列和后序遍历序列，是不能确定一棵二叉树</strong></p></li></ol><p>即：<strong>没有中序遍历序列的情况下是无法确定一颗二叉树的</strong></p><p>why?拿上面的例子来说：</p><p>先序遍历：ABDECFG：（A（B（D）（E））（C（F）（G）））</p><p>中序遍历：DBEAFCG：（（（D）B（E））A（（F）C（G）））</p><p>后序遍历：DEBFGCA：（（（D）E（B））（（F）G（C））A）</p><p>几个规律：</p><ol><li><strong>先序遍历序列的第一个结点一定是根结点</strong></li><li><strong>后序遍历序列的最后一个结点一定是根结点</strong></li><li><strong>根结点将中序遍历序列分成左右子树两部分</strong></li></ol><p>所以，前序和后序在本质上可以将父子结点分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树。</p><p>按照上述的规律可以一步一步的还原二叉树，这里拿先序排列和中序排列举例：</p><ol><li>由先序可以确定根结点是A</li><li>在中序中找到A，左边DBE就是左子树，右边FCG就是右子树</li><li>在先序中找到去掉A，发现D、B、E三个结点的构成的树，B是根结点，同理，C是根结点。</li><li>在中序遍历中确定D是B的左孩子，E是B的右孩子；同理，F是C的左孩子，G是C的右孩子</li></ol><p>根据上述信息画图：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/9f294ed2e36670ab96d7257dc655c8fa.png" alt="在这里插入图片描述"></p><h1 id="二叉树遍历算法的改进">二叉树遍历算法的改进</h1><h2 id="二叉树深度优先遍历算法的非递归实现">二叉树深度优先遍历算法的非递归实现</h2><ul><li><p>Q1：为什么说二叉树的递归算法效率不高？如何解决？</p><p>递归函数所申请的系统栈，是一个所有递归函数都通用的栈。对于二叉树深度优先遍历算法，系统栈除了记录访问过的结点信息之外，还有其他信息需要记录，以实现函数的递归调用。</p><p>如果可以手动建立栈，仅保存遍历所需的结点信息，即对二叉树遍历算法进行针对性的设计，对于遍历算法来说，显然要比递归函数通用的系统栈更高效。</p></li><li><p><strong>递归算法是把大问题逐渐化成一个越来越小的问题，再从小到大，从内到外逐个解决，这个核心思想在我们把递归转化成循环时是不变的。循环代替递归的关键，就是通过手动维护栈来实现递归，这个时候，结点入栈出栈的时机就显得非常重要</strong>。递归算法描述起来非常简洁而且想象，但运行过程并不容易搞透，若想把递归算法转化成非递归算法（循环），就要对他的运行过程非常清楚，手动尝试去模拟各种遍历算法的运行过程有利于理解这一部分内容。</p></li><li><p>先序遍历的非递归算法</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder2</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bt非空</span></span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BTNode *stack[maxSize];<span class="comment">//定义栈</span></span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>;<span class="comment">//初始化,栈顶指针top为-1时栈空</span></span><br><span class="line">        stack[++top] = bt;<span class="comment">//根结点入栈</span></span><br><span class="line">        BTNode *q;<span class="comment">//q是遍历指针，表示当前正在处理的元素</span></span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span>) &#123;<span class="comment">//循环条件：栈非空</span></span><br><span class="line">            q = stack[top--];<span class="comment">//出栈，用q保存</span></span><br><span class="line">            <span class="built_in">visit</span>(q);<span class="comment">//访问q         </span></span><br><span class="line">            <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果q还有右孩子，右孩子入栈</span></span><br><span class="line">                stack[++top] = q-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果q还有左孩子，左孩子入栈</span></span><br><span class="line">                stack[++top] = q-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先序遍历的非递归过程：从根结点开始，入栈。进入循环，出栈并访问根结点，先判断根结点是否有右孩子，如果有，右孩子入栈，然后判断根结点是否有左孩子，如果有，左孩子入栈。继续循环，根结点的左孩子出栈，如果它有右孩子，右孩子入栈，如果它有左孩子，左孩子入栈…栈空时退出循环。</p><p>关键之处：右孩子优先于左孩子入栈的顺序不能变。在先序遍历中，对左孩子的访问要优先于右孩子，又由于栈的先进后出特性，所以，每次访问完一个结点，它的右孩子要先于它的左孩子入栈，这样做才能保证左孩子先被访问到。</p></li><li><p>中序遍历的非递归算法</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历的递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder2</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BTNode *stack[maxSize];</span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        BTNode *q = bt;<span class="comment">//q是遍历指针，表示当前正在处理的元素，初始值为根结点bt</span></span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> || q != <span class="literal">NULL</span>) &#123;<span class="comment">//注意这里的循环条件：栈非空或q非空</span></span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;<span class="comment">//这个whiLe的作用是沿着q的左下方走到头，路过的结点依次入栈</span></span><br><span class="line">                stack[++top] = q;</span><br><span class="line">                q = q-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span>) &#123;<span class="comment">//这个if的作用是将出栈、访问栈顶元素之后，将遍历指针q指向出栈元素的右孩子</span></span><br><span class="line">                q = stack[top--];</span><br><span class="line">                <span class="built_in">visit</span>(q);</span><br><span class="line">                q = q-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历的非递归过程：</p><ol><li><p>从根结点出发，一路朝着树的左下走到头，找到第一个没有左孩子的结点a，路过的结点依次入栈。a就是中序遍历的第一个结点，它一定在左下角（但并不一定是叶子结点，a可能还有右孩子） 。</p></li><li><p>出栈并访问a，然后将遍历指针指向它的右孩子，去判断它的右孩子是否存在：</p><p>如果a的右结点b存在，就把b视为一个新树，回到步骤1，又一路朝着b的左下走…这里也就体现了递归的思想。</p><p>如果a的右结点b不存在（这意味着以a为根结点的数就只有它一个元素，那么树a此时已经遍历），那就去找a的父结点c，去完成对c的遍历（还是递归的思想）。c此时就在栈顶（如果栈非空），那么我们就出栈，完成对c的访问操作后，继续把遍历指针p指向c的右孩子…再接着判断c的右孩子是否存在…</p></li><li><p>重复这个过程，当栈空而且p也为空时循环结束。</p></li></ol><p>关键之处：假设根结点是t，当t出栈并完成访问操作后，这就意味着这个数的左半部分（包括t）遍历完成，此时栈是空的，但树的右半部分还没有遍历，所以不能将栈空作为遍历循环的判断条件。此时遍历指针p指向的是t的右孩子，可以根据p的状态此来判断遍历是否继续，最后一个元素遍历完时p指向的是它的右孩子，此时p为空。这就是外层遍历循环的判断条件<code>top != -1 || q != NULL</code>的原因。</p></li><li><p>后序遍历的非递归算法</p><p>后序遍历的非递归算法是最困难的，这里提供一种易于理解的版本。</p><p>先序遍历：ABDECFG（A（B（D）（E））（C（F）（G）））</p><p>中序遍历：DBEAFCG</p><p>后序遍历：DEBFGCA</p><p>逆后序遍历：ACGFBED</p><p>有一个规律是：逆后序遍历可以看成是把先序遍历过程中对左右子树遍历顺序交换所得的结果。</p><p>按照此规则实现后序遍历，要做两件事：</p><ol><li>在交换左右子树的遍历顺序的前提下进行先序遍历</li><li>对上述遍历结果逆序输出</li></ol><p>所以我们这里用到两个栈，一个栈是遍历本来就需要的，另一个则是来进行逆序的。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder2</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//栈1用来辅助进行交换了左右子树遍历顺序的先序遍历</span></span><br><span class="line"><span class="comment">//栈2用来实现上述遍历结果的逆序输出</span></span><br><span class="line">BTNode *stack1[maxSize];<span class="type">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">BTNode *stack2[maxSize];<span class="type">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">BTNode *q;<span class="comment">//遍历指针q</span></span><br><span class="line">stack1[++top1] = bt;</span><br><span class="line"><span class="comment">//进行交换了左右子树遍历顺序的先序遍历</span></span><br><span class="line"><span class="keyword">while</span>(top1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">q = stack1[top1--];</span><br><span class="line">stack2[++top2] = q;<span class="comment">//每次从栈1出去的元素,就立即把它放入到栈2中</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果q还有左孩子，左孩子入栈，这里左右子树的入栈的先后顺序发生了变化</span></span><br><span class="line">stack1[++top1] = q-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果q还有右孩子，右孩子入栈</span></span><br><span class="line">stack1[++top1] = q-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历结束后，栈2元素逐个出栈即可实现后序遍历</span></span><br><span class="line"><span class="keyword">while</span> (top2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">q = stack2[top2--];<span class="comment">//栈2元素出栈并访问</span></span><br><span class="line"><span class="built_in">visit</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线索二叉树">线索二叉树</h2><p>对于先序遍历、中序遍历、后序遍历来说，存在一定的局限性：</p><ol><li>不能从指定结点开始遍历，遍历操作必须从根开始</li><li>无法快速的找到某个结点的前驱与后继，每次查找都要从头开始遍历</li></ol><p>对此，解决思路是，能不能通过某种方式把树中结点的前驱和后继的相关信息保存起来，这样后续查找时就非常高效。</p><p>n个结点的二叉树共计有n+1个空指针，利于这些空指针来保存前驱与后继信息。</p><h3 id="线索二叉树的存储结构">线索二叉树的存储结构</h3><table><thead><tr><th style="text-align:center">lchild</th><th style="text-align:center">ltag</th><th style="text-align:center">data</th><th style="text-align:center">rtag</th><th style="text-align:center">rchild</th></tr></thead></table><p>在二叉树线索化的过程中会把树中的空指针（lchild与rchild）利用起来作为寻找当前结点前驱或后继的线索，这样就出线索和树中原有指向孩子结点的指针无法区分。为解决这个问题，增设两个标识域ltag和rtag，它们的具体意义如下：</p><ol><li>如果<strong>ltag=0</strong>，则表示<strong>lchild为指针</strong>，指向结点的<strong>左孩子</strong>；如果<strong>ltag=1</strong>， 则表示<strong>lchild为线索</strong>，指向结点的<strong>直接前驱</strong>。</li><li>如果<strong>rtag=0</strong>，则表示<strong>rchild为指针</strong>，指向结点的右孩子；如果<strong>rtag=1</strong>，则表示<strong>rchild为线索</strong>，指向结点的<strong>直接后继</strong>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树数结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTBNode</span> &#123;</span><br><span class="line"><span class="type">char</span> data;<span class="comment">//默认为char，可替换</span></span><br><span class="line"><span class="type">int</span> ltag, rtag;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTBNode</span>* lchild;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTBNode</span>* rchild;</span><br><span class="line">&#125;TBTNode;</span><br></pre></td></tr></table></figure><p>先序遍历、中序遍历、后序遍历的线索化方式是不同的，对应的线索二叉树称为<strong>先序线索二叉树、中序线索二叉树、后续线索二叉树</strong>。</p><h3 id="中序线索化">中序线索化</h3><p>对一棵二叉树中所有结点的空指针域按照某种遍历方式加线索的过程叫作<strong>线索化</strong>，被线索化了的二叉树称为<strong>线索二叉树</strong>。</p><p>线索化从某种程度上讲，可以看成是对<strong>遍历算法的一种应用</strong>。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/9f47a702f64d0f31479129e2f1f3f96a.png" alt="image-20210713203209570"></p><p>中序线索化的规则是：</p><ol><li>左线索指针指向当前结点在中序遍历序列中的前驱结点，右线索指针指向后继结点；</li><li>需要两个辅助指针p和pre，p表示当前结点，pre表示p的前驱结点；</li><li>p 的左线索如果存在则让其指向pre， pre的右线索如果存在则让其指向p，这样就完成了一 对线索的连接；</li><li>按照这样的规则一 直进行下去，当整棵二叉树遍历完成的时候，线索化也就完成了。</li></ol><p>按照上述规则可以写出两个结点线索化的过程，这就：</p><ul><li>==<strong>二叉树线索化的代码块</strong>==(非常重要)：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p-&gt;lchild = pre;</span><br><span class="line">    p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pre-&gt;rchild = p;</span><br><span class="line">    pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">pre = p;</span><br></pre></td></tr></table></figure><p>二叉树进行中序线索化是在二叉树中序遍历算法的框架中进行的，先回顾下中序遍历递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">inOrder</span>(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//线索化写在这里代替visit</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把前面的visit()函数替换成线索化的代码块，即可得到中序线索化一个二叉树的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;    </span><br><span class="line"><span class="built_in">inThread</span>(p-&gt;lchild, pre);<span class="comment">//递归，中序遍历并线索化左子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">        pre = p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">inThread</span>(p-&gt;rchild, pre);<span class="comment">//递归，中序遍历并线索化左子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过中序遍历建立中序线索二叉树的主程序为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过中序遍历建立中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatInThread</span><span class="params">(TBTNode *tbt)</span> </span>&#123;</span><br><span class="line">TBTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tbt != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">inThread</span>(tbt, pre); <span class="comment">//中序线索化，传入根结点tbt和它的前驱NULL</span></span><br><span class="line">pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*inThread最后一次执行时：</span></span><br><span class="line"><span class="comment">p指向中序遍历的最后一个结点的右孩子（NULL），pre指向最后一个结点，不满足if（p!=NULL）&#123;...&#125;，函数结束。</span></span><br><span class="line"><span class="comment">此时还差最后一个结点的后继没有线索化，应该手动完成最后一个结点的右线索*/</span></span><br></pre></td></tr></table></figure><p>经过上述操作后，可以理解为已经把二叉树变成了一个中序线索二叉树，可以将其视为一个链表。</p><p>中序线索二叉树中隐含了线索二叉树的前驱与后继信息。对其遍历时，只需要先找到序列中的第一个结点，然后依次找到结点的后继，直到后继为空即可。</p><ul><li><p>查找中序线索二叉树的中序序列的第一个结点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求以p为根的中序线索二叉树中，中序序列下的第一个结点：</span></span><br><span class="line"><span class="function">TBTNode *<span class="title">getFirst</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) &#123;<span class="comment">//树中最左下的结点（不一定是叶结点）</span></span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找中序线索二叉树的中序序列的最后一个结点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求以p为根的中序线索二叉树中，中序序列下的最后一个结点：</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">getLast</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>) &#123;<span class="comment">//最右下的就是最后一个结点</span></span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找中序线索二叉树的中序序列的后继结点：</p><ol><li>若右标志为1，则右链被线索化，直接指向它的后继；</li><li>若右标志为0，就遍历右子树中找到第一个的结点，它就是p的后继，它在右子树的左下角，这里调用getFirst即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点p在中序线索二叉树的后继结点</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">getNext</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getFirst</span>(p-&gt;rchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查找中序线索二叉树的中序序列的前驱结点：</p><ol><li>若左标志为1，则左链被线索化，直接指向它的前驱；</li><li>若左标志为0，就遍历左子树中找到最后一个结点，它就是p的前驱，它在左子树的右下角，这里调用getLast()</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点p在中序线索二叉树的前驱结点</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">getPrior</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getLast</span>(p-&gt;lchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序线索二叉树的中序遍历方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索二叉树的中序遍历方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TBTNode *t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TBTNode *p = <span class="built_in">getFirst</span>(t);p != <span class="literal">NULL</span>;p = <span class="built_in">getNext</span>(p)) &#123;</span><br><span class="line"><span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="先序线索化">先序线索化</h3><ul><li><p>二叉树线索化的代码块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p-&gt;lchild = pre;</span><br><span class="line">    p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pre-&gt;rchild = p;</span><br><span class="line">    pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">pre = p;</span><br></pre></td></tr></table></figure></li><li><p>先序遍历的递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//线索化的代码块放这里代替visit</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">preOrder</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">preOrder</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>与中序线索二叉树一样，根据二叉树线索化的代码块以及先序遍历和后序遍历算法，只需要变动线索化代码块与递归的位置即可：</p><ul><li><p>二叉树的先序线索化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;   </span><br><span class="line">        <span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">        pre = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意，这里在递归入口处设有条件，左右指针不是线索才能继续递归      </span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">inThread</span>(p-&gt;lchild, pre);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">inThread</span>(p-&gt;rchild, pre);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>易错点</strong>：注意<strong>递归处的条件判断</strong>，这是先序线索化独有的，考虑一种特殊情况：加入p此时指向D，pre指向的是B，在对p完成线索化之后，p的lchild已经指向了B，此时按照程序，pre指向D，q指向D的lchild（注意，此时D已经完成线索化），即q又指向了B，又要去完成对B的线索化。可是， 在对D线索化前不是刚对B线索化过了吗？这就产生了死循环。所以，在递归入口前，我们要添加左右指针非线索的条件，就是为了避免这种情况。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/fb11b46b3d986ec64b87f58cfdcc9715.png" alt="image-20210714014808947"></p><ul><li><p>查找先序线索二叉树的先序后继结点</p><p>先序遍历遵循的是“根左右”的原则，</p></li></ul><ol><li>如果p有左孩子（ltag=0），那么左孩子就是它的后继</li><li>如果p没有左孩子但有右孩子（ltag=1，rtag=0），那么右孩子就是它的后继</li><li>如果p左右孩子都没有(ltag=1，rtag=1)，那么必然被线索化，它的右链域就指向它后继</li></ol><p>也就是说，只需要判断p有没有左孩子，如果它有左孩子，左孩子就是它的后继，否则，它的rchild一定指向它的后继。</p><p>所以不难写出先序遍历一个先序线索二叉树的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历先序线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (TBTNode *p = root;p != <span class="literal">NULL</span>;) &#123;</span><br><span class="line"><span class="built_in">visit</span>(p);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)<span class="comment">//ltag == 0说明p的左链域没有被线索化，那么它一定有左孩子，左孩子就是p的后继</span></span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//只要p没有左孩子，那么不管右孩子是否被线索化，rchild一定指向p的后继</span></span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天勤书上的版本，个人觉得没有上面这个好理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOreder</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TBTNode *p = root;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">visit</span>(p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">visit</span>(p);</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>查找先序线索二叉树的先序前驱结点</p><ol><li>p结点被线索化，那么p-&gt;lchild就是它的前驱</li><li>p结点没有被线索化，根据先序二叉树：根左右的顺序，根的左子树和右子树都是他的后继，而未被线索化的结点是没有办法返回查找的，所以这种情况下找不到前驱。此时只能从头遍历一次二叉树，才能确定p结点的前驱。</li></ol><p>改进：改二叉链表结构为三叉链表结构，每个结点再增设一个指向父结点的指针。</p></li></ul></li></ul><h3 id="后序线索化">后序线索化</h3><ul><li><p>后序遍历的递归算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">postOrder</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">postOrder</span>(p-&gt;rchild);</span><br><span class="line"></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//线索化的代码块放这里代替visit</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的后序线索化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;    </span><br><span class="line"><span class="built_in">postThread</span>(p-&gt;lchild, pre);<span class="comment">//递归，后序遍历并线索化左子树</span></span><br><span class="line">        <span class="built_in">postThread</span>(p-&gt;rchild, pre);<span class="comment">//递归，后序遍历并线索化左子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线索化：p的左线索如果存在则让其指向pre</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre非空且pre右线索存在则让其指向p</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p和pre线索化完成后，将pre指向p（p在之后将指向它的孩子）</span></span><br><span class="line">        pre = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找后序线索二叉树的后序前驱结点</p><p>后序遍历遵循“左右根”的规则：</p><ol><li>如果p有右孩子，那么p的后序前驱为p的右孩子</li><li>如果p没有右孩子，那么p的后序前驱为p的左孩子</li><li>如果p左右孩子都没有，那么p已经被线索化，lchild指向它的前驱</li></ol><p>也就是说，只需要判断p到底有没有右孩子即可，有右孩子，p的前驱就是rchild，否则就是lchild。</p></li><li><p>查找后序线索二叉树的后序后继结点</p><ol><li>如果p的右链域被线索化，那么p的后继就是rchild；</li><li>如果p没有被线索化，那么根据后序二叉树：左右根的顺序，根的左子树和右子树都是他的前驱，而未被线索化的结点是没有办法返回查找的，所以这种情况下找不到p的后继。此时只能从头遍历一次二叉树，才能确定p结点的后继。</li></ol><p>改进：改二叉链表结构为三叉链表结构，每个结点再增设一个指向父结点的指针。</p></li></ul><h3 id="手动查找线索二叉树中的前驱与后继">手动查找线索二叉树中的前驱与后继</h3><p>首先，上面已经分析了机器查找的过程，总结如下图：先序线索二叉树和后续线索二叉树都存在一定的局限性。为了解决这个问题，可以将二叉链表结构为三叉链表结构，多增设一个指向父结点的指针。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n3SRU0Ni-1626800975205)(C:/Users/76583/Desktop/%E5%A4%A9%E5%8B%A4%E7%AC%94%E8%AE%B0/image-20210714205603680.png)]</p><p>如何人工的查找前驱与后继呢？这里重点看先序线索二叉树找前驱以及后序线索二叉树找后继。</p><ul><li><p>查找中序线索二叉树的中序后继结点：</p><ol><li>若右标志为1，则右链被线索化，直接指向它的后继；</li><li>若右标志为0，就遍历右子树中找到第一个的结点，它就是p的后继，它在右子树的左下角。</li></ol></li><li><p>查找中序线索二叉树的中序前驱结点：</p><ol><li>若左标志为1，则左链被线索化，直接指向它的前驱；</li><li>若左标志为0，就遍历左子树中找到最后一个结点，它就是p的前驱，它在左子树的右下角。</li></ol></li><li><p>查找先序线索二叉树的先序后继结点</p><ol><li>如果p有左孩子（ltag=0），那么左孩子就是它的后继</li><li>如果p没有左孩子但有右孩子（ltag=1，rtag=0），那么右孩子就是它的后继</li><li>如果p左右孩子都没有(ltag=1，rtag=1)，那么必然被线索化，它的右链域就指向它后继</li></ol><p>也就是说，只需要判断p有没有左孩子，如果它有左孩子，p的后继就是lchild，否则就是rchild。</p></li><li><p><strong>查找先序线索二叉树的先序前驱结点</strong></p><ol><li>p结点被线索化，那么p-&gt;lchild就是它的先序前驱</li><li>p结点没有被线索化，找到p的父亲结点q，按照“根左右”的规则 ：<ol><li>p是q的左孩子，则p的先序前驱是q；</li><li>p是q的右孩子，且p没有左孩子，则p的先序前驱是q；</li><li>p是q的右孩子，且p有左孩子，则p的先序前驱是q的左子树最后一个被先序遍历的结点（右下角）</li></ol></li><li>p是根结点，则p没有先序前驱。</li></ol></li><li><p>查找后序线索二叉树的后序前驱结点</p><ol><li>如果p有右孩子，那么p的后序前驱为p的右孩子</li><li>如果p没有右孩子，那么p的后序前驱为p的左孩子</li><li>如果p左右孩子都没有，那么p已经被线索化，lchild指向它的前驱</li></ol><p>也就是说，只需要判断p到底有没有右孩子即可，有右孩子，p的前驱就是rchild，否则就是lchild。</p></li><li><p><strong>查找后序线索二叉树的后序后继结点</strong></p><ol><li>如果p的右链域被线索化，那么p的后继就是rchild；</li><li>如果p没有被线索化，找到p的父亲结点q，根据后序二叉树“左右根”的规则：<ol><li>p是q的右孩子，那么p的后序后继就是q；</li><li>p是q的左孩子，且p没有右孩子，则p的后序后继就是q；</li><li>p是q的左孩子，且p有右孩子，则p的后序后继就是q的左子树中第一个被后序遍历的结点（左下角）</li></ol></li><li>p是根节点，则p没有后序后继。</li></ol></li></ul><h1 id="树、森林和二叉树的相互转换">树、森林和二叉树的相互转换</h1><p>树的孩子兄弟存储结构与二叉树的存储结构本质上都是二叉链表，只是左右结点表达的含义不同：</p><ul><li>二叉树<ol><li>lchild：结点的左孩子</li><li>rchild：结点的右孩子</li></ol></li><li>树的孩子兄弟表示法<ol><li>child：结点的第一个孩子</li><li>sibling：结点的下一个兄弟</li></ol></li></ul><h2 id="树转换为二叉树">树转换为二叉树</h2><p>规则：孩子兄弟表示法：</p><ol><li>每个结点的左指针指向自己的第一个孩子</li><li>每个结点的右指针指向相邻的右兄弟</li></ol><p>即“<strong>左孩子，右兄弟</strong>”，<strong>由于根结点没有兄弟，所以转换后的二叉树没有右子树</strong>。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/a8bfb37d1d45859433611024ecc31fd2.png" alt="请添加图片描述"></p><p>树转换成二叉树的画法：</p><ol><li><p>在各兄弟结点之间加一条连线</p></li><li><p>对每一个结点，只保留它与第一个孩子之间的连线，其余都抹去</p></li><li><p>以树根为圆心，顺时针旋转45度</p></li></ol><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/4cbfb18f43c39d853f53855b45ea7ffa.png" alt="请添加图片描述"></p><h2 id="二叉树转换为树">二叉树转换为树</h2><p>把树转换为二叉树的过程逆过来即可：</p><ol><li>以树根为圆心，逆时针旋转45度</li><li>则同一层的为兄弟，顺着兄弟的路径找到上一层父结点，连线</li><li>抹去每一层结点之间的连线</li></ol><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/fa1b09a2a2ba6f3ceb12c20a9c9fd481.png" alt="请添加图片描述"></p><h2 id="森林转换为二叉树">森林转换为二叉树</h2><ol><li>对森林中的每一颗树都按照上面的方法转换为二叉树</li><li>每个树转换为二叉树后都没有右子树，那么就把森林中的第二棵树当做第一颗树的右子树，以此类推，最终整个森林就转变成了二叉树。</li></ol><h2 id="二叉树转换为森林">二叉树转换为森林</h2><ol><li>不停地将根结点有右孩子的二叉树的右孩子链接断开，直到不存在根结点有右孩子的二叉树为止；</li><li>然后将得到的多棵二叉树按照二叉树转化为树的规则依次转化即可。</li></ol><h2 id="树的遍历">树的遍历</h2><p>树的遍历有两种方式：先序遍历和后序遍历。</p><ol><li><p>先序遍历是先访问根结点，再依次访问根结点的每棵子树，访问子树时仍然遵循先根再子树的规则；</p></li><li><p>后序遍历是先依次访问根结点的每棵子树，再访问根结点，访问子树时仍然遵循先子树再根的规则。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/dc1c4a82d16091dc9adb3531cccf7b05.png" alt="请添加图片描述"></p></li></ol><p>对于如图所示的树：先序遍历的结果为ABEFCGDHIJ，后序遍历的结果为EFBGCHIJDA。</p><p><strong>树转换为二叉树后，树的先序遍历对应二叉树的先序遍历，树的后序遍历对应二叉树的中序遍历（注意不是后序遍历）。</strong></p><p>所以，可以将树转换为二叉树后，借助遍历二叉树的方法来遍历树。假如一 棵树已经转化为二叉树来存储，要得到其先序遍历序列，只需先序遍历这棵二叉树；要得到其后序遍历序列，只需中序遍历这棵二叉树。</p><h2 id="森林的遍历">森林的遍历</h2><p>森林的遍历方式有两种：先序遍历和后序遍历。</p><ol><li>先序遍历的过程：先访问森林中第一 棵树的根结点，然后先序遍历第一 棵树中根结点的子树，最后先序遍历森林中除了第一 棵树以外的其他树。</li><li>后序遍历的过程：后序遍历第一棵树中根结点的子树，然后访问第一棵树的根结点，最后后序遍历森林中除去第一 棵树以外的其他树。</li></ol><p><strong>森林转换为二叉树，森林的先序遍历对应二叉树的先序遍历，森林的后序遍历对应二叉树的中序序列（注意不是后序遍历）。</strong></p><h1 id="二叉树的应用">二叉树的应用</h1><h2 id="赫夫曼树">赫夫曼树</h2><h3 id="赫夫曼二叉树">赫夫曼二叉树</h3><p>赫夫曼树又叫作最优二叉树，它的特点是带权路径最短。几个相关概念：</p><ol><li>路径：路径是指从树中一个结点到另一个结点的分支所构成的路线。</li><li>路径长度：路径长度是指路径上的分支数目。</li><li>树的路径长度：树的路径长度是指从根到每个结点的路径长度之和。</li><li>带权路径长度：结点具有权值，从该结点到根之间的路径长度乘以结点的权值，就是该结点的带权路径长度。</li><li><strong>树的带权路径长度（WPL）</strong>：树的带权路径长度是指树中所有叶子结点的带权路径长度之和。</li></ol><ul><li><p>构造赫夫曼二叉树</p><p>给定n个权值，用这n个权值来构造赫夫曼树的算法描述如下：</p><ol><li>将这n个权值分别看作只有根结点的n棵二叉树，这些二叉树构成的集合记为F。</li><li>从F中选出两棵根结点的权值最小的树（假设为a、b）作为左、右子树，构造一 棵新的二叉树c， 新的二叉树的根结点的权值为左、右子树根结点权值之和。</li><li>从F中删除a、b, 加入新构造的树c。</li><li>重复进行2、3两步，直到F中只剩下一 棵树为止，这棵树就是赫夫曼树。</li></ol></li><li><p>赫夫曼树的特点</p><ol><li><strong>树的带权路径长度最短</strong>。</li><li><strong>权值越大的结点，距离根结点越近</strong>。</li><li><strong>树中没有度为1的结点</strong>。这类树又叫作正则（严格）二叉树。</li><li>树中两个权值最小的结点一定是兄弟结点；</li><li>树中任一非叶结点的权值一定不小下一层任一结点的权值；</li><li>赫夫曼树的结点总数为2n-1，n为叶子结点个数，也是最开始给定权值的结点个数。</li><li>赫夫曼树不唯一，但WPL相同且最优。</li></ol></li></ul><h3 id="赫夫曼编码">赫夫曼编码</h3><p>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为<strong>固定长度编码</strong>。</p><p>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<strong>可变长度编码</strong>。</p><p>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</p><p>赫夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</p><p>任意一个字符的编码都不是另一个字符编码的前缀，则称这样的编码为前缀编码。前缀编码可以保证不会出现歧义。</p><ul><li><p>由赫夫曼树得到哈赫夫曼编码</p><ol><li>将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），根据频度大小构造出对应的赫夫曼树。</li><li>对赫夫曼树每个结点的左右分支编号，左0右1，则从根到每个结点的路径上的数字即为每个字符的赫夫曼编码。</li></ol><p>一个例子：假设有字符串s=“AAABBACCCDEEA”，按照上图的方法得到如图所示的赫夫曼树并对分支编号：</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ec77dfdf0c5a43f4cf3c78bbf901b0f8.png" alt="image-20210717233804817"></p><p>那么对ABCDE进行赫夫曼编码有：</p><ol><li>A=0</li><li>B=110</li><li>C=10</li><li>D=1110</li><li>E=1111</li></ol><p>可以看到，显然，所有字符结点都出现在叶结点中，且越靠近根结点的字符频度越高（权值越大），<strong>出现次数最多的字符编码长度就越短，而且赫夫曼编码属于前缀编码</strong>。根据赫夫曼树WPL最短的特性可知，<strong>赫夫曼编码产生的是最短前缀编码</strong>。</p></li></ul><h3 id="赫夫曼多叉树">赫夫曼多叉树</h3><p>赫夫曼二叉树是赫夫曼n叉树的一 种特例。</p><p>对于结点数目&gt;= 2 的待处理序列，都可以构造赫夫曼二叉树，但却不一 定能构造赫夫曼 n 叉树。</p><p>当发现无法构造时，需要补上权值为0的结点让整个序列凑成可以构造赫夫曼n叉树的序列。</p><p>例如：对于序列A(1)、B(3)、C(4)、D(6) (括号内为权值），就不能直接构造赫夫曼三叉树，需要补上一 个权值为0的结点H。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/155d465e9e92879998fa09bf79083222.png" alt="image-20210717234900685"></p><p>H结点的存在对WPL值没有影响，得到的仍然是最小WPL：(0*2)+(1*2)+(3*2)+(4*1)+(6*1)=18。</p><p>但要注意的是，二叉赫夫曼树和三叉赫夫曼树所得到的WPL是不同的，不要混淆最小的概念，这里的最小是说在含有n个带权叶结点的三叉树中，赫夫曼三叉树是WPL最小的。</p><h2 id="二叉排序树BST">二叉排序树BST</h2><ul><li><p>BST（Binary Search Tree）定义</p><p>二叉排序树或者是空树，或者是满足以下条件的树：</p><ol><li>若它的左子树不为空，则左子树上所有关键字的值均不大于（或不小于）根关键字的值</li><li>若它的右子树不为空，则右子树上所有关键字的值均不小于（或不大于）根关键字的值</li><li>左右子树又各是一颗二叉排序数。</li></ol><p>根据定义可知，二叉排序数的中序遍历是非递减有序（或非递增有序）的，没有特殊说明，BST均采取左小右大的分布。</p></li><li><p>存储结构</p><p>二叉排序树和二叉树的存储结构没有差别，都是有一个值域和两个指针域组成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> *rchild;</span><br><span class="line">&#125;BSTNode;</span><br></pre></td></tr></table></figure></li><li><p>查找关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找key</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">BSTSearch</span><span class="params">(BSTNode *bst,<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bst == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (key == bst-&gt;key) &#123;</span><br><span class="line"><span class="keyword">return</span> bst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bst-&gt;key) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bst-&gt;lchild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bst-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入关键字</p><p>要插入关键字首先要找到插入位置，对于一个不存在于二叉排序树中的关键字，其查找不成功的位置就是该关键字的插入位置。</p><ol><li>查找关键字，当来到空指针的位置就插入，返回1，新插入的结点必是叶结点</li><li>如果找到关键字，则不需要再插入，返回0，插入失败</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSTInsert</span><span class="params">(BSTNode *bst, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">bst = (BSTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">bst-&gt;lchild = bst-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">bst-&gt;key = key;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (key == bst-&gt;key) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bst-&gt;key) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BSTInsert</span>(bst-&gt;lchild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BSTInsert</span>(bst-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除关键字</p><p>二叉排序树的删除操作是最麻烦的，因为必须保证删除操作之后继续维持树的“有序性”。假设将要被删除的结点为p，f是它的父结点，那么会出现三种情况：</p><ol><li><p>p是叶子结点。直接删除即可。</p></li><li><p>p只有右子树而没有左子树，或者p只有左子树没有右子树。此时，只需要删除p，把它的子树接在f上取代p的位置即可。</p></li><li><p>p既有右子树也有左子树。按照以下操作方法可以将情况3转换为情况1,2：</p><p>找到中序遍历序列中p的直接前驱m，或者，找到中序遍历序列中p的直接后继n，将p的值改为m或者n，之后删除原m或者原n。</p><p>原先的m或者n的删除方式必然是情况1,2中的某一种，这样就完成了情况3向情况1,2的转换。</p></li></ol></li><li><p>建立二叉排序树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBST</span><span class="params">(BSTNode *&amp;bst,<span class="type">int</span> key[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    bst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">BSTInsert</span>(bst,key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉平衡树AVL">二叉平衡树AVL</h2><ul><li><p>定义</p><p>二叉平衡树或者是空树，或者是满足以下条件的树：</p><ol><li>平衡二叉树的左右子树都是平衡二叉树</li><li>左右子树的高度差不超过1。</li></ol><p>即：以树中所有结点为根的树的左右子树高度之差不超过1。</p></li><li><p>平衡因子</p><p>一个结点的平衡因子为其左子树的高度减去右子树高度的差。</p><p>对于平衡二叉树，树中的所有结点的平衡因子的取值只能是-1、0 、1 三个值。</p></li><li><p><strong>平衡二叉树的查找</strong></p><p>任意关键字的查找，比较次数不超过AVL树的高度。</p><p>设N~h~表示高度为h的平衡二叉树所含有的最少结点数，则有：N~0~=0，N~1~=1，N~2~=2，N~3~=4，N~5~=7，……，N~h~=N~h-2~+N~h-1~+1。</p><p>这个结论也可以反过来求给定结点数的AVL树的查找所需要的最多比较次数（或树的最大高度）。</p></li><li><p>平衡调整</p><p>建立平衡二叉树的过程和建立二叉排序树的过程基本一 样，都是将关键字逐个插入空树中的过程。不同的是，在建立平衡二叉树的过程中，每插入一 个新的关键字都要进行检查，看是否新关键字的插入会使得原平衡二叉树失去平衡，即树中出现平衡因子绝对值&gt;1的结点。如果失去平衡则需要进行<strong>平衡调整</strong>。平衡二叉树的重点就是平衡调整。</p></li><li><p><strong>平衡调整的方法</strong></p><p>假定向平衡二叉树中插入一 个新结点后破坏了平衡二叉树的平衡性：</p><ol><li>首先要找出插入新结点后失去平衡的最小子树</li><li>调整这棵子树，使之成为平衡子树。最小不平衡子树调整后，整个树恢复平衡。</li></ol><p>最小不平衡子树是指距离插入结点最近，且以平衡因子绝对值大于1的结点作为根的子树，又称为最小不平衡子树。</p></li></ul><h3 id="二叉平衡树的平衡调整">二叉平衡树的平衡调整</h3><p>主要分为四种情况：LL右单旋转，RR左单旋转，LR先左后右双旋转，RL先右后左双旋转。</p><p>这里的L与R是对不平衡状态的描述：比如LL，就是指结点A的<strong>左孩子</strong>的<strong>左子树</strong>上插入了新结点导致A失去平衡。</p><ol><li><p>LL调整：某时刻在a的左孩子b的左子树Y上插入 一 个结点，导致 a 的左子树高度为 h+2 , 右子树高度为h，发生不平衡。</p><p>此时应把b向右旋转代替a成为根结点，这一过程称为右单旋转。</p><p>具体操作为：将a下移一 个结点高度，b 上移一 个结点高度，也就是将 b 从 a 的左子树取下，然后将b的右子树挂在a的左子树上，最后将a挂在b的右子树上以达到平衡。</p></li><li><p>RR调整：情况与LL调整类似，对称处理<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/7fd308748d5e2023cc950abff7e0ffd0.png" alt="请添加图片描述"><br>即可。</p></li><li><p>LR调整：某时刻在a的左孩子b的右子树Y上插入一 个结点（不管是插在Y的左孩子还是右孩子，做法一样）导致不平衡。</p><p>需要做两次旋转，先左旋c后右旋b。</p><p>具体操作为：将c作为a和b两棵子树的根，b为左子树，a为右子树，c原来的左子树U作为b的右子树，c原来的右子树V作为a的左子树以达到平衡。这就是LR调整，也叫先左后右双旋转调整，因为调整的过程可以看成是先左旋c后右旋b。</p></li><li><p>RL调整：如果b在a的右子树上，且插入的结点在b的左子树上，即与图9-8a对称的情况，则此时只需将上述过程做左右对称处理即可。这种调整叫RL调整，也叫先右后左双旋转调整。</p></li></ol><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/33ef29bdcf93333fffb1b94ddc42e2d6.png" alt="请添加图片描述"></p><h1 id="典型例题">典型例题</h1><h2 id="二叉树的性质相关">二叉树的性质相关</h2><ol><li><p>一颗完全二叉树有1001个结点，其中叶子结点的个数为（501）个。</p><blockquote><p>分析：完全二叉树一定是由一颗满二叉树从下到上，从右到左，挨个删除结点所得到的。</p><p>也就是说，一颗完全二叉树，度为1（分支为1）的结点一定是1或者0，如果有度为1的结点，它的孩子一定是二叉树最后一层最后一个结点。</p><p>假设度为1的结点数位1，即n~1~=1，那么n=n~0~+n~1~+n~2~=n~0~+1+n~0~-1=2n~0~=1001，n~0~=500.5，显然错误。</p><p>假设度为1的结点数为0，即n~1~=0，那么此时二叉树中只有度为0和度为2的结点，则n=n~0~+n~2~，根据性质2，又有n~0~=n~2~+1，则n=n~0~+n~2~=n~0~+n~0~-1=2n~0~-1=1001，得n~0~=501。</p></blockquote></li><li><p>假设高度为h的二叉树中只有度为0和2的结点，那么此类二叉树中所包含的结点数<strong>最少</strong>为（2h-1）个。</p><blockquote><p>要求度只有0和2，且结点最少，那么必然是类似二叉赫夫曼数的构造。</p><p>除了第一层只有1个根结点以外，其余每一层都只有2个结点，则结点数为2h-1。</p><p>如果题目要求结点最多，那么自然是满二叉树，此时结点数是2^h^-1。</p></blockquote></li><li><p>设树的度为4，其中度为1、2、3、4的结点个数分别为4、2、1、1，则树中的叶子结点个数为（8）个。</p><blockquote><p>根据性质4：n~0~=1+n~2~+2n~3~+…+(m-1)n~m~=1+2+2*1+3*1=8</p></blockquote></li><li><p>有n个叶子结点的二叉赫夫曼树的结点总数是（2n-1）个。</p></li><li><p>n个结点的线索二叉树含有的线索数为（n+1）。</p><blockquote><p>线索二叉树的线索数等于原二叉树中的空指针数=总结点数+1</p></blockquote></li><li><p>一颗具有1025个结点的二叉树的高度h的范围为（11~1025）。</p><blockquote><p>高度最高：每层只有一个结点，则高度为1025</p><p>高度最低：完全二叉树，根据性质10，h=[log~2~(1025+1)]向上取整，h=11</p></blockquote></li><li><p>在度为m的赫夫曼树中，叶子结点的个数为n，则非叶子结点的个数为（ ⌈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n-1}{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>⌉）个。</p><blockquote><p>在构造度为m的赫夫曼树的过程中，每次把m个叶子结点合并为一个父结点 （第一 次合并可能少于 m 个子结点），每次合并减少 m -1个结点。加入第一次合并了m个结点，为了统一计算给n-1，把第一次合并看成m-1个结点，共需要 ⌈(n-1)/(m-1)⌉次合并，向上取整是因为最后不一定能整除，此时会人为的补上结点形成最后一次合并，每次合并增加一 个非叶子结点。下图展示了度为3，则叶子结点个数为8的赫夫曼三叉树的合并过程，橙色的为人为补上的结点。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/9bfe00ac282e5a616cb8d33ac8d5a4e4.png" alt="image-20210717221854178"></p></blockquote></li><li><p>已知一棵完全二叉树的第6层（设根为第1层）有8个叶子结点，则该完全二叉树的结点个数最多是（111）个。</p><blockquote><p>需要注意的是，树不一定是6层，不要陷入思维惯性，看到第6层有8个叶子结点，就下定论树只有6层。实际上，结点个数最多的情况下树有7层，第6层的8个叶子结点在第7层均没有孩子，即7层的满二叉树从7层右边往左去掉8*2=16个结点形成的完全二叉树。前6层为满二叉树，共有2^6^-1=63个结点，第7层有2^7-1^-16=48个结点，共计111个结点。</p></blockquote></li><li><p>已知一棵有2011个结点的树，它的叶子结点为116个，则该树转换成的二叉树中没有右孩子的结点个数为（1896）个。</p><blockquote><p>考虑极端情况：</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ab426d38b7fe3f8268cacf7705f49274.png" alt="image-20210717223732140"></p><p>按照“左孩子，右兄弟”的规则构成二叉树，最后一个叶子结点加上上面1895个中间结点必然没有右孩子。</p></blockquote></li><li><p>高度为6的平衡二叉树，所有非叶结点的平衡因子均为1，则该平衡二叉树的结点总数为（N~6~=20）</p><blockquote><p>根据性质11可推得，高度为6的平衡二叉树的结点最少为20个，实际上，题目所有非叶结点的平衡因子均为1，暗含的信息也是指结点最少的极端情况，当所有非叶结点的平衡因子均为1时，此时增加一个结点，会使得某个结点的平衡因子变为0，而不影响平衡性。这也就是构成平衡二叉树结点最少的情况。</p></blockquote></li><li><p>n和m为一颗二叉树的两个结点，在中序遍历时，n在m前的条件是n在m的左边。(对)</p></li><li><p><strong>对于二叉树来说，不管是前序、中序、后序遍历，叶子结点在遍历序列中的先后顺序是相同的</strong>。（对）</p></li><li><p>一颗二叉树的先序序列和后续序列正好相反，则该二叉树的高度一定等于其结点数。（对）</p></li></ol><h2 id="算法题">算法题</h2><h3 id="求二叉树的总结点数">求二叉树的总结点数</h3><ol><li><p>采用中序、先序、后序任意一种方式遍历树来计算；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums = <span class="number">0</span>;<span class="comment">//全局变量，一个计数器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">nums++;<span class="comment">//每次经过一个结点，计数器+1</span></span><br><span class="line"><span class="built_in">getNodeNums</span>(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">getNodeNums</span>(bt-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>采用另外一种递归思路：如果树空，返回0；如果树非空，求其左子树的的结点数n1，右子树的结点数n2，返回n1+n2+1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n1, n2;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">n1 = <span class="built_in">getNodeNums</span>(bt-&gt;lchild);</span><br><span class="line">n2 = <span class="built_in">getNodeNums</span>(bt-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> n1 + n2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="求二叉树的叶子结点数">求二叉树的叶子结点数</h3><p>给上一题加上限制条件：左右孩子非空即可。</p><ul><li><p>方法一:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nums++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">getNodeNums</span>(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">getNodeNums</span>(bt-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">getNodeNums</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n1, n2;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;<span class="comment">//空树返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)&#123;<span class="comment">//如果是叶子结点，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">n1 = <span class="built_in">getNodeNums</span>(bt-&gt;lchild);<span class="comment">//既不是空树也不是叶子结点，求它的左子树的叶子结点数</span></span><br><span class="line">n2 = <span class="built_in">getNodeNums</span>(bt-&gt;rchild);<span class="comment">//求它的右子树的叶子结点数</span></span><br><span class="line"><span class="keyword">return</span> n1 + n2 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="把二叉树的叶子结点从左到右串成链表">把二叉树的叶子结点从左到右串成链表</h3><p>具体要求就是修改叶子结点的rchild指针，指向它右边的叶子结点。用head和tail分别指向链表的表头和表尾。</p><p>分析：这里要用到一个非常重要的性质：不管是先序遍历、中序遍历还是后序遍历，在它们的遍历过程中叶子结点被访问的先后顺序都是不变的，都是从左往右。任选一种，修改visit函数即可，这里采用先序遍历的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkNodes</span><span class="params">(BTNode *bt, BTNode *&amp;head, BTNode *&amp;tail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//开始串接链表</span></span><br><span class="line">            <span class="comment">//head为空，说明bt是表头，表尾指针和表头指针同时指向它</span></span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line">head = bt;</span><br><span class="line">tail = bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//bt不是表头，就把它接在表尾，同时挪动表尾指针</span></span><br><span class="line">tail-&gt;rchild = bt;</span><br><span class="line">tail = bt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">linkNodes</span>(bt-&gt;lchild, head, tail);</span><br><span class="line"><span class="built_in">linkNodes</span>(bt-&gt;rchild, head, tail);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有指向父结点指针的二叉树">带有指向父结点指针的二叉树</h3><ol><li><p>修改数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode_p</span> &#123;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode_p</span> *lchild;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode_p</span> *rchild;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode_p</span> *parent;<span class="comment">//增加父亲指针</span></span><br><span class="line">&#125;BTNode_p;</span><br></pre></td></tr></table></figure></li><li><p>遍历二叉树，给每个结点都设立父结点，我们需要两个参数，当前结点和它的父结点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历二叉树设立父结点</span></span><br><span class="line"><span class="comment">//传入根结点和它的父结点NULL即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setParentTree</span><span class="params">(BTNode_p *btp, BTNode_p *par)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (btp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">btp-&gt;parent = par;</span><br><span class="line">btp = par;</span><br><span class="line"><span class="built_in">setParentTree</span>(btp-&gt;lchild, btp);</span><br><span class="line"><span class="built_in">setParentTree</span>(btp-&gt;rchild, btp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="将一颗满二叉树的先序序列转换为后序序列">将一颗满二叉树的先序序列转换为后序序列</h3><p>假设先序序列存储在数组pre[L1,…,R1]中，请把后序序列存储到post[L2,…,R2]数组中。</p><p>分析：根据满二叉树的特性可知，满二叉树具有一个重要的特性就是左右子树的结点数目是相等的，利用这一特性，我们可以很自然的根据先序序列唯一的满二叉树：序列的第一个元素就是根结点，然后将剩余的元素等分为两份，则分别为左子树序列和右子树序列。那如何把先序序列转换为后序序列呢？根据先序遍历和后序遍历的特性，它们的叶子结点的相对位置都是相同的，我们只需要递归地把先序序列中根结点的位置放到序列的末尾即可。但是，这种方法只适合于满二叉树，正是因为是满二叉树，我们才能每次正确的找到子树的根结点。</p><p>这里的主要难点就在于左右子树的下标问题，假设先序序列为pre[L1,…,R1]，后序序列将存储在post[L2,…,R2]中，那么：</p><p>左子树的下标：</p><ul><li><p>L1+1：在pre数组中除去第一个元素（根结点），剩下的第一个就是左子树下标的开始位置</p></li><li><p>(L1 + 1 + R1) / 2：在pre数组中L1+1到R2的中间位置就是左子树的末端下标</p></li><li><p>L2——0：在post数组中左子树的序列的开始位置始终在数组开始位置</p></li><li><p>R2——(L2 + R2 - 1) / 2：在post数组中L2到R2-1的中间位置就是左子树的末端下标</p></li></ul><p>左子树的下标：</p><ul><li>(L1 + 1 + R1) / 2 + 1：在pre数组中左子树的末端下标+1就是右子树的开始位置</li><li>R1：在pre数组中从右子树的开始位置一直到pre数组的末端都是右子树的结点</li><li>(L2 + R2 - 1) / 2 + 1：在post数组中左子树的末端下标+1就是右子树的序列的开始位置</li><li>R2 - 1：在post数组中从右子树的开始位置一直到post数组的倒数第二个位置（倒数第一是根结点）都是右子树的结点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把先序序列pre数组中下标L1到R1的元素转换为后序序列存到post数组中的L2到R2位置上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preToPost</span><span class="params">(<span class="type">char</span> pre[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">char</span> post[], <span class="type">int</span> L2, <span class="type">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//L1&gt;R1为递归结束的条件</span></span><br><span class="line"><span class="keyword">if</span> (L1 &lt;= R1) &#123;</span><br><span class="line">        <span class="comment">//将根结点放到后序序列的最后一位</span></span><br><span class="line">post[R2] = pre[L1];</span><br><span class="line">        <span class="comment">//递归转换左子树</span></span><br><span class="line"><span class="built_in">preToPost</span>(pre, L1 + <span class="number">1</span>, (L1 + <span class="number">1</span> + R1) / <span class="number">2</span>, post, L2, (L2 + R2 - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//递归转换右子树</span></span><br><span class="line"><span class="built_in">preToPost</span>(pre, (L1 + <span class="number">1</span> + R1) / <span class="number">2</span> + <span class="number">1</span>, R1, post, (L2 + R2 - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>, R2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的深度">求二叉树的深度</h3><blockquote><p>写一个算法求二叉树的深度，二叉树以二叉链表的形式存储。</p></blockquote><p>分析：假设这棵树的左子树的深度为ld，右子树的深度为rd，那这棵二叉树的深度等于ld和rd中的较大者再加一（根结点本身），采用递归的思想，先求左子树的深度，再求右子树的深度，最后返回二者中的较大者+1，按照&quot;左右中&quot;的遍历顺序，这不就正好是后序遍历吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二叉树的深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ld, rd;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>) &#123;<span class="comment">//作为递归结束标志，空树的深度自然为0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ld = <span class="built_in">getDepth</span>(bt-&gt;lchild);<span class="comment">//递归求得左子树的深度</span></span><br><span class="line">rd = <span class="built_in">getDepth</span>(bt-&gt;rchild);<span class="comment">//递归求得右子树的深度</span></span><br><span class="line"><span class="keyword">return</span> (ld &gt; rd ? ld : rd) + <span class="number">1</span>;<span class="comment">//返回二者中的较大者+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的宽度">求二叉树的宽度</h3><blockquote><p>写一个算法，求出二叉树的宽度（结点数最多的那一层上的结点个数），二叉树以二叉链表的形式存储。</p></blockquote><p>分析：直接在二叉树中求最大宽度显然不是一件容易的事情，如果我们能把树中的元素都存到线性表（队列）里，并记录下每一个结点所在的层数，直接遍历线性表就可以得到最大宽度了。那么我们要做的事情就变成了：</p><ol><li>遍历二叉树，求得树中每个结点所在的层数，并把信息存到队列里。</li><li>遍历队列，找出层数相同的最大结点个数</li></ol><p>根结点的层数显然为1，根结点的孩子的层数就为1+1。这就说明，只要我们当前结点的层数，就能知道它的孩子所在的层数。那该采取哪种二叉树遍历方式呢？显然是层次遍历，我们当然希望把结点一层一层的从左往右逐个放到线性表里，那么在同一层的结点就是相邻的，这样只需要一次遍历就能求得最大宽度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据我们的需求，定义队列中元素的结构体：结点+层数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">BTNode *node;<span class="comment">//结点指针</span></span><br><span class="line"><span class="type">int</span> lno;<span class="comment">//结点所在层数</span></span><br><span class="line">&#125;St;</span><br><span class="line"><span class="comment">//求二叉树的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">(BTNode *bt)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line">St que[maxSize];<span class="comment">//队列尽可能的大，能放下树中的所有结点</span></span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义两个临时变量用于接收每次出队元素保存的信息</span></span><br><span class="line">BTNode *q;</span><br><span class="line"><span class="type">int</span> Lno = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//根结点入队，它所在的层数是1</span></span><br><span class="line">que[++rear].node = bt;</span><br><span class="line">que[++rear].lno = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//队列非空时循环</span></span><br><span class="line"><span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">q = que[++front].node;</span><br><span class="line">Lno = que[++front].lno;</span><br><span class="line"><span class="comment">//左右孩子入队</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果出队结点q有左孩子，则左孩子入队，它所在的层数是q所在的层数+1</span></span><br><span class="line">que[++rear].node = q-&gt;lchild;</span><br><span class="line">que[++rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;<span class="comment">//如果出队结点q有右孩子，则右孩子入队，它所在的层数是q所在的层数+1</span></span><br><span class="line">que[++rear].node = q-&gt;rchild;</span><br><span class="line">que[++rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        最后一个结点出队后，Lno就保存的是树中的最大层数;</span></span><br><span class="line"><span class="comment">        上面所说的出队，并没有将元素从队列中删除，只是挪动了队头指针;</span></span><br><span class="line"><span class="comment">        遍历队列，求得最大宽度:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> maxWidth = <span class="number">0</span>;<span class="comment">//宽度</span></span><br><span class="line"><span class="type">int</span> num;<span class="comment">//计数器</span></span><br><span class="line"><span class="type">int</span> last=<span class="number">0</span>;<span class="comment">//last用来保存每次查找下一层结点时的开始位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lno; i++)<span class="comment">//分别查找第一层、第二层...第Lno层的结点个数</span></span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>  j = last; j &lt; rear; j++)<span class="comment">//从last位置开始统计第i层结点的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (que[j].lno == i) &#123;<span class="comment">//每发现一个第i层的结点，计数器+1</span></span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span> (num &gt; maxWidth) maxWidth = num;<span class="comment">//刷新最大宽度值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (que[j<span class="number">+1</span>].lno &gt; i) &#123; <span class="comment">//下一个结点不是第i层（必然是i+1层），就记录下次开始的位置并跳出循环找下一层</span></span><br><span class="line">last = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxWidth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于树中结点时按照一层一层从左往右的顺序存放的，那么层数相同的结点在队列中必然是相互挨着的，所以我们可以设置一个结束标志last，当发现下一个元素的层数不是i时，就直接跳出循环，下一次，找i+1层的元素时就直接从last开始找。所以，只需要遍历一次队列就够了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="求二叉树指定结点所在的层数">求二叉树指定结点所在的层数</h3><p>方法一：利用层次遍历，把结点和它所在的层数信息保存在一个新的数据结构中（跟上一题求最大宽度是的做法一样），然后保存在一个队列中，遍历队列即可解决问题。</p><p>方法二：利用递归遍历，定义一个全局变量层数L，初始值为1，每次遍历左孩子的时候就L+1，每次遍历完右孩子的时候将要返回根结点时就给L-1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> L = <span class="number">1</span>;<span class="comment">//全局变量L表示层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leno</span><span class="params">(BTNode* p, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x) &#123;<span class="comment">//如果p-&gt;data==x，就输出层数L</span></span><br><span class="line">cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">++L;<span class="comment">//每次遍历左孩子前就给层数+1</span></span><br><span class="line"><span class="built_in">leno</span>(p-&gt;lchild,x);</span><br><span class="line"><span class="built_in">leno</span>(p-&gt;rchild,x);</span><br><span class="line">--L;<span class="comment">//每次遍历完右孩子放回根结点前，就给层数-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据先序序列和中序序列构造二叉树">根据先序序列和中序序列构造二叉树</h3><blockquote><p>二叉树的先序序列存储在一维数组pre[L1,…,R1]中，中序序列存储在一维数组in[L2,…,R2]中，（L1,L2,R1,R2均表示了数组中元素的下标范围，元素为char型），假设二叉树中各结点中数据值不相同，请给出由pre[L1,…,R1]和in[L2,…,R2]构造二叉树的算法。</p></blockquote><p>分析：根据先序序列和中序序列构建二叉树：</p><ol><li><p>根据先序序列的第一个结点找到根结点</p></li><li><p>在中序序列中找到根结点的位置i，i左边就是左子树，i右边就是右子树：</p><p>在in中，从L2到i-1就是左子树，i+1到R2就是右子树</p><p>与之对应的左子树在pre的位置是L1+1到L1+（i-L2）,右子树的位置是L1+（i-L2）+1到R1</p></li><li><p>重复1，2两步，递归地构建左右子树，当L1-R1&lt;0（表示待处理序列的长度&lt;0）时递归结束</p></li></ol><p>这个算法的关键是确定左右子树的序列在pre和in数组中的下标。给出实例结合代码分析。</p><p>先序遍历pre：ABDECFG：（A（B（D）（E））（C（F）（G）））</p><p>中序遍历in：DBEAFCG：（（（D）B（E））A（（F）C（G）））</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由pre[L1,...,R1]和in[L2,...,R2]构造二叉树</span></span><br><span class="line"><span class="function">BTNode *<span class="title">createBT</span><span class="params">(<span class="type">char</span> pre[], <span class="type">char</span> in[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//L1&gt;R1说明处理的序列长度小于0，返回NULL，是递归结束的条件</span></span><br><span class="line">    <span class="keyword">if</span> (L1 &gt; R1) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//构造根节点</span></span><br><span class="line">BTNode *bt;</span><br><span class="line">bt = (BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//查找pre[L1]在in数组中的位置，用i记录下来</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = L2;i &lt;= R2;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[L1])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//给bt的各参数赋值</span></span><br><span class="line">bt-&gt;data = in[i];</span><br><span class="line">    <span class="comment">//递归构建bt的左右子树</span></span><br><span class="line">    <span class="comment">//pre[L1 + 1,...,L1 + i - L2]是左子树先序序列，pre[L1 + i - L2 + 1,..., R1]是右子树的先序序列</span></span><br><span class="line">    <span class="comment">//in[L2,..., i - 1]是左子树的中序序列，in[i + 1,..., R2]是右子树的中序序列</span></span><br><span class="line">bt-&gt;lchild = <span class="built_in">createBT</span>(pre, in, L1 + <span class="number">1</span>, L1 + i - L2, L2, i - <span class="number">1</span>);</span><br><span class="line">bt-&gt;rchild = <span class="built_in">createBT</span>(pre, in, L1 + i - L2 + <span class="number">1</span>, R1, i + <span class="number">1</span>, R2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建完成后返回根节点</span></span><br><span class="line"><span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1，每次遍历完右孩子的时候将要返回根结点时就给L-1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> L = <span class="number">1</span>;<span class="comment">//全局变量L表示层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leno</span><span class="params">(BTNode* p, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x) &#123;<span class="comment">//如果p-&gt;data==x，就输出层数L</span></span><br><span class="line">cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">++L;<span class="comment">//每次遍历左孩子前就给层数+1</span></span><br><span class="line"><span class="built_in">leno</span>(p-&gt;lchild,x);</span><br><span class="line"><span class="built_in">leno</span>(p-&gt;rchild,x);</span><br><span class="line">--L;<span class="comment">//每次遍历完右孩子放回根结点前，就给层数-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据先序序列和中序序列构造二叉树-2">根据先序序列和中序序列构造二叉树</h3><blockquote><p>二叉树的先序序列存储在一维数组pre[L1,…,R1]中，中序序列存储在一维数组in[L2,…,R2]中，（L1,L2,R1,R2均表示了数组中元素的下标范围，元素为char型），假设二叉树中各结点中数据值不相同，请给出由pre[L1,…,R1]和in[L2,…,R2]构造二叉树的算法。</p></blockquote><p>分析：根据先序序列和中序序列构建二叉树：</p><ol><li><p>根据先序序列的第一个结点找到根结点</p></li><li><p>在中序序列中找到根结点的位置i，i左边就是左子树，i右边就是右子树：</p><p>在in中，从L2到i-1就是左子树，i+1到R2就是右子树</p><p>与之对应的左子树在pre的位置是L1+1到L1+（i-L2）,右子树的位置是L1+（i-L2）+1到R1</p></li><li><p>重复1，2两步，递归地构建左右子树，当L1-R1&lt;0（表示待处理序列的长度&lt;0）时递归结束</p></li></ol><p>这个算法的关键是确定左右子树的序列在pre和in数组中的下标。给出实例结合代码分析。</p><p>先序遍历pre：ABDECFG：（A（B（D）（E））（C（F）（G）））</p><p>中序遍历in：DBEAFCG：（（（D）B（E））A（（F）C（G）））</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由pre[L1,...,R1]和in[L2,...,R2]构造二叉树</span></span><br><span class="line"><span class="function">BTNode *<span class="title">createBT</span><span class="params">(<span class="type">char</span> pre[], <span class="type">char</span> in[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//L1&gt;R1说明处理的序列长度小于0，返回NULL，是递归结束的条件</span></span><br><span class="line">    <span class="keyword">if</span> (L1 &gt; R1) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//构造根节点</span></span><br><span class="line">BTNode *bt;</span><br><span class="line">bt = (BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//查找pre[L1]在in数组中的位置，用i记录下来</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = L2;i &lt;= R2;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[L1])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//给bt的各参数赋值</span></span><br><span class="line">bt-&gt;data = in[i];</span><br><span class="line">    <span class="comment">//递归构建bt的左右子树</span></span><br><span class="line">    <span class="comment">//pre[L1 + 1,...,L1 + i - L2]是左子树先序序列，pre[L1 + i - L2 + 1,..., R1]是右子树的先序序列</span></span><br><span class="line">    <span class="comment">//in[L2,..., i - 1]是左子树的中序序列，in[i + 1,..., R2]是右子树的中序序列</span></span><br><span class="line">bt-&gt;lchild = <span class="built_in">createBT</span>(pre, in, L1 + <span class="number">1</span>, L1 + i - L2, L2, i - <span class="number">1</span>);</span><br><span class="line">bt-&gt;rchild = <span class="built_in">createBT</span>(pre, in, L1 + i - L2 + <span class="number">1</span>, R1, i + <span class="number">1</span>, R2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建完成后返回根节点</span></span><br><span class="line"><span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-4 数组、矩阵与广义表</title>
      <link href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数组">数组</h1><ol><li><p>二维数组是元素为一元数组的一维数组。</p></li><li><p>数组一般采取顺序存储，最常见的两种操作是查找与修改。</p></li><li><p>二维数组元素的位置计算问题：假设有二维数组<code>a[m][n]</code>，数组从<code>a[0][0]</code>开始存储，问<code>a[i][j]</code>是数组中第几个元素？</p><p>分析：m表示a的行数，n表示a的列数，且每行有n个元素，每列有m个元素。</p><p><code>a[i][j]</code>表示的是数组a中第i+1行第j+1个元素，那么：</p><ul><li>行优先：<code>a[i][j]</code>前面有i行，那么<code>a[i][j]</code>前面就有<code>i*n+j</code>个元素，则<code>a[i][j]</code>就是第<code>i*n+j+1</code>个元素</li><li>列优先：<code>a[i][j]</code>前面有j列，那么<code>a[i][j]</code>前面就有<code>j*m+i</code>个元素，则<code>a[i][j]</code>就是第<code>j*m+i+1</code>个元素</li></ul></li></ol><h1 id="矩阵的压缩存储">矩阵的压缩存储</h1><h2 id="矩阵">矩阵</h2><p>A<sub>mn</sub>即为一个矩阵的逻辑表示，在数据结构中，可以用一个二维数组来存储。</p><ul><li><p>矩阵的转置</p><p>对于一个m×n的矩阵A[m][n]，其转置矩阵是一个n×m的矩阵B[n][m]，且有B[i][j]=A[j][i]，0&lt;=i&lt;n，0&lt;=j&lt;m。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//矩阵转置</span></span><br><span class="line"><span class="comment">//二维数组统一设定成maxSize*maxSize的尺寸，maxSize是事先定义好的宏常量，表示可能出现的数组的尺寸最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trsmat</span><span class="params">(<span class="type">int</span> A[][maxSize], <span class="type">int</span> B[][maxSize], <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//遍历A，按照转置的定义挨个取值赋给B</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">B[j][i] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>矩阵相加</p><p>矩阵相加按照C~i,j~=A~i,j~+B~i,j~的规则，这说明m×n的两个矩阵相加后大小仍是m×n。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//矩阵相加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addmat</span><span class="params">(<span class="type">int</span> C[][maxSize], <span class="type">int</span> A[][maxSize], <span class="type">int</span> B[][maxSize], <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩阵相乘</p><p>设A为m×n的矩阵，B为n×p的矩阵，那么称 的矩阵C为矩阵A与B的乘积，且只有在A矩阵的列数和B的行数相同时才有意义。矩阵C中的第i行第j列元素可以表示为：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/2021070901430016.png" alt="在这里插入图片描述"></p><p>那么自然地，C的大小为m×p：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//矩阵相乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mutmat</span><span class="params">(<span class="type">int</span> C[][maxSize], <span class="type">int</span> A[][maxSize], <span class="type">int</span> B[][maxSize], <span class="type">int</span> m, <span class="type">int</span> n,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; p; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">C[i][j] = A[i][k] * B[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="特殊矩阵与稀疏矩阵">特殊矩阵与稀疏矩阵</h2><h3 id="特殊矩阵">特殊矩阵</h3><ol><li><p>对称矩阵</p><p>矩阵中的元素满足<code>a[i][j]=a[j][i]</code>的矩阵称为对称矩阵。</p><p>例：假设有一个n×n的对称矩阵，第一个元素为<code>a[0][0]</code>，请用一种存储效率较高的存储方式将其存在一个一维数组中。</p><p>分析：对称矩阵满足主对角线上下方的元素对称相等，所以相同的元素只需要保存一份。那么所需要的一维数组的存储空间就是1+2+3+…+n个，即n(n+1)/2个元素。</p><p>按照行优先的顺序存储在一维数组中，矩阵元素与一元数组b中下标的对应关系为：</p><table><thead><tr><th style="text-align:center">a元素</th><th style="text-align:center">a[0][0]</th><th style="text-align:center">a[1][0]</th><th style="text-align:center">…</th><th style="text-align:center">a[n-1][0]</th><th style="text-align:center">…</th><th>a[n-1][1]</th></tr></thead><tbody><tr><td style="text-align:center">b下标</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">…</td><td style="text-align:center">(n-1)n/2</td><td style="text-align:center">…</td><td>n(n+1)/2-1</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a<span class="number">0</span><span class="number">1</span><span class="number">2</span>...n<span class="comment">//矩阵a的示意图，*表示元素</span></span><br><span class="line"><span class="number">0</span>*</span><br><span class="line"><span class="number">1</span>**</span><br><span class="line"><span class="number">2</span>***</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">n***...* <span class="comment">//取a的主对角线下半部分按照行优先的方式存储到一维数组b中</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b<span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>            <span class="built_in">n</span>(n<span class="number">+1</span>)/<span class="number">2</span><span class="number">-1</span></span><br><span class="line">* |*  *| * * *|...|****...*|</span><br></pre></td></tr></table></figure></li><li><p>三角矩阵</p><ul><li>上三角阵：矩阵下三角部分（不包含对角线）的元素全为c（c可以是0）的矩阵</li><li>下三角阵：矩阵上三角部分（不包含对角线）的元素全为c（c可以是0）的矩阵</li></ul><p>三角矩阵的存储方式与对称矩阵类似，但需要多存一个c元素，我们把它放在最后即可：</p><table><thead><tr><th style="text-align:center">a元素</th><th style="text-align:center">a[0][0]</th><th style="text-align:center">a[1][0]</th><th style="text-align:center">…</th><th style="text-align:center">a[n-1][0]</th><th style="text-align:center">…</th><th style="text-align:center">a[n-1][1]</th><th style="text-align:center">c</th></tr></thead><tbody><tr><td style="text-align:center">b下标</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">…</td><td style="text-align:center">(n-1)n/2</td><td style="text-align:center">…</td><td style="text-align:center">n(n+1)/2-1</td><td style="text-align:center">n(n+1)/2</td></tr></tbody></table></li><li><p>对角矩阵</p><p>如图是一个三对角矩阵，它的特点是除了主对角线以及其上下两条斜线上的元素外，其他元素均为c（c可以是0）：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210709013935624.png" alt="请添加图片描述"></p><p>它的特点是除了首行和末行元素个数为2外，其余每行的元素个数都为3，据此来计算将其转化为一元数组后的下标问题。</p></li></ol><h3 id="稀疏矩阵">稀疏矩阵</h3><p>目前对于稀疏矩阵还没有一个明确统一的定义，在严版数据结构中的定义：</p><ol><li>相同的元素或者零元素在矩阵中的分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵。</li></ol><p>国外对于稀疏矩阵的普遍定义为：</p><ol start="2"><li>矩阵中绝大多数元素都为0的矩阵称为稀疏矩阵。</li></ol><h4 id="稀疏矩阵的顺序存储">稀疏矩阵的顺序存储</h4><p>稀疏矩阵的绝大部分元素都没有必要存储，如何高效的存储剩余的元素就是稀疏矩阵压缩存储的关键。</p><p>常用的稀疏矩阵的顺序存储方法为：三元组表示法以及伪地址表示法。</p><ol><li><p>三元组表示法</p><p>三元组数据结构的每个元素都含有三个变量：分别存储矩阵元素的值、行下标、列下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//值</span></span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//行</span></span><br><span class="line">    <span class="type">int</span> j;<span class="comment">//列</span></span><br><span class="line">&#125;Trimat;</span><br></pre></td></tr></table></figure><p>假设有一个4阶的稀疏矩阵A如下图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"> ———————————</span><br><span class="line"><span class="number">0</span>|<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>|<span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span>|<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span>|<span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>里面含有5个非0元素，将其转换为三元组表示法即为：</p><table><thead><tr><th style="text-align:center">val</th><th style="text-align:center">i</th><th style="text-align:center">j</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">1</td></tr></tbody></table><p>可以看到，5个元素我们用了6个三元组结点，因为默认第1个结点的val存储非零元素的个数，i存储原矩阵的行数，j存储原矩阵的列数。以A[0][4]元素1为例，它的值为1，行坐标为0，列坐标为3，那么:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trimat[<span class="number">0</span>].val=<span class="number">1</span>;</span><br><span class="line">trimat[<span class="number">0</span>].i=<span class="number">0</span>;</span><br><span class="line">trimat[<span class="number">0</span>].j=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>伪地址法</li></ol><p>伪地址法即元素在矩阵中按照行优先或者列优先存储的相对位置。（第几个元素的意思）</p><p>伪地址法存储时每个元素只需要两个变量，即：值和伪地址。</p><p>比如上述矩阵A的最后一个非零元素2，按照行优先的规则它在矩阵中的位置就是i*4+j+1，即3*4+1+1=14。</p><p>对于一个m*n的稀疏矩阵a，a[i][j]的伪地址计算方法为（行优先）：n*i+j+1。</p></li></ol><h4 id="稀疏矩阵的链式存储">稀疏矩阵的链式存储</h4><p>最常见的稀疏矩阵的链式存储方法就是：邻接表法和十字链表法。</p><p>邻接表法就是将矩阵中的每一行的非零元素串成一个链表，每个链表结点中含有两个分量，一个是元素值，一个是列号。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210709013935726.png" alt="请添加图片描述"></p><p>在稀疏矩阵的十字链表存储结构中，矩阵的每一行用一个带头结点的链表表示， 每一列也用 一个带头结点的链表表示， 这种存储结构中的链表结点都有5个分量： 行分量、 列分量、数据域分量、指向下方结点的指针、指向右方结点的指针。</p><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210709013935641.png" alt="请添加图片描述"></p><h1 id="广义表">广义表</h1><p>广义表： 表元素可以是原子或者广义表的一种线性表的扩展结构。</p><ul><li><p>广义表的长度： 为表中最上层元素的个数</p></li><li><p>广义表的深度： 为表中括号的最大层数</p></li><li><p>表头 (Head) 和表尾 (Tail)：当广义表非空时， 第 个元素为广义表的表头， 其余元素组成的表是 广义表的表尾。</p></li></ul><p>举例说明：</p><ol><li><p><code>A=( )</code>, A 是个空表，长度为 0，深度为 1。</p></li><li><p><code>B=(d, e)</code>, B 的元素全是原子，即 d 和 e，长度为 2，深度为 1。</p></li><li><p><code>C=(b, (c, d))</code>, C 有两个元素，分别是原子 b 和另一个广义表(c, d)，长度为 2，深度为 2。</p></li></ol><p>4)<code>D=(B, C)</code>, D 的元素全是广义表，即 B 和 C， 长度为 2， 深度为 3。</p><p>由此可见，一个广义表的子表可以是其他已经定义的广义表的引用。</p><p>5)<code>E=(a, E)</code>, E 有两个元素，分别是原子 a 和它本身，长度为 2。</p><p>由此可见，广义表可以是递归定义的，展开E可以得到(a,(a, (a, (a, · · ·)))) ，是无限深的广义表。</p><h2 id="广义表的头尾链表存储结构">广义表的头尾链表存储结构</h2><ol><li>原子结点（2个域）：标记域、数据域</li><li>广义表结点（3个域）：标记域、头指针域、尾指针域</li></ol><p>其中，对于广义表结点来说，</p><ol><li>标记域用于区分当前结点是原子（用0来表示）还是广义表（用1来表示）；</li><li>头指针域指向原子结点或者广义表结点；</li><li>尾指针域为空或者指向本层中的下一个广义表结点。</li></ol><p>图5-7展示了1)到5)中广义表的头尾链表存储结构的存储情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=()</span><br><span class="line">B=(d,e)</span><br><span class="line">C=(b,(c,d))</span><br><span class="line">D=(B,C)</span><br><span class="line">E=(a,E)</span><br></pre></td></tr></table></figure><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210709013935724.png" alt="请添加图片描述"></p><h2 id="广义表的扩展线性表存储结构">广义表的扩展线性表存储结构</h2><p>，其中也有两种结点，即原子结点和广义表结点。</p><ul><li><p>原子结点有3个域：标记域、数据域和尾指针域；</p></li><li><p>广义表结点也有3个域：标记域、头指针域与尾指针域。</p></li></ul><p>其中，标记域区分当前结点是原子（用0来表示），还是广义表（用1来表示）。</p><p>扩展线性表存储结构类似带头结点的单链表存储结构，每一个子表都有一个不存储信息的头结点来标记其存在。</p><p>头尾链表存储结构类似于不带头结点的单链表存储结构。</p><p>图5-8展示了1)到5)中广义表的扩展线性表存储结构的存储情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=()</span><br><span class="line">B=(d,e)</span><br><span class="line">C=(b,(c,d))</span><br><span class="line">D=(B,C)</span><br><span class="line">E=(a,E)</span><br></pre></td></tr></table></figure><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210709013935733.png" alt="请添加图片描述"></p><h1 id="练习题">练习题</h1><ol><li><p>设数组A[0, ···, n-1]的n个元素中有多个零元素，设计一 个算法，将 A 中所有的非零元素依次移动到A数组的前端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组A中的非0字符移动到数组靠前的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">moveElem</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">temp = A[j];</span><br><span class="line">A[j] = A[i];</span><br><span class="line">A[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于浮点型数组A[0, ···, n-1], 试设计实现下列运算的递归算法。</p><p>(1)求数组A中的最大值。<br>(2)求数组中n个数之和。<br>(3)求数组中n个数的平均值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*(1)分析：如果数组长度为1, 则可以直接返回最大值；否则将数组A视为两部分，即A[O]和A[l...,n-1]。如果A[0]大于A[1,...,n-1]中的最大值，则返回A[0], 反之按照上一步的方法递归地处理A[1]和A[2,...,n-1]。*/</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getMax</span><span class="params">(<span class="type">float</span> A[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> max;</span><br><span class="line"><span class="keyword">if</span> (i == j) &#123;</span><br><span class="line"><span class="keyword">return</span> A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">max = <span class="built_in">getMax</span>(A, i + <span class="number">1</span>, j);</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; max) <span class="keyword">return</span> A[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="built_in">getMax</span>(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归求和，思路与上面类似</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getSum</span><span class="params">(<span class="type">float</span> A[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> sum;</span><br><span class="line"><span class="keyword">if</span> (i == j) &#123;</span><br><span class="line"><span class="keyword">return</span> A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sum = <span class="built_in">getSum</span>(A, i + <span class="number">1</span>, j);</span><br><span class="line"><span class="keyword">return</span> A[i] + sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">getSum</span>(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归求平均值</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">getAverage</span><span class="params">(<span class="type">float</span> A[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> ave;</span><br><span class="line"><span class="keyword">if</span> (i == j) &#123;</span><br><span class="line"><span class="keyword">return</span> A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ave = <span class="built_in">getAverage</span>(A, i + <span class="number">1</span>, j);</span><br><span class="line"><span class="keyword">return</span> (A[i] + (j - i) * ave) / (j - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">getAverage</span>(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>试设计一 个算法，将数组 A [0, · · ·, n-1]中所有奇数移到偶数之前。要求不另增加存储空间，且时间复杂度为O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组 A [0, · · ·, n-1]中所有奇数移到偶数之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (a[i] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; i &lt; j)<span class="comment">//a从左往右遇到的第一个奇数</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span> (a[j] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i &lt; j)<span class="comment">//a从右往左遇到的第一个偶数</span></span><br><span class="line">j--;</span><br><span class="line"><span class="comment">//交换后挪动i和j，向数组中间靠拢，当i==j时跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">i++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-3 串</title>
      <link href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E2%80%94%E2%80%94%E4%B8%B2/"/>
      <url>/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E2%80%94%E2%80%94%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="串数据类型的定义">串数据类型的定义</h1><h2 id="串的定义">串的定义</h2><ol><li>串是由0个或多个字符组成的有限序列。</li><li>串中字符的个数称为串的长度，0个字符的串称为空串。</li><li>串中任意连续的字符组成的子序列称为子串，包含子串的串称为主串。</li><li>串是一种限定元素为字符的线性表。</li><li>串与线性表最大的区别是操作集不同，线性表主要是针对某一元素操作，而串则主要针对子串操作。</li></ol><h2 id="串的存储结构">串的存储结构</h2><ul><li>定长顺序存储表示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Str</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[maxSize<span class="number">+1</span>];<span class="comment">//maxSize为已定义的常量，表示串的最大长度。+1是以为多出一个结束标记`\0`</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;Str;</span><br></pre></td></tr></table></figure><p>虽然多了一个结束标记’\0’，但是计算长度length时并不纳入计算范围。</p><ul><li>变长分配存储表示（动态分配存储表示）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Str</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;<span class="comment">//指向动态分配存储空间首地址的字符指针</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;Str;</span><br></pre></td></tr></table></figure><p>使用动态分配时，需要使用malloc()函数来分配一个长度为length，类型为char的连续存储空间：<code>str.ch=(char*)malloc(sizeof(char)*(n+1))</code>作为串的基地址。</p><h2 id="串的基本操作">串的基本操作</h2><ol><li><p>赋值操作</p><p>串是一个数组，这里的赋值操作不是指对某一位置处的赋值，而是将一个字符串（数组）的值赋给另一个数组。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将ch赋值给str</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strAssign</span><span class="params">(Str&amp; str, <span class="type">char</span>* ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.释放原串空间</span></span><br><span class="line"><span class="keyword">if</span> (str.ch) <span class="built_in">free</span>(str.ch);</span><br><span class="line"><span class="comment">//2.求ch的长度</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *c = ch;</span><br><span class="line"><span class="keyword">while</span> (*c) &#123;<span class="comment">//c值为&#x27;\0&#x27;结束循环</span></span><br><span class="line">++len;</span><br><span class="line">++c;<span class="comment">//由于c一开始指向的是一片连续存储空间的首地址，那么相邻存储单元的地址就相差1，这里c++就相当于指针c指向ch中下一个字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果ch的长度为0，那么直接返回空串即可</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">str.ch = <span class="literal">NULL</span>;</span><br><span class="line">str.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4.ch的长度不为0，开始赋值</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//先分配存储空间，返回申请到的连续存储空间的首地址，+1是为了存放&#x27;\0&#x27;</span></span><br><span class="line">str.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(len + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (str.ch == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//申请存储空间失败</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">c = ch;<span class="comment">//上面测量长度时，c已经指向了ch的最后一个字符，这里要将指针重新指向数组的头部</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= len;i++, c++) &#123;<span class="comment">//显然循环了len+1次，因为&#x27;\0&#x27;也要赋值过来</span></span><br><span class="line">str.ch[i] = *c;</span><br><span class="line">&#125;</span><br><span class="line">str.length = len;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>int strAssign(Str&amp; str, char* ch)&#123;...&#125;</code>的使用：</p><p><code>strAssign(str,&quot;abcde&quot;)</code>此句执行后，str.ch的值就是abcde，str.length的值就是5。</p><ol start="2"><li>获取字符串的长度</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果串的定义中有定义length的话，直接返回length</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getStrLen</span><span class="params">(Str str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有定义length，可以通过上面的方法计算长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getStrLen</span><span class="params">(Str str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *c = str.<span class="type">char</span>;</span><br><span class="line"><span class="keyword">while</span> (*c) &#123;</span><br><span class="line">++len;</span><br><span class="line">++c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>串的比较</li></ol><p>设两串 A和 B 中的待比较字符分别为 a 和 b：</p><p>如果 a 的 ASCII码小于 b 的 ASCII 码， 则返回 A 小于B 的标记（一个负数）；</p><p>如果 a 的 ASCII 码大于b 的 ASCII 码， 则返回 A 大于B 的标记（一个正数）；</p><p>如果 a 的 ASCII 码等于b 的 ASCII 码， 则继续下一对字符；</p><p>经过上述比较没有比较出A和B大小的情况下，规定先结束的字符串为较小串，两串同时结束则A与B相等（返回0）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用s1去和s2比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strCompare</span><span class="params">(Str s1,Str s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s<span class="number">1.l</span>ength &amp;&amp; i&lt;s<span class="number">2.l</span>ength; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s<span class="number">1.</span>ch[i] != s<span class="number">2.</span>ch[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> s<span class="number">1.</span>ch[i] - s<span class="number">2.</span>ch[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> s<span class="number">1.l</span>ength - s<span class="number">2.l</span>ength;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.字符的比较、加减都是在操作它们的ASCII码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.for循环里发现某一位置s1和s2对应的字符的ASCII码不相等，则返回s1.ch[i] - s2.ch[i]，有2种情况：</span></span><br><span class="line"><span class="comment">s1.ch[i] - s2.ch[i] &lt; 0，则s1 &lt; s2</span></span><br><span class="line"><span class="comment">s1.ch[i] - s2.ch[i] &gt; 0，则s1 &gt; s2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.for循环里面没有return,则在循环外返回s1.length - s2.length，有3种可能结果：</span></span><br><span class="line"><span class="comment">        s1.length - s2.length == 0,则二者同时结束循环且所有字符相等，s1 == s2</span></span><br><span class="line"><span class="comment">        s1.length - s2.length &lt; 0,则s1先结束循环，s1 &lt; s2</span></span><br><span class="line"><span class="comment">        s1.length - s2.length &gt; 0,则s2先结束循环，s1 &gt; s2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>串的拼接</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">concat</span><span class="params">(Str&amp; str, Str&amp; str1, Str&amp; str2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果str.ch非NULL，就把原有的空间释放，并给ch赋NULL</span></span><br><span class="line"><span class="keyword">if</span> (str.ch) &#123;</span><br><span class="line"><span class="built_in">free</span>(str.ch);</span><br><span class="line">str.ch = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//申请一片足以放下str1、str2两个字符串的空间,+1是为了放结束符&#x27;\0&#x27;</span></span><br><span class="line">str.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(str<span class="number">1.l</span>ength + str<span class="number">2.l</span>ength + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (!str.ch)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//申请空间失败</span></span><br><span class="line"><span class="comment">//申请成功，开始拼接s1</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str<span class="number">1.l</span>ength) &#123;</span><br><span class="line">str.ch[i] = str<span class="number">1.</span>ch[i];</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//拼接s2</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= str<span class="number">2.l</span>ength) &#123;<span class="comment">//&lt;=legth循环了length+1次，把&#x27;\0&#x27;也赋值过来</span></span><br><span class="line">str.ch[i + j] == str<span class="number">2.</span>ch[j];</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//修改str的参数值length</span></span><br><span class="line">str.length = str<span class="number">1.l</span>ength + str<span class="number">2.l</span>ength;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>获取子串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//截取字符串</span></span><br><span class="line"><span class="comment">//从字符串str的pos位置开始，截取长度为len的字符串赋值给sbustr，成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subString</span><span class="params">(Str&amp; substr, Str str, <span class="type">int</span> pos, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">//校验输入值</span></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span> || len &gt;= str.length || len&lt;<span class="number">0</span> || len&gt;str.length - pos) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放掉ch的空间</span></span><br><span class="line"><span class="keyword">if</span> (substr.ch) &#123;</span><br><span class="line"><span class="built_in">free</span>(substr.ch);</span><br><span class="line">substr.ch = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始截取</span></span><br><span class="line"><span class="comment">//case1——len==0</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">substr.ch = <span class="literal">NULL</span>;</span><br><span class="line">substr.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//case2——len!=0</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//申请空间</span></span><br><span class="line">substr.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (substr.ch == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//核心，截取字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos, j = <span class="number">0</span>;i &lt; pos + len;i++, j++) &#123;</span><br><span class="line">substr.ch[j] = str.ch[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">substr.ch[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">substr.length = len;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>串清空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串清空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clearString</span><span class="params">(Str &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.ch) &#123;</span><br><span class="line"><span class="built_in">free</span>(str.ch);</span><br><span class="line">str.ch = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">str.length = <span class="number">0</span>;</span><br><span class="line">retrn <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法">KMP算法</h1><h2 id="简单模式匹配">简单模式匹配</h2><p>用两个指针i和j分别表示主串和模式串中的将要进行比较的字符下标，指针k用来记录上一趟匹配主串的开始位置；</p><p>从主串和模式串的第一个字符开始开始匹配，如果相等，继续比较下一个字符，直到匹配成功，或某一位置字符不匹配；</p><p>如果中途某一位置字符不匹配，i 回溯到这一趟比较最开始的位置（k），从这个位置的下一个位置和模式串第一个字符（j回溯到1）比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单模式匹配，要求返回模式串在主串中的位置（首个字符的位置）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(Str str, Str substr)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> k = i;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= str.length &amp;&amp; j &lt;= substr.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.ch[i] == substr.ch[j]) &#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">i = k++; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt; substr.length) <span class="comment">//匹配成功时，j=substr.length+1</span></span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法的时间复杂度：O(mn),m和n分别表示主串和模式串的长度</span></span><br></pre></td></tr></table></figure><h2 id="KMP算法匹配">KMP算法匹配</h2><h3 id="next-数组的获取">next[]数组的获取</h3><p>KMP算法的关键就是next[]的获取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getNext：给定字符串s,求s的next[]数组。这里默认串从s.ch[]的1位置开始存储,同样的，next[]也是从1开始。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(Str s, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//规定next[1]=0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || s.ch[i] == s.ch[j]) &#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* while循环表示即从1开始求模式串的next数组：</span></span><br><span class="line"><span class="comment">首次进入循环，此时i==1,j==0，且next[1]=0已知，不需要比较，直接令next[2]=1；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">假设现在s的next数组已经求到了i位置，next[i]==j已知（i前面每一个位置的next值都可知），怎么求next[i+1]？</span></span><br><span class="line"><span class="comment">分析：next[i+1]等于s.ch[1]~s.ch[i]的最大公共前后缀长度+1；</span></span><br><span class="line"><span class="comment"> next[i]==j已知，即s.ch[1]~s.ch[i-1]的最大公共前后缀长度=j-1；</span></span><br><span class="line"><span class="comment">那么此时只要看s.ch[i]和s.ch[j]的值就可以判断：</span></span><br><span class="line"><span class="comment">1.如果s.ch[i]==s.ch[j]，那么自然next[i+1]=j+1;</span></span><br><span class="line"><span class="comment">2.如果s.ch[i]!=s.ch[j]，此时将求next[i+1]的问题视为模式匹配问题，</span></span><br><span class="line"><span class="comment">即前缀s.ch[1]...s.ch[j]去和后缀s.ch[i-j+1]...s.ch[i]匹配，</span></span><br><span class="line"><span class="comment">那么此时应将j指针回溯到j=next[j],再令s.ch[j]去和s.ch[i]比较，</span></span><br><span class="line"><span class="comment">重复上述的比较过程，直到出j==0或者二者相等。</span></span><br><span class="line"><span class="comment">（记住这个处理过程即可，原理网上找图片更好理解）</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">j==0说明：</span></span><br><span class="line"><span class="comment">1.如果是首次进入循环，此时i==1,j==0，规定next[1]=0。此时直接令next[2]=1</span></span><br><span class="line"><span class="comment">（实际上不管任何字符串，它的第一个字符和第二个字符的next值都应该是1，</span></span><br><span class="line"><span class="comment">因为它们的公共前后缀都是0，只不过这里为了方便运算，规定第一个字符的next为0）；</span></span><br><span class="line"><span class="comment">2.非首次进入循环，则说明此时前缀s.ch[1]...s.ch[j]去和后缀s.ch[i-j+1]...s.ch[i]</span></span><br><span class="line"><span class="comment">没有公共前后缀，那么next[i+1]=j+1=0+1=1；</span></span><br><span class="line"><span class="comment">则此时next[i+1]已知，再接着去求next[i+1+1]。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="KMP算法-2">KMP算法</h3><p>i和j表示主串和模式串上字符下标；</p><p>取主串和模式串的字符从位置1开始挨个进行比较，如果相等，就接着比较下一个字符；</p><p>如果不相等，i不变，取模式串此位置j上的next[j]，用模式串next[j]位置上的字符去和主串上的字符i接着比较。</p><p>特殊的，这里的j=0只针对next[1]，实际上，在next数组中，只有next[1]是等于0的。j=0时，指针i和j都往后挪一位，即若主串i位置和模</p><p>式串第一个字符不相等，就从主串中的i+1位置继续与模式串第一个字符比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KMP，substr是模式串，next[]是它的next数组，str是主串,字符串数组和next数组均是从1开始存储</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(Str str, Str substr, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (i &lt;= str.length &amp;&amp; j &lt;= substr.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || str.ch[i] == substr.ch[j]) &#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j]; <span class="comment">//与简单匹配求解最大的不同之处，i不回溯，只回溯j</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (j &gt; substr.length) </span><br><span class="line"><span class="keyword">return</span> i - substr.length;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//KMP算法的时间复杂度（包含求next数组的过程）：O(m+n)，m和n分别表示主串和模式串的长度</span></span><br></pre></td></tr></table></figure><ol><li>KMP算法的关键就在于求取模式串的next[]，手动计算时，next[i]等于模式串的子串（位置1到位置i-1）的最大公共前后缀长度+1；</li><li>KMP的匹配算法和简单匹配算法形式上很相似，KMP算法的优势是建立在模式串中存在大量”部分匹配“基础上，如果模式串每个字符都和其他字符不同（每个字符的next值都为1），那么KMP算法和简单匹配（暴力匹配）的时间复杂度没有区别。</li><li>KMP算法的特点是主串中的i不需要回溯，这意味着对于规模大的外存中字符串的匹配操作可以分段进行，每次可以读取部分进入内存比较，完成后写回外存，且不需要在后续比较中再读入，减少了I/O操作，提高了效率。这是KMP算法的优势之一。</li></ol><h3 id="KMP算法的改进">KMP算法的改进</h3><p>求nextval[]的一般步骤：</p><ol><li>当i=1时，next[i]=0，作为特殊标记，这一点与next数组没有区别</li><li>从左往右，当i不为1时（next[i]=j），如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ch_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 不等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">ch_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，则nextval[i]=j=next[i]</li><li>从左往右，当i不为1时（next[i]=j），如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ch_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">ch_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，则nextval[i]=next[j]=next[next[j]]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(Str s, <span class="type">int</span> nextval[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || s.ch[i] == s.ch[j]) &#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line"><span class="comment">//nextval与next不同之处,这一块原本是next的赋值区域，所以只需要改动这里</span></span><br><span class="line"><span class="keyword">if</span> (s.ch[i] != s.ch[j]) </span><br><span class="line">nextval[i] = j;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">nextval[i] = nextval[j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-2 栈与队列</title>
      <link href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列">栈与队列</h1><h2 id="结构体定义">结构体定义</h2><ol><li>顺序栈定义</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[maxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><ol start="2"><li>链栈结点定义</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure><ol start="3"><li>顺序队列定义</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[maxSize];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><ol start="4"><li>链队定义</li></ol><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210703204401512.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链队类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QNode *front;</span><br><span class="line">    QNode *rear;</span><br><span class="line">&#125;LiQueue;</span><br></pre></td></tr></table></figure><h2 id="栈的应用">栈的应用</h2><h3 id="顺序栈的应用">顺序栈的应用</h3><ol><li>C语言里算术表达式中的括号只有小括号。编写算法，判断一 个表达式中的括号是否正确配对，表达式已经存入字符数组a[]中，表达式中的字符个数为n。</li></ol><blockquote><p>分析：遍历算数表达式的字符数组，遇到左括号就入栈，遇到右括号就出栈。如果遍历完后栈非空或者出栈时发现栈空，则说明不匹配。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化栈,规定top为-1时栈空</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[maxsize];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="comment">//碰到左括号就入栈</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;(&#x27;</span>)<span class="built_in">stack</span>[++top]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="comment">//碰到右括号就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//出栈时栈空就说明不匹配</span></span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                top--;<span class="comment">//出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历结束，栈空，则说明左括号和右括号数目相等</span></span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：什么样的问题适合用栈解决？</p><p>答：在解决问题的过程中，如果碰到一个子问题，根据现有的条件没有办法解决，就可以先把它记下来，等到以后可以解决时再返回来解决。<strong>栈具有记忆的功能，这是其FILO（先进后出）的特性决定的</strong>。</p><ol start="2"><li>前缀表达式、中缀表达式、后缀表达式</li></ol><blockquote><p>1.中缀表达式就是常见的运算表达式，如 (3+4)×5-6</p><p>2.<strong>前缀表达式</strong>又称波兰式，前缀表达式的运算符位于操作数之前 比如:<strong>- × + 3 4 5 6</strong></p><p>前缀表达式的计算机求值：<strong>从右至左</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（<strong>栈顶元素 op 次顶元素</strong>），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p><p>3.<strong>后缀表达式</strong>又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后</p><p>后缀表达式计算机求值：与前缀表达式类似，只是顺序是<strong>从左至右</strong>，比如<strong>3 4 + 5 × 6 -</strong></p></blockquote><p>编写一 个函数，求后缀式的数值，其中后缀式存于一 个字符数组a中，a中最后一 个字符为&quot;\0&quot;, 作为结束符，并且假设后缀式中的数字都只有一 位。本题中所出现的除法运算，皆为整除运算，如2/3结果为0、3/2结果为1。</p><blockquote><p>分析：从左到右扫描a，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数（连续出栈两次），用运算符对它们做相应的计算（<strong>次顶元素 op 栈顶元素</strong> ），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//op函数用来运算：栈顶元素a Op 次顶元素b</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">op</span><span class="params">(<span class="type">int</span> a,<span class="type">char</span> Op,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> a-b;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> a*b;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//除数为0，输入错误</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后缀式计算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">com</span><span class="params">(<span class="type">char</span> a[])</span>&#123;</span><br><span class="line">    <span class="comment">//a,b为每次运算时的数字，c用来保存结果</span></span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="comment">// 注意元素类型必须为整型，不能为char型，虽然操作数只有一位，但是在运算的过程中会产生多位数</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span>[maxSize];<span class="comment">//初始化栈</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//从左往右遍历数组，遇到&#x27;\0&#x27;时结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;a[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//字符是数字，入栈</span></span><br><span class="line">        <span class="keyword">if</span>( a[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; a[i]&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="comment">//a[i]-&#x27;0&#x27;将字符型转换为整型</span></span><br><span class="line">            <span class="built_in">stack</span>[++top]=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//字符是运算符号，连续出栈两次并计算</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//注意第二个在入栈时后入栈，即栈顶元素是第二个操作数，次顶元素是第一个操作数</span></span><br><span class="line">            b=<span class="built_in">stack</span>[top--];</span><br><span class="line">            a=<span class="built_in">stack</span>[top--];</span><br><span class="line">            <span class="comment">//运算并将结果入栈</span></span><br><span class="line">            c=op(a,a[i],b)</span><br><span class="line">            <span class="built_in">stack</span>[++top]=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>0~9</strong>的整型a和字符型的相互转换，比如：</li></ul><p><code>char b='5'; int a=b-'0'; </code>那么此时<code>a=5;</code>;<br><code>int a=1 ; char b=a+'0'; </code>那么此时<code>b='1';</code></p><h3 id="链栈的应用">链栈的应用</h3><p>用不带头结点的单链表存储链栈，设计初始化栈，判空，进出栈等算法。</p><ol><li>初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(LNode *&amp;lst)</span>&#123;</span><br><span class="line">    lst = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>判空</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LNode *lst)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lst==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>进栈</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LNode *&amp;lst,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">//申请新的结点空间并赋值</span></span><br><span class="line">    LNode *p=(LNode*)<span class="built_in">malloc</span>(sizeod(LNode));</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    <span class="comment">//头插法插入无头结点的链表</span></span><br><span class="line">    p-&gt;next=lst;</span><br><span class="line">    lst=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>出栈</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈，用x记录其值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LNode *&amp;lst,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lst==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LNode *p=lst;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    lst=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序队与循环队列">顺序队与循环队列</h2><ul><li>顺序队列的结构体定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[maxSize];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><ol><li><p>循环队列的由来</p><blockquote><p>在顺序队中，通常让<strong>队尾指针rear指向刚进队的元素位置</strong>，让<strong>队首指针front指向刚出队的元素位置</strong>。因此，元素进队的时候，rear要向后移动；元素出队的时候，front也要向后移动。这样经过一 系列的出队和进队操作以后，两个指针最终会达到数组末端maxSize-1处。虽然队中已经没有元素，但仍然无法让元素进队，这就是所谓的“<strong>假溢出</strong>“。要解决这个问题，可以把数组弄成一 个环，让 rear和 front沿着环走，这样就永远不会出现两者来到数组尽头无法继续往下走的情况，这样就产生了循环队列。</p></blockquote></li></ol><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/20210703204438961.png" alt="在这里插入图片描述"></p><p>（1）<strong>front指向队首元素的前一个位置</strong>（上一此出队的元素位置）；</p><p>​  <strong>rear指向队尾元素</strong>。指针的移动：</p><ul><li><p>出队，移动队首指针：<code>front=(front+1)%maxSize </code>（maxSize是数组长度）</p></li><li><p>入队，移动队尾指针：<code>rear=(rear+1)% maxSize</code></p></li></ul><p>（2）队空：<code>qu.rear==qu.front</code></p><p>（3）队满：<code>(qu.rear+1)%maxSize==qu.front</code>（循环队列必须损失一个存储空间，用来区分队空与队满）</p><p>如果不想损失存储空间，可另外设置一个t</p><p>（4）x入队：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qu.rear=(qu.rear+<span class="number">1</span>)% maxSize;</span><br><span class="line">qu.data[qu.rear]=x;</span><br></pre></td></tr></table></figure><p>（5）x出队：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qu.front=(qu.front+<span class="number">1</span>)% maxSize;</span><br><span class="line">x=qu.data[qu.front];</span><br></pre></td></tr></table></figure><p>（6）元素个数：<code>(rear - front + maxSize) % maxSize</code></p><ol start="2"><li><p>循环队列初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(SqQueue &amp;qu)</span>&#123;</span><br><span class="line">qu.front=qu.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环队列的判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(SqQueue qu)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qu.front==qu.rear)&#123;<span class="comment">//循环队列的判空条件：首尾指针重合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环队列的进队算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(SqQueue &amp;qu,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((qu.rear+<span class="number">1</span>)%maxSize==qu.front) <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队未满，先动指针再存值</span></span><br><span class="line">    qu.rear=(qu.rear+<span class="number">1</span>)% maxSize;</span><br><span class="line">qu.data[qu.rear]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环队列的进队算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(SqQueue &amp;qu,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qu.rear==qu.front) <span class="comment">//队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//队非空，先动指针再取值</span></span><br><span class="line">    qu.front=(qu.front+<span class="number">1</span>)% maxSize;</span><br><span class="line">x=qu.data[qu.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>（2）循环队列补充知识点</p><ol><li><p>当从队尾插入新元素以及从对头删除新元素时，我们都知道对应的rear与front是顺时针转的，对应的语句是：</p><p><code>q.rear=(q.rear+1)%maxSize</code>或者<code>q.front=(q.front+1)%maxSize</code>；</p><p>如果我们规定队首也可以插入新元素，队尾也可以删除元素，那么对应的front和rear就是逆时针转的，这个时候对应的语句就应该是：</p><p><code>q.rear=(q.rear-1+maxSize)%maxSize</code>或者<code>q.front=(q.front-1+maxSize)%maxSize</code>。</p><p>二者的效果刚好相反，这是关于循环队列最重要的语句。</p></li><li><p>上面提到，要想分辨队空还是队满，我们需要损失一个存储空间，使得队空与队满得以分清：</p><p>队空：<code>qu.rear==qu.front</code></p><p>队满：<code>(qu.rear+1)%maxSize==qu.front</code></p><p>这是因为仅仅依靠<code>q.rear==q.front</code>我们无法判断队空和队满，主要原因是我们没法判断最后一次操作时到底是入队还是出队。如果最后一次操作是入队，那么当rear和front重合时，必然是队满，反之队空。对此，可以设立一个tag，当<code>q.rear==q.front</code>时，规定tag为0时为队空，tag为1时为队满。tag初始值为0，每次入队时，我们就把tag设为1，每次出队时就把tag设为0，这样就可以在不损失存储空间的情况下来判断队空和队满了。</p><p>队空：<code>qu.rear==qu.front &amp;&amp; tag==0</code></p><p>队满：<code>qu.rear==qu.front &amp;&amp; tag==1</code></p></li></ol><h2 id="链队">链队</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LAxeT1NB-1624983506505)(C:\Users\76583\AppData\Roaming\Typora\typora-user-images\image-20210625234951443.png)]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链队类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QNode *front;</span><br><span class="line">    QNode *rear;</span><br><span class="line">&#125;LiQueue;</span><br></pre></td></tr></table></figure><ul><li><p>队空：<code>lqu-&gt;rear==NULL</code>或<code>lqu-&gt;front==NULL</code></p></li><li><p>队满：在内存无限大情况下不存在队满的情况</p></li><li><p>元素进队：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lqu-&gt;rear-&gt;next=p;</span><br><span class="line">lqu-&gt;rear=p;</span><br></pre></td></tr></table></figure></li><li><p>元素出队：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=lqu-&gt;front;</span><br><span class="line">lqu-&gt;front=p-&gt;next;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure></li></ul><ol><li>链队的初始化算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(LiQueue *&amp;lqu)</span>&#123;</span><br><span class="line">    lqu=(LiQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    lqu-&gt;front=lqu-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>链队的判空算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isQueueEmpty</span><span class="params">(LiQueue *lqu)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;rear==<span class="literal">NULL</span>||lqu-&gt;front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>链队的入队算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(LiQueue *lqu,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    QNode *p=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;rear==<span class="literal">NULL</span>)&#123;<span class="comment">//入队时，如果队空，需要特殊处理</span></span><br><span class="line">        luq-&gt;front=lqu-&gt;rear=p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lqu-&gt;rear-&gt;next=p;</span><br><span class="line">        lqu-&gt;rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>链队的出队算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deQueue</span><span class="params">(LiQueue *lqu,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;rear==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    QNode *p=lqu-&gt;front;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;front==lqu-&gt;rear)&#123;<span class="comment">//出队时如果队中只剩一个元素，需要特殊处理</span></span><br><span class="line">        lqu-&gt;front=lqu-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        luq-&gt;front=p-&gt;next;</span><br><span class="line">        x=p-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享栈与双端队列">共享栈与双端队列</h2><ol><li><p>共享栈</p><p>为了提高内存空间的利用率、减少溢出的可能性，使用两个栈共享一片连续的内存空间，则这两个栈的栈底分别位于存储空间的两端（因为顺序栈的栈底是不会变的），那么两个栈的栈顶则一定位于存储空间内，当两栈顶相遇时，则说明存储空间已满。</p></li><li><p>双端队列</p><p>双端队列是一种插入和删除操作在两端均可以进行的线性表。可以把它看做是栈底连在一起的两个栈，两个栈顶则向两端延伸。</p></li></ol><h3 id="共享栈的实现">共享栈的实现</h3><p>共享栈的初始状态：规定s0的栈底在左侧<code>0</code>处，s1的栈底在右侧<code>(maxSize-1)</code>处，栈顶在<code>0~maxSize-1</code>之间变动；</p><p>s0栈顶的初始值为-1，s1栈顶的初始值为maxSize，栈内元素个数0；top[0]为s0栈顶，top[1]s1栈顶；</p><p>当s0栈顶与s1栈顶相遇时，栈满：<code>top[0]+1==top[1]</code>；栈空：<code>top[0]==-1 &amp;&amp; top[1]==maxSize</code>。</p><table><thead><tr><th style="text-align:center">top[0]</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">…</th><th style="text-align:center">n-1</th><th style="text-align:center">top[1]</th></tr></thead></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享栈的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> elem[maxSize];</span><br><span class="line">    <span class="type">int</span> top[<span class="number">2</span>];<span class="comment">//top[0]为s0栈顶，top[1]s1栈顶</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(SqStack &amp;st,<span class="type">int</span> stNo,<span class="type">int</span> x)</span>&#123;<span class="comment">//stNo表示入栈的编号，x是要入栈的值</span></span><br><span class="line">    <span class="keyword">if</span>(st.top[<span class="number">0</span>]+<span class="number">1</span>&lt;st.top[<span class="number">2</span>])&#123;<span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span>(stNo==<span class="number">0</span>)&#123;<span class="comment">//从栈顶s0处入栈</span></span><br><span class="line">            ++(st.top[<span class="number">0</span>]);</span><br><span class="line">            st.elem[st.top[<span class="number">0</span>]]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stNo==<span class="number">1</span>)&#123;<span class="comment">//从栈顶s1处入栈,注意此处入栈栈顶是自减，因为它的栈底是在右侧</span></span><br><span class="line">            --(st.top[<span class="number">1</span>]);</span><br><span class="line">            st.elem[st.top[<span class="number">1</span>]]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//stNo的值不是0、1，输入错误</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满，插入失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(SqStack &amp;st,<span class="type">int</span> stNo,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stNo==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.top[<span class="number">0</span>]!=<span class="number">-1</span>)&#123;<span class="comment">//st0不为空，可以出栈</span></span><br><span class="line">            x=st.elem[st.top[<span class="number">0</span>]];</span><br><span class="line">            --(st.top[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//st0为空，出栈失败</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stNo==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.top[<span class="number">1</span>]!=maxSize)&#123;<span class="comment">//st1不为空，可以出栈</span></span><br><span class="line">            x=st.elem[top[<span class="number">1</span>]];</span><br><span class="line">            ++(st.top[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//st1为空，出栈失败</span></span><br><span class="line">    &#125;<span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//stNo不为0、1，输入错误</span></span><br></pre></td></tr></table></figure><h3 id="用两个栈模拟队列">用两个栈模拟队列</h3><p>栈的特点是后进先出，队列的特点是先进先出。所以，当用两个栈s1和s2模拟一个队列时，s1作为输入栈，逐个元素压栈，以此模拟队列元素的入队。当需要出队时，将栈s1退栈并逐个压入栈s2中， s1中最先入栈的元素在s2中处于栈顶。s2退栈，相当于队列的出队，实现了先进先出。只有栈s2为空且s1也为空时，才算是队列空。</p><ul><li>入队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队，将新元素x压入s1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(SqStack &amp;s1, SqStack &amp;s2, <span class="type">int</span> x)</span> &#123;</span><br><span class="line"><span class="type">int</span> y;<span class="comment">//临时变量，用来在s1和s2之间传值 </span></span><br><span class="line"><span class="comment">//如果s1不是满的，直接把元素压入即可</span></span><br><span class="line"><span class="keyword">if</span> (s1.top != maxSize - <span class="number">1</span>) &#123;</span><br><span class="line">push(s1, x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s1满，可以尝试把元素放到s2中，再从s1入栈，不过要先判断s2中是否还有剩余的未pop的元素</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里要尤其注意：</span></span><br><span class="line">        <span class="comment">//s1满，s2非空，此时不能入栈，必须要等s2中的元素都出栈，才能继续往s2中压入新元素</span></span><br><span class="line">        <span class="comment">//此时就是队满的状态，虽然s2中还有剩余的存储空间</span></span><br><span class="line">        <span class="comment">//此时如果将s1中的元素压入s2，则后进的元素反而跑到先进的元素前面出，这就不符合先进先出的原则</span></span><br><span class="line"><span class="keyword">if</span> (!isEmpty(s2)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//只有在s1满，s2空的情况下，才能把s1元素压入s2中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isEmpty(s2)) &#123;</span><br><span class="line">            <span class="comment">//s1出栈，s2入栈，直到s1空，s2满</span></span><br><span class="line">            <span class="comment">//最先入s1的元素此时在s2的栈顶</span></span><br><span class="line"><span class="keyword">while</span> (!isEmpty(s1)) &#123;</span><br><span class="line">pop(s1, y);</span><br><span class="line">push(s2, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里，s2此时是栈满的状态，s1此时是栈空的状态</span></span><br><span class="line"><span class="comment">//把新元素压入s1</span></span><br><span class="line">push(s1, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队，s2的栈顶元素退栈，x接收出队元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deQueue</span><span class="params">(SqStack &amp;s2, SqStack &amp;s1, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="comment">//如果s2非空，直接出栈</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isEmpty</span>(s2)) &#123;</span><br><span class="line"><span class="built_in">pop</span>(s2, x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果s2是空的，就将s1中的所有元素挨个出栈再压入到s2中</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//s2空，s1空，则队空，出队失败</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEmpty</span>(s1)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//s2空，s1非空，s1出栈，s2入栈，直到s1空，此时s2不一定是满的,这取决于s1中转移前的元素个数</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(s1)) &#123;</span><br><span class="line"><span class="built_in">pop</span>(s1, y);</span><br><span class="line"><span class="built_in">push</span>(s2, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时s1是空的，最先入s1的元素此时在s2的栈顶，出栈</span></span><br><span class="line"><span class="built_in">pop</span>(s2, x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isQueueEmpty</span><span class="params">(SqStack s1, SqStack s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s1和s2都为空，则队空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEmpty</span>(s1) &amp;&amp; <span class="built_in">isEmpty</span>(s2)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队满</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isQueueFull</span><span class="params">(SqStack s1, SqStack s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s1满，去看s2</span></span><br><span class="line"><span class="keyword">if</span> (s<span class="number">1.</span>top == maxSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//s1满，s2非空，则队满（因为此时不能将s1中的元素压入s2来腾出空间给新元素）</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isEmpty</span>(s2))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//s1满，s2空，则队未满</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//s1未满，则队未满</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十进制转化二进制">十进制转化二进制</h2><ol><li>编写一个算法，将一个非负的十进制整数N转换为一个二进制数。</li></ol><p>分析：十进制转换二进制，方法是&quot;除2取余，逆序排列&quot;，这里可以使用栈来解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">baseTrans</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> stack[maxSize];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (N!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">i = N % <span class="number">2</span>;<span class="comment">//N除以2取余得到二进制数，入栈</span></span><br><span class="line">N = N / <span class="number">2</span>;<span class="comment">//N自身除以2取整，准备下一次运算</span></span><br><span class="line">stack[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (top!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出栈，将得到的余数逆序输出</span></span><br><span class="line">i = stack[top--];</span><br><span class="line">result = result * <span class="number">10</span> + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-1 线性表</title>
      <link href="/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表的结构体定义与基本操作">线性表的结构体定义与基本操作</h1><h2 id="线性表的结构体定义">线性表的结构体定义</h2><ol><li>顺序表的结构体定义</li></ol><p>一个顺序表中包含一个存储表中元素的数组data[]和一个指示元素个数的变量length：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[maxSize]; <span class="comment">// 默认int型，可换</span></span><br><span class="line"><span class="type">int</span> legth;</span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure><p>简单写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[maxSize]</span><br><span class="line"><span class="type">int</span> n;</span><br></pre></td></tr></table></figure><ol start="2"><li>单链表的结点定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">//指向后继结点的指针</span></span><br><span class="line">&#125;LNode; <span class="comment">//定义单链表结点类型</span></span><br></pre></td></tr></table></figure><ol start="3"><li>双链表的结点定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DLNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLNode</span> *prior;<span class="comment">//指向前驱结点的指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLNode</span> *next; <span class="comment">//指向后继结点的指针</span></span><br><span class="line">&#125;DLNode; <span class="comment">//定义双链表结点类型</span></span><br></pre></td></tr></table></figure><h2 id="顺序表的操作">顺序表的操作</h2><ol><li>按元素值的查找算法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在顺序表中查找第一个和e值相等的元素，并返回其下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findElem</span><span class="params">(Sqlist L,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(e==L.data[i])&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败，标记-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>插入数据元素的算法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在顺序表L的p（0≤p≤length）位置上插入新元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> p,<span class="type">int</span> e)</span></span>&#123; <span class="comment">//L要发生改变，所以要用引用型</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;L.length || L.length==maxSize )&#123; <span class="comment">//检查是否越界</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=L.length<span class="number">-1</span>;i&gt;=p;i--)&#123; <span class="comment">//p位置及p以后的所有元素朝后挪</span></span><br><span class="line">L.data[i<span class="number">+1</span>]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">L.data[p]=e; </span><br><span class="line">(L.lenth)++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.删除数据的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除书序表L中下标p(0≤p≤length-1)的元素，并将删除的元素赋值给e</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteElem</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> p, <span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>（p&lt;<span class="number">0</span>||p&gt;length<span class="number">-1</span>） <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//检查参数合法性</span></span><br><span class="line">e=L.data[p]; <span class="comment">//被删除元素赋值给e</span></span><br><span class="line"><span class="keyword">for</span>(i=p;p&lt;=L.length<span class="number">-1</span>;i--)&#123; <span class="comment">//从位置p开始，将后一个数赋值给前一个位置</span></span><br><span class="line">L.data[i]=L.data[i<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line">--(L.length);<span class="comment">//L长度-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.初始化</p><p>只需要将length设为0即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(Sqlist &amp;L)</span>&#123;</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.求指定位置元素的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getElem</span><span class="params">(Sqlist L，<span class="type">int</span> p,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;L.length<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e=L.data[p];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的操作">单链表的操作</h2><p>1.单链表的建立——尾插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个元素存储在数组a中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createListR</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">LNode *s,*r; </span><br><span class="line">C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); C-&gt;next=<span class="literal">NULL</span>; <span class="comment">//申请C的头结点空间</span></span><br><span class="line">r=C; <span class="comment">//给r赋初始值；r始终指向C的终端结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//循环申请n个结点</span></span><br><span class="line">s-&gt;data=a[i]; <span class="comment">//从数组中取值赋给s的数据域</span></span><br><span class="line">r-&gt;next=s; <span class="comment">//将s结点接在C的末端</span></span><br><span class="line">r=r-&gt;next; <span class="comment">//刷新r</span></span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在构造头结点时要给终端结点赋NULL？<br>良好的代码习惯，这样可以避免后续操作（很多循环判断条件会用到）时很多因终端结点非NULL而引起的错误。</p><p>2.单链表的建立——头插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createListF</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">LNode *s;</span><br><span class="line">C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">s-&gt;data=a[i];</span><br><span class="line"><span class="comment">//每次都从头结点后面插入新元素，应该先将s的next指向原链表中的第一个元素，再将头结点的next指向s</span></span><br><span class="line">s-&gt;next=C-&gt;next;</span><br><span class="line">c-&gt;next=s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：以上是带头结点的单链表的头插法与尾插法，考虑一下不带头结点和尾结点的单链表的插入？</p><p>3.单链表的归并——尾插法——顺序插入</p><p>A、B为带头结点的单链表，其中元素递增有序。设计一个算法，将A和B合并成一个按元素值非递减有序的链表C。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> merge（LNode *A,LNode *B,LNode *&amp;C）&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用p和q来指向链表AB中的最小值，即最前面的值</span></span><br><span class="line">LNode *p=A-&gt;next; </span><br><span class="line">LNode *q=B-&gt;next;</span><br><span class="line">C=A; C-&gt;next=<span class="literal">NULL</span>; <span class="built_in">free</span>(B); <span class="comment">//将A的头结点赋给C，并释放掉B的头结点（已经将链表B中的首个结点赋给q了）</span></span><br><span class="line">LNode *r = C; <span class="comment">//r始终指向C的终端结点</span></span><br><span class="line"><span class="comment">//开始归并</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)&#123; <span class="comment">//比较当前p和q的大小，将小的那一个用r接在C后，每接一个刷新指针</span></span><br><span class="line">r-&gt;next=p;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">r=r-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">r-&gt;next=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">r=r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剩下的全部一次性接在C后</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>) r-&gt;next=p;</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-&gt;next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.单链表的归并——头插法——逆序插入</p><p>A、B为带头结点的单链表，其中元素递增有序。设计一个算法，将A和B合并成一个按元素值递减有序的链表C。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> merge（LNode *A,LNode *B,LNode *&amp;C）&#123;</span><br><span class="line"></span><br><span class="line">LNode *p=A-&gt;next; </span><br><span class="line">LNode *q=B-&gt;next;</span><br><span class="line">C=A; C-&gt;next=<span class="literal">NULL</span>; <span class="built_in">free</span>(B);</span><br><span class="line">LNode *s; <span class="comment">//s用来接收新结点</span></span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;data&lt;=q-&gt;data)&#123;</span><br><span class="line">s=p;</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">s-&gt;next=C-&gt;next;</span><br><span class="line">C-&gt;next=s;</span><br><span class="line"><span class="comment">//刷新指针p</span></span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">s=q;</span><br><span class="line">s-&gt;next=C-&gt;next;</span><br><span class="line">C-&gt;next=s;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是头插法归并和尾插法归并不同的地方，头插法归并剩余的元素需要逐个插入到C中</span></span><br><span class="line"><span class="keyword">while</span>(p!<span class="literal">NULL</span>)&#123;</span><br><span class="line">s=p;</span><br><span class="line">s-next=c-&gt;next;</span><br><span class="line">c-next=s;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q!<span class="literal">NULL</span>)&#123;</span><br><span class="line">s=q;</span><br><span class="line">s-next=c-&gt;next;</span><br><span class="line">c-next=s;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以稍作改进，只需要用s记录下此时指针即可，p和q一定只有一个还有剩余，不可能两个都有剩余。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s=NULL; //先将s置空</span></span><br><span class="line"><span class="comment">if(p!=NULL)&#123;s=p;&#125;</span></span><br><span class="line"><span class="comment">if(q!=NULL)&#123;s=q;&#125;</span></span><br><span class="line"><span class="comment">while(s!=NULL)&#123;</span></span><br><span class="line"><span class="comment">s-&gt;next=C-&gt;next;</span></span><br><span class="line"><span class="comment">C-next=s；</span></span><br><span class="line"><span class="comment">s=s-&gt;next;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.单链表中元素的删除与插入</p><p>插入操作在上面已经展现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两个语句的顺序不能颠倒。删除操作比较简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但完整的删除语法要释放内存，正确的写法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在单链表中删除某个结点必须要知道它的前驱结点。</p><p>6.单链表的查找</p><p>如果只是简单的查找，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LNode* <span class="title function_">findLNode</span><span class="params">(LNode *C,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">LNode *p=C-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data==x)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：查找链表C（带头结点）中是否存在一个值为x的元素，如果存在，则删除该结点然后返回1，否则返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findAndDelete</span><span class="params">(LNode *C,<span class="type">int</span> x)</span>&#123;<span class="comment">//C的表头结点不会改变，所以这里用引用型，C除了表头结点外其他结点都可以改变</span></span><br><span class="line">LNode *p,*q;</span><br><span class="line">p=C;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next-&gt;data==x) <span class="keyword">break</span>;<span class="comment">//找到x时此时p指向的是x的前一个位置,这是因为要删除结点必须知道它的前一个结点</span></span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//即使是最后一个元素找到了x，p也指向的是倒数第二个元素，此时p-&gt;next!=NULL</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="comment">//删除成功返回1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双链表的操作">双链表的操作</h2><p>1.尾插法建立双链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createDListR</span><span class="params">(DLNode *&amp;L,<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">DLNode *s,*r;</span><br><span class="line"><span class="comment">//create head node</span></span><br><span class="line">L=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">L-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">s=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">s-&gt;data=a[i];</span><br><span class="line"><span class="comment">//到这里和单链表几乎没有区别，插入时也只是多了一步前驱结点的定义过程。</span></span><br><span class="line">r-&gt;next=s;</span><br><span class="line">s-&gt;prior=r;</span><br><span class="line">r=s; <span class="comment">//r=r-&gt;next;</span></span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.双链表——查找结点</p><p>单链表和双链表的查找算法没有任何区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DLNode* <span class="title function_">findDNode</span><span class="params">(DLNode *C,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">DLNode *p=C-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data==x)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果找到，则返回结点地址p，如果没找到，循环因p=NULL而结束，返回p;</p><p>3.双链表——插入结点</p><p>在双链表中p所指的结点后插入一个新结点s:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">s-&gt;next-&gt;prior=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键是先后顺序，要先将插入的结点的前后接好，这样才不会发生链断后找不到结点的情况。</p><p>4.双链表——删除结点</p><p>删除p的后继结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆置问题">逆置问题</h2><p>算法：给定一个线性表，如何将其中的元素逆置？可设置两个指针，分别指向表头和表尾，边交换元素边向中间挪动，直到两个指针相遇。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如元素存在数组a[]中，left和right是数组两端元素的下标。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left，j=right;i&lt;j;i++,j--)&#123; <span class="comment">//注意，这里的循环条件不能写成i!=j，如果数组中的元素有偶数个，会发生i和j相互跨过对方，循环不会结束。</span></span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆置相当于把原来数组中元素逆序重新放在数组里。</p><p>例题：</p><blockquote><p>（1）将数组的前k（k&lt;n）个元素逆序后移动到数组后端，原数组数据不丢失，其余元素的位置无关紧要；<br>答：将整个数组逆置即可。</p></blockquote><blockquote><p>（2）将数组的前k（k&lt;n）个元素保持原顺序移动到数组后端，原数组数据不丢失，其余元素的位置无关紧要；<br>答：将前k个元素逆置后将整个数组逆置。</p></blockquote><blockquote><p>（3）将数组中的前n个元素（x0,x1,x2,…,xn-1）经过移动后变为（xp,xp+1,…,xn-1,x0,x1,…,xp-1）,即循环左移p(0&lt;p&lt;n)<br>答：观察移动后的元素位置，相当于把前p个元素顺序不变放在后端，后n-p个元素顺序不变放在前端。所以先将前p个元素和后n-p个元素分别逆置，再将整个数组逆置。</p></blockquote><h2 id="课后题">课后题</h2><p>二、综合应用题</p><p>1.基础题</p><p>（4）设计一个算法，从一给定的顺序表L中删除下标i~j(i&lt;=j包括i和j的所有元素),假设i和j都是合法的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteElems</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="comment">//从i开始，用后面的元素覆盖掉要删除的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;L.length;k++)&#123;</span><br><span class="line">L.data[i]=L.data[k];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）有一个顺序表L,其元素为整型数据，设计一个算法，将L中所有小于表头元素的整数放在前半部分，大于表头元素的整数放在后半部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(Sqlist &amp;L)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j=L.length<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> temp=L.data[i]; <span class="comment">//用temp来保存表头元素的值</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j&amp;&amp;L.data[j]&gt;temp) --j; <span class="comment">//j从最右边往左扫描，找到比temp小的数时跳出while执行if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123; <span class="comment">//为什么在这里还要再判断一次i&lt;j呢？经过上一步，j有可能已经小于等于i了。</span></span><br><span class="line">L.data[i]=L.data[j];        <span class="comment">//将大的数放在位置i上，i向右挪</span></span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j&amp;&amp;L.data[i]&lt;temp) ++i;<span class="comment">//i从左往右扫描，找到比temp大的数时跳出while执行if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">L.data[j]=L.data[i];<span class="comment">//将找到的这个大于temp的数放在给j位置上，j往左挪</span></span><br><span class="line">--j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.data[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*经过一次循环，j从右往左扫，将一个大的数放在了前半部分，i从左往右扫，将一个小的数放在了后半部分。</span></span><br><span class="line"><span class="comment">每次元素覆盖时，之前位置上的数已经放在了前半部分/后半部分，而temp值始终保存着最开始a[0]，所以不用担心数据丢失。</span></span><br><span class="line"><span class="comment">当i==j时循环结束，最后一次循环结束时i和j所指的数是也是循环内最后一次发生覆盖元素的数，</span></span><br><span class="line"><span class="comment">它的值已经保存在了别的位置上，此时将temp放在这里，所有数据保存完整。*/</span></span><br></pre></td></tr></table></figure><p>（6）有一个递增非空单链表，设计一个算法删除值域重复的结点。例如，{1,1, 2, 3, 3, 3, 4, 4,7, 7, 7, 9, 9, 9}经过删除后变成{1,2, 3, 4, 7, 9}。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteRepeat1</span><span class="params">(LNode *L)</span>&#123; <span class="comment">//表头结点不用改变，这里传指针型即可</span></span><br><span class="line">LNode *p=L-&gt;next; <span class="comment">//p指向首个结点</span></span><br><span class="line">LNode *q;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data==p-&gt;next-&gt;data)&#123;<span class="comment">//由于链表递增，所以重复的元素一定是相连的，如果p的值和下一个结点的值相等，就删除它</span></span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p=p-&gt;next;<span class="comment">//如果不相等，p向右移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（7）设计一个算法删除单链表L(有头结点）中的一个最小值结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">deleteMin</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">LNode *q;</span><br><span class="line">LNode *p=L-&gt;next;</span><br><span class="line">LNode *minPrior=L; <span class="comment">//假设第一个结点是最小的，min始终指向最小结点的前一个结点（方便删除min）</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next-&gt;data &lt; p-&gt;data)&#123;</span><br><span class="line">minPrior=p;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">q=minPrior-&gt;next;</span><br><span class="line">minPrior-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（8）有一个线性表，采用带头结点的单链表L来存储。设计一个算法将其逆置。要求不能建立新结点，只能通过表中已有结点的重新组合来完成。</p><p>//链表逆置问题，可以看成是链表的逆序问题，将L看成一个空链表，将结点使用头插法挨个插入即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line"><span class="comment">//将链表从头结点处分开成两部分</span></span><br><span class="line">LNode *p=L-&gt;next;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//temp用来临时记录插入前p的位置</span></span><br><span class="line">LNode *temp;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">temp=p;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line"><span class="comment">//刷新p</span></span><br><span class="line">p=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（9）设计一个算法，将一个头结点为A的单链表（其数据域为整数）分解成两个单链表A和B，使得A链表只含有原来链表中data域为奇数的结点，而B链表只含有原链表中data域为偶数的结点，且保持原来的相对顺序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：把AB看成两个空的链表，把每个结点单独取出来判断其值，分类重新按照尾插法插入到A和B中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">divorce_1</span><span class="params">(LNode *A,LNode *&amp;B)</span>&#123;</span><br><span class="line"><span class="comment">//申请B链表的头结点</span></span><br><span class="line">B=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); </span><br><span class="line">B-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 只保留A的头结点,用p记录其他结点</span></span><br><span class="line">LNode *p=A-&gt;next;</span><br><span class="line">A-&gt;next=<span class="literal">NULL</span>; </span><br><span class="line"><span class="comment">//现在有两个新的空链表，接下来把结点分类按尾插法插入</span></span><br><span class="line">LNode *temp,*tempA=A,*tempB=B; <span class="comment">//tempA、tempB始终指向A/B的终端结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//取出结点p</span></span><br><span class="line">temp=p;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;data%<span class="number">2</span>==<span class="number">0</span>)&#123;<span class="comment">//偶数,尾插法接入B中</span></span><br><span class="line">*tempB-&gt;next=p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//奇数，尾插法插入A中</span></span><br><span class="line">*tempA-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">p=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：从A中删除偶数结点，并将其取出来插入到B中</span></span><br><span class="line"><span class="comment">//注意删除操作时必须要知道前驱结点，这里的删除不用释放空间，结点并不是真正意义上的删除，只是转移到了B中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">divorce_2</span><span class="params">(LNode *A,LNode *&amp;B)</span>&#123;</span><br><span class="line">B=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请B链表的头结点</span></span><br><span class="line">B-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">LNode *p=A;<span class="comment">//p表示偶数结点的前驱结点(删除操作用)</span></span><br><span class="line">LNode *r=B;<span class="comment">//r始终指向B的终端结点</span></span><br><span class="line">LNode *temp;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next-&gt;data % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="comment">//取出偶数结点</span></span><br><span class="line">temp=p-&gt;next;</span><br><span class="line">p-&gt;next=temp-&gt;next;</span><br><span class="line">temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//尾插法插在B中</span></span><br><span class="line">r-&gt;next=temp;</span><br><span class="line">r=r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.思考题</p><p>（1）有N个个位正整数存放在int型数组A[O,…, N-1]中，N为已定义的常量且N&lt;=9,数组A[]的长度为N,另给一个int型变量i,要求只用上述变量(A[O]A,…___,[N-1]与i,这N+l个整型变量）写一个算法，找出这N个整数中的最小者，并且要求不能破坏数组A[]中的数据。</p><blockquote><p>分析：在数组（顺序表）中查找最小值，需要一个循环变量i来控制循环，一个临时变量记录min。题目中要求只能用到i一个变量，可以让i的十位上的数字作为循环变量，各位上的数作为临时变量。<br>// i%10 取个位数 临时变量<br>// i/10 取十位数 循环变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> &amp;i)</span>&#123;</span><br><span class="line">i=a[<span class="number">0</span>];<span class="comment">// i赋初始值为a[0]，此时i是个位数，i/10==0，i%10==a[0]</span></span><br><span class="line"><span class="keyword">while</span>(i/<span class="number">10</span>&lt;=N<span class="number">-1</span>)&#123;<span class="comment">// i/10 从0开始，递增到N-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">10</span>&gt;a[i/<span class="number">10</span>])&#123;</span><br><span class="line">i = i - i%<span class="number">10</span>;<span class="comment">//去掉个位数</span></span><br><span class="line">i = i + a[i/<span class="number">10</span>];  <span class="comment">//个位数替换成较小的数组元素值</span></span><br><span class="line">&#125; </span><br><span class="line">i = i+<span class="number">10</span>; <span class="comment">//十位数增+1（循环变量+1）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i%<span class="number">10</span>;<span class="comment">//返回个位数即为最小值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）写一个函数，逆序打印单链表中的数据，假设指针L指向了单链表的开始结点。</p><blockquote><p>分析：采用递归的方法解决</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reprint</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">reprint(L-&gt;next);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）（2021）试编写一个函数，以不多于3n/2的平均比较次数，在一个有n个整数的顺序表A中找出最大值和最小值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findMaxAndMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n,<span class="type">int</span> &amp;max,<span class="type">int</span> &amp;min)</span>&#123;</span><br><span class="line">max = min = A[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n<span class="number">-1</span>;)&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于min和max来说，A[i]有三种情况：</span></span><br><span class="line"><span class="comment">1.A[i]&lt;min更新最小值</span></span><br><span class="line"><span class="comment">2.A[i]&gt;max更新最大值</span></span><br><span class="line"><span class="comment">3.min&lt;=A[i]&lt;=maxA[i]既不可能是最大值也不可能是最小值，不操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(A[i]&gt;max)&#123;</span><br><span class="line">max = A[i];</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[i]&lt;min)&#123;</span><br><span class="line">min = A[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：当表中的n个整数按从小到大排列时，比较次数为n-1;<br>最差情况：当表中的n个整数按从大到小排列时，比较次数为2(n-1);<br>每个结点的数值上面说了有三种情况，概率为1/3，每个节点比较1次和比较2次的概率相等，则单个结点的平均比较次数为3/2；<br>平均比较次数：（3/2）*（n-1）=3n/2-3/2</p><p>（3）（2022）设有两个用有序链表表示的集合A和B,设计一个算法，判断它们是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEqual</span><span class="params">(LNode *A,LNode *B)</span>&#123;</span><br><span class="line">LNode *p =A-&gt;next;</span><br><span class="line">LNode *q =B-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data == q-&gt;data)&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、真题精选</p><p>（二）综合应用题</p><ol><li>已知一个带有表头结点的单链表，结点结构为:</li></ol><table><thead><tr><th>data</th><th>next</th></tr></thead></table><p>假设该链表只给出了头指针head。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k(k为正整数)个位置上的结点。若查找成功，算法输出该结点的data值，并返回1; 否则，只返回0。要求：<br>(1)描述算法的基本设计思想。<br>(2)描述算法的详细实现步骤。<br>(3)根据设计思想和实现步骤，采用程序设计语言描述算法（使用C或C++语言实现），关键之处请给出简要注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解：(<span class="number">1</span>)基本思想：</span><br><span class="line">遍历链表，用两个指针p，q，p指向当前结点，q指向当前结点的前k<span class="number">-1</span>个结点，当p指向最后一个结点时，q指向倒数第k个结点。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)详细实现步骤：</span><br><span class="line">指针p:当前结点；初始值为head-&gt;next(指向头结点)</span><br><span class="line">指针q:p的前k<span class="number">-1</span>个结点；初始值为head-&gt;next(指向头结点)</span><br><span class="line">用 i 表示 p 和 q 之间的结点数，初始值为<span class="number">1</span>(中间只有一个头结点)，p 从左到右遍历：</span><br><span class="line">当i&lt;=k时，p向右移，q不动；</span><br><span class="line">当i&gt;k时，p向右移，q也向右移，直到p指向终端结点时跳出循环，q所指的指针即为链表中倒数第k(k为正整数）个位置上的结点。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(LNode *head,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">LNode *p,*q=head-&gt;next;</span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i&gt;k)&#123;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>已知一个整数序列A = (A0, A1, …, A(n-1)), 其中0&lt;=ai&lt;=n (0&lt;=i&lt;n)。若存在ap1 = ap2=…= apm= x且m&gt;n/2(0&lt;=pk&lt;n, 1&lt;=k&lt;=m), 则称x为A的主元素。例如，A= (0, 5, 5, 3, 5, 7, 5, 5), 则5为主元素；又如，A= (0, 5, 5, 3, 5, 1, 5, 7), 则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求：<br>(1)给出算法的基本设计思想。<br>(2)根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。<br>(3)说明你所设计算法的时间复杂度和空间复杂度</li></ol><p>方法一：排序取中位数；</p><p>方法二：抵消法：删除数组中两个不同的数，直到剩下的数都一样。此时剩下的数就是主元素。<br>原理：主元素的个数一定是比其他元素的个数至少多1的，任意删去两个不同的数之后，在剩余子数组中，主元素依旧是主元素。随着遍历，最后剩下的数，一定是主元素（因为最多删除n/2-1次）。</p><p>计数器：count 初始值为1<br>候选值：num 初始值为a[0]</p><p>遍历数组，<br>如果a[i]和num值相等，则count+1;<br>如果a[i]和num值不相等，则count-1;直到count等于0（这意味着随机删除了多组两两不同的数），更换候选值num=a[i]，计数器重置为1，从a[i]开始接着朝后遍历，直到扫描完整个数组;</p><p>如果数组中一定存在主元素，那么最后剩下的值就一定是主元素。可是现在由于数组中不一定存在主元素，最后num的值不一定是主元素，所以遍历结束后我们需要对num进行再次确认。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">majority</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> num = a[<span class="number">0</span>];</span><br><span class="line">count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==num)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//不相等时需要判断count是否为0</span></span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">count--;</span><br><span class="line"><span class="comment">// count为0，说明前面已经删去了多组两两不相等的数，此时重置候选值和计数器</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">num=a[i];</span><br><span class="line">count=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历结束后，要对num值是否满足条件再进行判断，因为数组a中不一定含有主元素</span></span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==num)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&gt;n/<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">算法的时间复杂度：O(n)</span><br><span class="line">算法的空间复杂度：O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识总结</title>
      <link href="/2023/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章概述">第 1 章概述</h1><h2 id="1-1-计算机网络在信息时代中的作用">1.1 计算机网络在信息时代中的作用</h2><ul><li>21 世纪的一些重要特征就是<font color="#245bdb">数字化</font>、<font color="#245bdb">网络化</font>和<font color="#245bdb">信息化</font>，它是一个<font color="#245bdb">以网络为核心的信息时代</font>。</li><li>网络是指“三网”，即<font color="#245bdb">电信网络</font>、<font color="#245bdb">有线电视网络</font>和<font color="#245bdb">计算机网络</font>。</li><li><mark style="background: #BBFABBA6;">“<font color="#c00000">三网融合</font>”：随着技术的发展，电信网络和有线电视网络都逐渐融入了现代计算机网络的技术。</mark></li><li>计算机网络向用户提供的最重要的功能：<ol><li><font color="#c00000">连通性</font>——计算机网络使上网用户之间都可以交换信息，好像这些用户的计算机都可以彼此直接连通一样。</li><li><font color="#c00000">共享</font>——即<font color="#245bdb">资源共享</font>。可以是信息共享、软件共享，也可以是硬件共享。</li></ol></li></ul><h2 id="1-2-因特网概述">1.2 因特网概述</h2><ul><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">网络</font> (network)由若干<font color="#c00000">结点</font> (node)和连接这些结点的<font color="#c00000">链路</font> (link)组成。 </mark></p><ul><li>网络中的结点可以说计算机、集线器、交换机或路由器等。</li></ul></li><li><p>互联网是“<font color="#c00000">网络的网络</font>”(network of networks)。</p></li><li><p><font color="#c00000">因特网</font>是世界上最大的互连网络。</p></li><li><p>连接在因特网上的计算机都称为<font color="#c00000">主机</font> (host)。</p></li><li><p><mark style="background: #BBFABBA6;"> 网络把许多计算机连接在一起，而因特网把许多网路连接在一起。</mark></p></li><li><p>因特网发展的三个阶段：</p><ol><li><u>第一阶段是从单个网络 <font color="#245bdb">ARPANET</font> 向互联网发展的过程。</u></li><li><u>第二阶段：建成了三级结构的互联网。 </u><ul><li>它是一个三级计算机网络，分为<font color="#245bdb">主干网</font>、<font color="#245bdb">地区网</font>和<font color="#245bdb">校园网</font>（或<font color="#245bdb">企业网</font>）。</li></ul></li><li><u>第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。</u><ul><li><font color="#d83931">因特网服务提供者 ISP </font>(Internet Service Provider)： 任何机构和个人只要向某个 ISP 交纳规定的费用，就可从该 ISP 获取所需 IP 地址的使用权，并可通过该 ISP 接入到互联网。</li><li>根据提供服务的<u>覆盖面积大小</u>以及<u>所拥有的 IP 地址数目</u>的不同，ISP 也分成为不同层次的 ISP：<font color="#245bdb">主干 ISP</font>、<font color="#245bdb">地区 ISP</font> 和<font color="#245bdb">本地 ISP</font>。</li></ul></li></ol></li></ul><h2 id="1-3-因特网的组成">1.3 因特网的组成</h2><ul><li><p>从互联网的<font color="#245bdb">工作方式</font>上看，因特网可以划分为两大块：</p><ol><li><font color="#c00000">边缘部分</font>： 由所有连接在互联网上的<font color="#245bdb">主机</font>组成。<br>这部分是<u>用户直接使用</u>的，用来进行通信（传送数据、音频或视频）和资源共享。</li><li><font color="#c00000">核心部分</font>：由大量<font color="#245bdb">网络</font>和连接这些网络的<font color="#245bdb">路由器</font>组成。<br>这部分是<u>为边缘部分提供服务</u>的（提供连通性和交换）。</li></ol></li><li><p><font color="#c00000">端系统</font>：处在互联网边缘的部分，就是连接在互联网上的所有的主机。</p></li><li><p><font color="#c00000">计算机之间的通信</font>：主机 A 的某个<font color="#245bdb">进程</font>与主机 B 的<font color="#245bdb">另一个进程</font>之间的通信。</p><ul><li><font color="#245bdb">进程</font>就是运行着的程序。</li></ul></li><li><p><font color="#245bdb">端系统之间的通信方式</font>通常可划分为两大类：</p><ol><li><p><font color="#c00000">客户服务器方式</font>（C/S 方式），即 Client/Server 方式，简称为 <font color="#245bdb">C/S 方式</font>。</p><ul><li><font color="#245bdb">客户</font> (client)和<font color="#245bdb">服务器 </font>(server)都是指通信中所涉及的两个应用<font color="#245bdb">进程</font>。</li><li>客户服务器方式所描述的是进程之间<font color="#245bdb">服务和被服务</font>的关系。</li><li>客户是服务的<font color="#245bdb">请求方</font>，服务器是服务的<font color="#245bdb">提供方</font>。</li><li>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</li></ul></li><li><p><font color="#c00000">对等方式</font>（P2P 方式），即 Peer to Peer 方式，简称为<font color="#245bdb"> P2P 方式</font>。</p><ul><li><mark style="background: #BBFABBA6;">对等连接 P2P 两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</mark></li><li>只要两个主机都运行了对等连接软件（P2P 软件），就可以进行<font color="#245bdb">平等的</font>、<font color="#245bdb">对等连接通信</font>。</li><li>对等连接方式从本质上看<font color="#245bdb">仍然是使用客户服务器方式</font>，只是对等连接中的每一个主机既是客户又是服务器。</li></ul></li></ol></li><li><p>因特网的核心部分</p><ul><li>网络核心部分是由许多<font color="#245bdb">网络</font>和把它们互连起来的<font color="#245bdb">路由器</font>组成，而主机处在因特网的边缘部分。</li><li><font color="#245bdb">主机</font>的用途是为用户进行<font color="#245bdb">信息处理</font>的，并且可以和其他主机通过网络交换信息。路由器的用途则是对分组进行<font color="#245bdb">存储转发</font>，最后把分组交付目的主机。</li><li>在网络核心部分起特殊作用的是<font color="#c00000">路由器</font> (router)。</li><li>路由器是实现<font color="#245bdb">分组交换</font> (packet switching) 的关键构件，其任务是<u>转发收到的分组</u>，这是网络核心部分最重要的功能。</li></ul></li><li><p>三种交换技术：<font color="#c00000">电路交换</font>、<font color="#c00000">分组交换</font>、<font color="#c00000">报文交换</font></p><ul><li><font color="#c00000">交换</font>(switching)的含义就是<font color="#245bdb">转接</font>—— 把一条电话线转接到另一条电话线，使它们连通起来。从通信资源的分配角度来看，<mark style="background: #BBFABBA6;">交换就是按照某种方式<u>动态地分配</u>传输线路的资源</mark>。</li></ul><ol><li>电路交换的特点<ul><li>电路交换分为三个阶段：<ol><li><font color="#245bdb">建立连接</font>：建立一条<u>专用的物理通路</u>，占用通信资源；</li><li><font color="#245bdb">通信</font>：一直占用通信资源；</li><li><font color="#245bdb">释放连接</font>：释放刚才占用的所有通信资源。</li></ol></li><li>电路交换必定是<font color="#245bdb">面向连接</font>的。（面向的意思就是“基于”）</li><li>电路交换的用户<font color="#245bdb">始终占用端到端的通信资源</font>。</li><li>电路交换适合于<font color="#245bdb">通信量很大的实时传输</font>。核心路由器之间可以使用电路交换。</li><li>使用电路交换传送<u>计算机数据</u>时，线路的<font color="#245bdb">传输效率</font>往往很低，这是因为计算机数据总是<font color="#245bdb">突发式</font>地出现在传输线路上，通信线路的实际利用率很低（用来传送数据的时间往往不到 10% 甚至不到 1% ）。</li></ul></li><li>分组交换的特点<ul><li><font color="#c00000">报文</font> (message)：要发送的整块数据。</li><li>分组交换采用<font color="#c00000">存储转发</font>技术。</li><li>在发送端，先把较长的报文划分成<font color="#245bdb">较短的、固定长度的数据段</font>，每一个数据段前面添加上<font color="#245bdb">首部</font>(header)构成<font color="#245bdb">分组</font> (packet)（分组又称为<font color="#245bdb">包</font>，首部称为<font color="#245bdb">包头</font>）。分组交换网以“<font color="#245bdb">分组</font>”作为<font color="#245bdb">数据传输单元</font>，依次把各分组发送到接收端，接收端收到分组后剥去首部还原成报文。</li><li>每一个分组的首部都含有<font color="#245bdb">地址</font>（诸如<font color="#245bdb">目的地址</font>和<font color="#245bdb">源地址</font>）等控制信息。</li><li>路由器处理分组的过程：<ol><li>把收到的分组先放入<font color="#245bdb">缓存</font>（暂时存储）；</li><li>查找<font color="#245bdb">转发表</font>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口转发出去。</li></ol></li><li>分组交换的优点：<ol><li><font color="#00b050">高效</font>：<font color="#245bdb">动态分配</font>传输带宽，对通信链路是逐段占用。</li><li><font color="#00b050">灵活</font>：为每一个分组<font color="#245bdb">独立</font>地选择<font color="#245bdb">最合适</font>的转发路由。</li><li><font color="#00b050">迅速</font>：<font color="#245bdb">不必先建立连接</font>就能向其他主机发送分组。</li><li><font color="#00b050">可靠</font>：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。</li></ol></li><li>分组交换的缺点：<ol><li>分组在各结点存储转发时需要<font color="#245bdb">排队</font>，这就会造成一定的<font color="#c00000">时延</font>。</li><li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的<font color="#c00000">开销</font>。</li></ol></li></ul></li><li>报文交换的特点：<ul><li>报文交换也采用存储转发技术。</li><li>报文交换不把报文分割成更小的分组，而是将整个报文作为传输的单位，在结点间存储转发。</li><li>报文交换的<font color="#245bdb">灵活性不如分组交换</font>，且<font color="#245bdb">时延较长</font>。</li></ul></li></ol></li><li><p>三种交换方式的比较：</p><ol><li>若要<font color="#245bdb">连续传送大量的数据</font>，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</li><li>报文交换和分组交换<font color="#245bdb">不需要预先分配传输带宽</font>，在传送突发数据时可提高整个网络的信道利用率。</li><li>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的<font color="#245bdb">时延小</font>，同时也具有<font color="#245bdb">更好的灵活性</font>。</li><li>电路交换是<font color="#245bdb">静态分配传输带宽</font>，而分组交换是<font color="#245bdb">动态分配带宽</font>，对通信链路逐段占用，更加合理有效地利用各链路的传输带宽。</li></ol></li></ul><h2 id="1-4-计算机网络在我国的发展">1.4 计算机网络在我国的发展</h2><h2 id="1-5-计算机网路的分类">1.5 计算机网路的分类</h2><ul><li><p><font color="#c00000">计算机网络</font>最简单的定义：<mark style="background: #BBFABBA6;">一些互相连接的、自治的计算机的集合</mark>。</p></li><li><p>按照<font color="#245bdb">网络的作用范围</font>进行分类：</p><ol><li><font color="#c00000">广域网 WAN</font>(Wide Area Network)：作用范围通常为几十到几千公里。</li><li><font color="#c00000">城域网 MAN</font> (Metropolitan Area Network)：作用距离约为 5~50 公里。</li><li><font color="#c00000">局域网 LAN</font> (Local Area Network) ：局限在较小的范围（如 1 公里左右）。</li><li><font color="#c00000">个人区域网 PAN </font>(Personal Area Network) ：范围很小，大约在 10 米左右</li></ol></li><li><p>按照<u>网路的使用者</u>进行分类：</p><ol><li><font color="#c00000">公用网</font> (public network) ：按规定交纳费用的人都可以使用的网络。因此也可称为公众网。</li><li><font color="#c00000">专用网</font> (private network) ：为特殊业务工作的需要而建造的网络。</li></ol></li><li><p>用来把用户接入因特网的网络：</p><ul><li><font color="#245bdb">接入网 AN </font>(Access Network)，它又称为<font color="#245bdb">本地接入网</font>或<font color="#245bdb">居民接入网</font>。</li><li>接入网是一类比较<u>特殊的计算机网络，用于将用户接入互联网</u>。</li><li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。</li><li>接入网是从某个用户端系统到互联网中的<u>第一个路由器</u>（也称为<font color="#245bdb">边缘路由器</font>）之间的一种网络。</li><li>从覆盖的范围看，很多接入网还是属于局域网。</li><li>从作用上看，接入网只是起到让用户能够与互联网连接的“桥梁”作用。</li></ul></li></ul><h2 id="1-6-计算机网络的性能">1.6 计算机网络的性能</h2><ol><li><p>速率</p><ul><li><font color="#c00000">比特</font>（bit）是计算机中<font color="#245bdb">数据量的单位</font>，也是信息论中使用的<font color="#245bdb">信息量的单位</font>。</li><li>网络技术中的<mark style="background: #BBFABBA6;"><font color="#c00000">速率</font>：指的是连接在计算机网络上的主机在数字信道上<font color="#245bdb">传送数据的速率</font></mark>，也称为<font color="#c00000">数据率</font> (data rate) 或<font color="#c00000">比特率</font> (bit rate)。</li><li>速率的单位是 b/s（比特每秒），也可以写成 bit/s，有时也写作 bps (bit per second)。</li><li>人们常说的 100 M 以太网的意思是速率为 100 Mb/s 的以太网 (M=10<sup>6</sup>=兆)。</li><li>速率往往是指<font color="#245bdb">额定速率</font>或<font color="#245bdb">标称速率</font>，非实际运行速率。</li></ul></li><li><p>带宽</p><ul><li>“带宽”本来是指信号具有的<font color="#245bdb">频带宽度</font>，其单位是赫（或千赫、兆赫、吉赫等）。</li><li>在计算机网络中，<mark style="background: #BBFABBA6;"><font color="#c00000">带宽</font> (bandwidth) 用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“<font color="#245bdb">最高数据率</font>”。</mark></li><li>带宽的单位是 b/s，即 “比特每秒”。</li><li>更常用的带宽单位是：千比每秒即 kb/s （10<sup>3</sup> b/s）、兆比每秒即 Mb/s（10<sup>6</sup> b/s）、吉比每秒即 Gb/s（10<sup>9</sup> b/s）、太比每秒即 Tb/s（10<sup>12 </sup>b/s）</li><li>请注意：在计算机界，K = 2<sup>10</sup> = 1024，M = 2<sup>20</sup>，G = 2<sup>30</sup>， T = 2<sup>40</sup>。<br>1 字节=1B=8 bit，1 KB =  2<sup>10</sup> = 1024 B 。<br>而在通信领域 K = 10<sup>3</sup>，M=10<sup>6</sup>等等，要注意区分。</li></ul></li><li><p>吞吐量</p><ul><li><mark style="background: #BBFABBA6;"><font color="#c00000">吞吐量</font> (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。</mark></li><li>单位是 b/s。</li><li>吞吐量更经常地用于对现实世界中的网络的一种<font color="#245bdb">测量</font>，以便知道实际上到底有多少数据量能够通过网络。</li><li>吞吐量受网络的<font color="#245bdb">带宽</font>或网络的<font color="#245bdb">额定速率</font>的限制：<font color="#245bdb">额定速率=吞吐量的上限</font>。</li></ul></li><li><p>时延</p><ul><li><mark style="background: #BBFABBA6;"><font color="#c00000">时延</font> (delay 或 latency) 是指数据从网络的一端传送到另一端所需的时间。</mark> 有时也称为<font color="#245bdb">延迟</font>或<font color="#245bdb">迟延</font>。</li></ul><ol><li><mark style="background: #BBFABBA6;"><font color="#c00000">发送时延</font>：主机或路由器发送数据帧所需要的时间。</mark><ul><li>也称为<font color="#c00000">传输时延</font>。</li><li>即从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="发送时延的计算公式"></li></ul></li><li><mark style="background: #BBFABBA6;"><font color="#c00000">传播时延</font>：电磁波在信道中需要传播一定的距离而花费的时间。</mark><ul><li><font color="#245bdb">传输时延</font>（<font color="#245bdb">发送时延</font>）与<font color="#245bdb">传播时延</font>有本质上的不同。</li><li><font color="#245bdb">发送速率</font>和信号在信道上的<font color="#245bdb">传播速率</font>是完全不同的概念。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6.png" alt=""></li></ul></li><li><mark style="background: #BBFABBA6;"><font color="#c00000">处理时延</font>：主机或路由器在收到分组时，为处理分组所花费的时间。 </mark></li><li><mark style="background: #BBFABBA6;"><font color="#c00000">排队时延</font>：分组在路由器输入输出队列中<font color="#245bdb">排队</font>等待处理所经历的时延。</mark><ul><li>排队时延的长短往往取决于网络中当时的<font color="#245bdb">通信量</font>，当通信量很大时会发生缓存队列溢出，使分组丢失，这相当于排队时延为无穷大。</li></ul></li></ol><ul><li>数据在网络中经历的<mark style="background: #FFF3A3A6;"><font color="#c00000">总时延</font>=发送时延+传播时延+处理时延+排队时延</mark>。</li><li>不同时延产生的地方不一样：</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E6%97%B6%E5%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9C%B0%E6%96%B9.png" alt=""></li><li>“<s>在高速链路（或高带宽链路）上，比特会传送得更快些</s>”这种说法是错的，因为：<ol><li>对于高速网络链路，提高的仅仅是数据的<font color="#245bdb">发送速率</font>而不是比特在链路上的传播速率。</li><li>提高链路带宽，数据的发送速率就越快，数据的<font color="#245bdb">发送时延</font>就越小。</li></ol></li><li>载荷信息的电磁波在通信线路中的传播速率（光速级别）与数据的发送速率无关。</li><li>通常说“光纤信道的传播速率高”是指<u>向光纤信道发送数据的速率高</u>，而光纤信道的传<u>播速率</u>（20.5 万公里每秒）实际上比铜线（23.1 万公里每秒）还要<u>略低</u>一些。</li></ul></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">时延带宽积</font> = 传播时延 × 带宽，又称<font color="#245bdb">以比特为单位</font>的链路长度。</mark></p><ul><li>把链路比作空心管道的话，时延带宽积就表示这个管道的<font color="#245bdb">体积</font>，即这个管道可以容纳多少个 bit（这些 bit 已发出但未到达终点）。</li><li>只有在代表链路的管道中都充满 bit 时，链路才得到充分的利用。</li></ul></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">往返时间 RTT</font> (round-trip time) 表示从发送方<font color="#245bdb">发送数据开始</font>，到发送方<font color="#245bdb">收到来自接收方的确认</font>，总共经历的时间。<br></mark></p></li><li><p><font color="#c00000">利用率</font></p><ul><li>分为信道利用率和网络利用率。</li><li><mark style="background: #BBFABBA6;"><font color="#c00000">信道利用率</font>指出某信道有百分之几的时间是被利用的（有数据通过）。</mark></li><li>完全空闲的信道的利用率是零。</li><li><font color="#c00000">网络利用率</font>则是全网络的信道利用率的加权平均值。</li><li><u>信道利用率并非越高越好</u>。当某信道的<u>利用率增大</u>时，该信道引起的<u>时延也就迅速增</u>加。</li><li><font color="#245bdb">时延与利用率的关系</font>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><msub><mi>D</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>−</mo><mi>U</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">D=\dfrac{D_{0}}{1-U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其中 D<sub>0</sub> 表示网络空闲时的时延，D 表示网络当前的时延，U 是网络的利用率，数值在 0 到 1 之间。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E6%97%B6%E5%BB%B6%E4%B8%8E%E5%88%A9%E7%94%A8%E7%8E%87.png" alt=""></li></ul></li></ol><h2 id="1-7-计算机网络体系结构">1.7 计算机网络体系结构</h2><ul><li><p>OSI 模型</p><ul><li>为了使不同体系结构的计算机网络都能互连，<font color="#245bdb">国际标准化组织 ISO</font>提出了一个试图使各种计算机在世界范围内互连成网的标准框架，即著名的<font color="#c00000">开放系统互连基本参考模型 OSI/RM</font> (Open Systems Interconnection Reference Model)，简称为 <font color="#c00000">OSI</font>。</li><li>只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。</li><li>OSI 只获得了一些理论研究的成果，在市场化方面却失败了。</li><li>非国际标准 TCP/IP 却获得了最广泛的应用。<mark style="background: #BBFABBA6;">TCP/IP 常被称为事实上的国际标准</mark>。</li></ul></li><li><p>协议与划分层次</p><ul><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">网络协议</font>：为进行网络中的数据交换而建立的规则、标准或约定，简称<font color="#245bdb">协议</font></mark></p></li><li><p>网络协议的三个组成要素：</p><ol><li><font color="#92d050">语法</font>：数据与控制信息的<font color="#245bdb">结构</font>或<font color="#245bdb">格式</font>。</li><li><font color="#92d050">语义</font>：需要发出何种<font color="#245bdb">控制信息</font>，完成何种<font color="#245bdb">动作</font>以及做出何种<font color="#245bdb">响应</font>。</li><li><font color="#92d050">同步</font>：<font color="#245bdb">事件实现顺序</font>的详细说明。</li></ol></li><li><p>对于非常复杂的计算机网络协议，其<font color="#245bdb">结构应该是层次式</font>的。</p></li><li><p><mark style="background: #BBFABBA6;">分层的好处：各层之间是独立的；灵活性好；结构上可分割开；易于实现和维护；能促进标准化工作。</mark></p></li><li><p>分层的坏处：<font color="#245bdb">降低了效率</font>；有些<font color="#245bdb">功能会在不同的层次中重复出现</font>，因而产生了额外开销。</p></li><li><p>各层完成的主要功能：</p><ul><li><font color="#c00000">差错控制</font>：使相应层次对等端的相应层次的通信更加可靠。</li><li><font color="#c00000">流量控制</font>：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li><font color="#245bdb">分段和重装</font>：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><font color="#245bdb">复用和分用</font>：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><font color="#245bdb">连接建立和释放</font>：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ul></li></ul></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">体系结构</font> (architecture)：计算机网络的各层及其协议的集合。</mark></p></li><li><p>换个说法，计算机网络体系结构就是这个计算机网络及其部件<font color="#245bdb">所应完成的功能的精确定义</font>。</p></li><li><p><font color="#245bdb">实现</font> (implementation) 是指在遵循这种体系结构的前提下，用何种硬件或软件完成这些功能的问题。</p></li><li><p>体系结构是<font color="#245bdb">抽象</font>的，而实现则是<font color="#245bdb">具体</font>的，是真正在运行的计算机硬件和软件。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p></li><li><p><font color="#c00000">具有五层协议的体系结构</font>综合了 OSI 七层协议与 TCP/IP 四层协议：</p><ul><li><font color="#92d050">应用层</font>：直接为用户的应用<font color="#245bdb">进程</font>提供服务。</li><li><font color="#92d050">运输层</font>：向两个主机中<font color="#245bdb">进程</font>之间的通信提供端到端的通信服务。</li><li><font color="#92d050">网络层</font>：负责为分组交换网上的不同<font color="#245bdb">主机</font>提供通信服务。网络层的另一个任务是<font color="#245bdb">选择合适的路由</font>，使源主机运输层传下来的分组，能够通过网络中的路由器找到目的主机。</li><li><font color="#92d050">数据链路层</font>：在两个<font color="#245bdb">相邻结点</font>间的线路上无差错地传送数据（点对点）。</li><li><font color="#92d050">物理层</font>：<font color="#245bdb">透明</font>地传送比特流。物理层还要确定<font color="#245bdb">连接电缆插头的定义及连接法</font>。</li><li>传递信息的物理媒体，如双绞线、同轴电缆、光缆等，在物理层的下面，当做第 0 层。</li></ul></li><li><p><font color="#c00000">透明</font>：指某一事物实际存在，但看起来却好像不存在一样。</p></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">协议数据单元 PDU</font>(Protocol Data Unit)：对等层实体之间进行信息交换的数据单位.</mark></p></li><li><p><font color="#c00000">对等层</font>(peer layer)：在网络体系结构中，通信双方实现同样功能的层。</p></li><li><p><font color="#c00000">协议栈</font>(protocol stack)：计算机网络体系结构采用了分层结构，因此不论在主机还是路由器中的协议都有好几层。这些一层一层的协议画起来很像堆栈的结构，因此把这些协议层称为协议栈。</p></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">实体</font>(entity)： 任何可发送或接收信息的硬件或软件进程。</mark></p></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">协议</font>(protocol)：控制两个对等实体（或多个实体）进行通信的规则的集合。 </mark></p></li><li><p><font color="#c00000">协议族</font>(protocol suite)：多个相关协议的集合。例如 TCP/IP 协议族。</p></li><li><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供<font color="#245bdb">服务</font>。</p></li><li><p>要实现本层协议，还需要使用下层所提供的服务。</p></li><li><p>网络协议必须把所有不利的情况都考虑到，而不能假定一切都是正常的和非常理想的。</p></li><li><p><strong>协议与服务的区别：</strong></p><ul><li><font color="#245bdb">协议的实现保证了本层能够向上一层提供服务</font>。</li><li>用户在本层只能看见下层提供的服务，而无法看见下面的协议。即下面的协议对上面的服务用户是透明的。</li><li>协议是“<font color="#245bdb">水平的</font>”，即协议是控制<font color="#245bdb">对等实体</font>之间通信的规则。</li><li>服务是“<font color="#245bdb">垂直的</font>”，即服务是由<font color="#245bdb">下层向上层</font>通过层间接口提供的。</li><li>上层使用<font color="#245bdb">服务原语</font>获得下层所提供的服务。</li></ul></li><li><p><font color="#c00000">服务原语</font>是指上层使用下层服务时与下层交换的一些命令。</p></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">服务访问点 SAP</font> (Service Access Point)：在同一系统中相邻两层的实体进行交互的地方。</mark></p></li><li><p>服务访问点 SAP 是一个抽象的概念, 它实际上就是一个逻辑接口。</p></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">服务数据单元 SDU </font>(Service Data Unit)：层与层之间进行信息交换的数据单位。</mark></p></li><li><p>SDU 与 PDU 不一样，可以多个 SDU 合成一个 PDU，也可以一个 SDU 划分为多个 PDU。</p></li><li><p><font color="#245bdb">everything over IP</font>——TCP/IP 协议可以<u>为各式各样的应用提供服务</u>。</p></li><li><p><font color="#245bdb"> IP over everything</font>——TCP/IP 协议允许 IP 协议<u>在各式各样的网络构成的互联网上运行</u>。</p></li></ul><h1 id="第-2-章物理层">第 2 章物理层</h1><h2 id="2-1-物理层的基本概念">2.1 物理层的基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上<font color="#245bdb">传输数据比特流</font>，而不是传输媒体。</li><li>物理层的<strong>作用</strong>是要尽可能地屏蔽掉不同<font color="#245bdb">传输媒体</font>和<font color="#245bdb">通信手段</font>的<font color="#245bdb">差异</font>。</li><li><strong>协议与规程的区别</strong>：<ul><li><font color="#c00000">协议</font> (protocol)：控制两个对等实体进行通信的规则的集合。</li><li><font color="#c00000">规程</font> (procedure)：用于<u>物理层</u>的<u>协议</u>。</li></ul></li><li>物理层的<strong>主要任务</strong>：确定与传输媒体的接口有关的一些特性。<ol><li><font color="#92d050">机械特性</font> ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</li><li><font color="#92d050">电气特性</font>：指明在接口电缆的各条线上出现的电压的范围。</li><li><font color="#92d050">功能特性</font>：指明某条线上出现的某一电平的电压的意义。</li><li><font color="#92d050">过程特性</font> ：指明对于不同功能的各种可能事件的出现顺序。</li></ol></li></ul><h2 id="2-2-数据通信的基础知识">2.2 数据通信的基础知识</h2><ul><li><p><font color="#c00000">数据通信系统</font></p><ul><li>一个数据通信系统包括三大部分：<font color="#245bdb">源系统</font>（或发送端、发送方）、<font color="#245bdb">传输系统</font>（或传输网络）和<font color="#245bdb">目的系统</font>（或接收端、接收方）。</li><li>源系统一般包括以下两个部分：<ol><li><font color="#245bdb">源点</font>：源点设备产生要传输的数据。也称<font color="#245bdb">源站</font>，或<font color="#245bdb">信源</font>。举例：PC 键入汉字产生数字比特流。</li><li><font color="#245bdb">发送器</font>：源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。<u>典型的发送器就是调制器</u>。</li></ol></li><li><font color="#245bdb">目的系统</font>一般也包括两个部分：<ol><li><font color="#245bdb">接收器</font>：接受传输系统传送过来的信号，转化为能够被目的设备处理的信息。<u>典型的接收器就是解调器。</u></li><li><font color="#245bdb">终点</font>：终点设备从接收器获取传送过来的数字比特流，然后把信息输出。又称<font color="#245bdb">目的站</font>或<font color="#245bdb">信宿</font>。</li></ol></li></ul></li><li><p>几个常用术语：</p><ul><li>通信的目的是传送<font color="#245bdb">消息</font> (message)，如语音、文字等。</li><li><font color="#c00000">数据</font> (data) —— 运送消息的实体。</li><li><font color="#c00000">信号</font> (signal) —— 数据的电气的或电磁的表现。</li><li><font color="#c00000">模拟数据</font> —— 即<font color="#00b050">连续数据</font>，即数据的变化是<font color="#245bdb">连续</font>的。</li><li><font color="#c00000">模拟信号</font> —— 即<font color="#00b050">连续信号</font>，其特点是<u>代表消息的参数的取值</u>是<font color="#245bdb">连续</font>的。</li><li><font color="#c00000">数字数据</font> —— 即<font color="#00b050">离散数据</font>，即数据的变化是<font color="#245bdb">离散</font>的。</li><li><font color="#c00000">数字信号</font> —— 即<font color="#00b050">离散信号</font>，其特点是代表消息的参数的取值是<font color="#245bdb">离散</font>的。</li><li><font color="#c00000">码元</font> (code) —— 码是信号元素和字符之间事先约定好的转换，而码元实质就是码所包含的元素。</li><li>在采用最简单的二进制编码时，一个码元就是一个比特。例如 A 字母在 ASCII 编码中的二进制表示是 1000001，这里的每一个 1 和 0 都是码元。但在比较复杂的编码中，一个码元可以包含多个比特。</li></ul></li><li><p>有关信道的几个概念：</p><ul><li><font color="#c00000">信道</font> (channel) —— 一般用来表示向某一个方向传送信息的媒体。</li><li>通信双方信息交互的三种基本方式：<ul><li><font color="#c00000">单向通信</font>（<font color="#00b050">单工通信</font>）——只能有<u>一个方向的通信</u>而<u>没有反方向的交互</u>。（例如电视广播）</li><li><font color="#c00000">双向交替通信</font>（<font color="#00b050">半双工通信</font>）——通信的<u>双方都可以发送</u>信息，但<u>不能双方同时发送</u>（当然也就不能同时接收）。</li><li><font color="#c00000">双向同时通信</font>（<font color="#00b050">全双工通信</font>）——通信的双方可以<u>同时发送和接收</u>信息。</li></ul></li><li><font color="#c00000">基带信号</font>（即基本频带信号）—— 来自信源的信号。<ul><li>像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li><li>基带信号往往包含有较多的<font color="#245bdb">低频</font>成分，甚至有<font color="#245bdb">直流</font>成分，而许多信道并不能传输这种低频分量或直流分量。因此<u>必须对基带信号进行<font color="#c00000">调制</font></u>  (modulation)。</li></ul></li><li>调制分为两大类：<ul><li><font color="#c00000">基带调制</font>：仅对基带信号的<font color="#245bdb">波形</font>进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为<font color="#c00000">编码</font> (coding)。</li><li><font color="#c00000">带通调制</font>：使用<font color="#245bdb">载波 </font>(carrier)进行调制，把基带信号的频率范围搬移到较高的<u>频段</u>，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道）。</li></ul></li><li><font color="#c00000">带通信号</font> ：经过载波调制后的信号。</li></ul></li><li><p>常用的编码方法：</p><ul><li><font color="#00b050">不归零制</font>：正电平代表 1，负电平代表 0。</li><li><font color="#00b050">归零制</font>：正脉冲代表 1，负脉冲代表 0。</li><li><font color="#00b050">曼彻斯特编码</font>：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。可反过来定义。</li><li><font color="#00b050">差分曼彻斯特编码</font>：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95.png" alt=""></li><li>从信号波形中可以看出，曼彻斯特、编码和差分曼彻斯特编码产生的信号<u>频率比不归零制高</u>。</li><li>从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫做没有自同步能力），而曼彻斯特编码和差分曼彻斯特编码<u>具有自同步能力</u>。</li></ul></li><li><p>最基本的带通调制方法：</p><ol><li><font color="#92d050">调幅</font> (AM)：载波的<font color="#245bdb">振幅</font>随基带数字信号而变化。</li><li><font color="#92d050">调频</font> (FM)：载波的<font color="#245bdb">频率</font>随基带数字信号而变化。</li><li><font color="#92d050">调相</font> (PM) ：载波的<font color="#245bdb">初始相位</font>随基带数字信号而变化。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%B8%89%E7%A7%8D%E8%B0%83%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt=""></li></ol></li><li><p><strong>信道的极限容量</strong></p><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种<font color="#245bdb">失真</font>以及带来多种<font color="#245bdb">干扰</font>。</li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在输出端的波形的失真就越严重。</li><li>数字信号通过实际的信道：</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%B1%E7%9C%9F.png" alt=""></li><li><strong>限制码元在信道中的传输速率的因素</strong>有以下两个：<ol><li><font color="#245bdb">信道能通过的频率范围 </font><ul><li>具体的信道所能通过的<u>频率范围</u>（带宽）总是有限的。信号中的许多<u>高频分量</u>往往不能通过信道。</li><li><mark style="background: #FFF3A3A6;"><font color="#c00000">奈氏准则</font>给出了在假定的理想条件下，为了避免<u>码间串扰</u>，<u>码元</u>的传输速率的上限值</mark>。<ul><li><mark style="background: #BBFABBA6;">理想低通信道的最高码元传输速率 = 2 W (Baud)</mark><u></u><ul><li>这里 W 是理想低通信道的带宽，单位为赫 (Hz)；</li><li>Baud 是<font color="#245bdb">波特</font>, 是码元传输速率的单位，1 波特即每秒传送 1 个码元。</li></ul></li></ul></li><li>另一种表达方法：每赫带宽的理想低通信道的最高码元传输速率是每秒 2 个码元。</li><li>如果信道的<u>频带越宽</u>（W 越大），就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><font color="#245bdb">信噪比</font><ul><li><font color="#c00000">信噪比</font>就是<font color="#245bdb">信号的平均功率 S</font>和<font color="#245bdb">噪声的平均功率 N</font>之比，记为 S/N。</li><li>用<u>分贝 </u>(dB) 作为度量单位：<mark style="background: #BBFABBA6;">信噪比 (dB) = 10 log<sub>10</sub> (S/N ) (dB) </mark><ul><li>例如，当 S/N=10 时，信噪比为 10 dB，而当 S/N=1000 时，信噪比为 30 dB。</li></ul></li><li><mark style="background: #FFF3A3A6;"><font color="#c00000">香农公式</font>推导出<u>带宽受限</u>且有<u>高斯白噪声干扰</u>的信道的<u>极限</u>、<u>无差错</u>的信息传输速率</mark>。<ul><li><font color="#245bdb">信道的极限信息传输速率 C</font> 可表达为：<mark style="background: #BBFABBA6;">C  = W log<sub>2</sub> (1+S/N)   (b/s) </mark></li><li>其中：W 为信道的带宽（以 Hz 为单位）；S/N 为信道的信噪比。</li></ul></li><li>香农公式表明：<ul><li><mark style="background: #BBFABBA6;">信道的<u>带宽 W </u>或信道中的<u>信噪比 S/N</u> 越大，则<u>信息的极限传输速率 C </u>就越高。 </mark></li><li>只要信息传输速率低于信道的极限信息传输速率 C，就一定可以找到某种办法来实现<u>无差错的传输</u>。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率<u>低</u>不少。</li></ul></li></ul></li></ol><ul><li>综上，对于带宽已经确定的信道，当信噪比不能再提升时，而且码元的传输速率也已经到达了上限值，如何提高信息的传输速率？答：<u>让一个码元携带更多比特的信息量</u>。</li><li>这里的带宽 W 是指<u>频率带宽</u>而不是数据的发送速率。</li></ul></li></ul></li></ul><h2 id="2-3-物理层下面的传输媒体">2.3 物理层下面的传输媒体</h2><ul><li><p><font color="#c00000">传输媒体</font>：数据传输系统在<u>发送器</u>和<u>接收器</u>之间的<u>物理通路</u>，也称<font color="#c00000">传输介质</font>或<font color="#c00000">传输媒介</font>。</p></li><li><p>传输媒体分为两大类：</p><ol><li><font color="#c00000">导向传输媒体</font>：电磁波被导向沿着固体媒体（铜线或光纤）传播。</li><li><font color="#c00000">非导向传输媒体</font>：指自由空间，在非导向传输媒体中电磁波的传输常称为<font color="#245bdb">无线传输</font>。</li></ol></li><li><p><strong>导向传输媒体</strong></p><ol><li><font color="#c00000">双绞线</font>：把两根互相绝缘的铜导线并排放在一起，用规则的方法进行<font color="#245bdb">绞合</font>起来。<ul><li><u>最常用</u>的传输媒体。</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为<u>几到十几公里</u>。</li><li><font color="#c00000">屏蔽双绞线 STP</font> (Shielded Twisted Pair)：带金属屏蔽层，价格更贵。</li><li><font color="#c00000">无屏蔽双绞线 UTP</font> (Unshielded Twisted Pair)</li></ul></li><li><font color="#c00000">同轴电缆</font>：由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层和塑料保护外层组成。<ul><li>同轴电缆具有很好的<u>抗干扰</u>特性，被广泛用于传输<u>较高速率</u>的数据。</li></ul></li><li><font color="#c00000">光缆</font><ul><li>光纤是光纤通信的传输媒体。</li><li>由于可见光的频率非常高，约为 108 MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</li><li><font color="#c00000">多模光纤</font>：可以存在<u>多条</u>不同角度入射的光线在一条光纤中传输。</li><li><font color="#c00000">单模光纤</font>：光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一<u>直向前传播</u>，而不会产生多次反射。</li><li>光纤的优点：通信容量非常大；传输损耗小，中继距离长；抗雷电和电磁干扰性能好；无串音干扰，保密性好；体积小，重量轻。</li></ul></li></ol></li><li><p><strong>非导向传输媒体</strong></p><ul><li>将<font color="#245bdb">自由空间</font>称为“非导引型传输媒体”。</li><li>无线传输所使用的<u>频段很广</u>。</li><li><font color="#245bdb">短波通信</font>（即高频通信）主要是靠<font color="#245bdb">电离层的反射</font>，但短波信道的通信<u>质量较差</u>，<u>传输速率低</u>。</li><li>微波在空间主要是<u>直线传播</u>。</li><li>传统微波通信有两种方式：<ol><li><font color="#245bdb">地面微波接力通信</font></li><li><font color="#245bdb">卫星通信</font></li></ol></li></ul></li></ul><h2 id="2-4-信道复用技术">2.4 信道复用技术</h2><ul><li><p><font color="#c00000">复用</font> (multiplexing) 是通信技术中的基本概念。它<mark style="background: #BBFABBA6;">允许用户使用一个<font color="#245bdb">共享信道</font>进行通信，降低成本，提高利用率。</mark></p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%A4%8D%E7%94%A8.png" alt=""></p></li><li><p><font color="#c00000">频分复用</font> <font color="#00b050">FDM</font> (Frequency Division Multiplexing)</p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>频分复用的所有用户在<font color="#245bdb">同样的时间</font>占用<font color="#245bdb">不同的带宽资源</font>（请注意，这里的“带宽”是<u>频率带宽</u>而不是数据的发送速率）。</li></ul></li><li><p><font color="#c00000">时分复用</font> <font color="#00b050">TDM</font> (Time Division Multiplexing)</p><ul><li>时分复用则是将时间划分为一段段等长的<font color="#00b050">时分复用帧</font>（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）的。</li><li>TDM 信号也称为<font color="#00b050">等时</font> (isochronous) 信号。</li><li>时分复用的所有用户在<font color="#245bdb">不同的时间</font>占用<font color="#245bdb">同样的频带宽度</font>。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt=""></li><li>时分复用会造成线路资源浪费：</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E5%BC%95%E8%B5%B7%E7%9A%84%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9.png" alt=""></li></ul></li><li><p><font color="#c00000">统计时分复用</font> <font color="#00b050">STDM</font>  (Statistic TDM)</p><ul><li>统计时分复用是一种改进过的时分复用，它能明显地<u>提高</u>信道的<u>利用率</u>。</li><li>STDM 帧不是<u>固定分配</u>时隙，而是<u>按需动态地</u>分配时隙。</li><li>在输出线路上，某一个用户所占用的时隙并<u>不是周期性</u>地出现，因此统计时分复用又称为<font color="#245bdb">异步时分复用</font>，而普通时分复用称为<font color="#245bdb">同步时分复用</font>。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/STDM.png" alt=""></li></ul></li><li><p><font color="#c00000">波分复用</font> <font color="#00b050">WDM</font> (Wavelength Division Multiplexing)：</p><ul><li>波分复用就是<font color="#245bdb">光的频分复用</font>。</li></ul></li><li><p><font color="#c00000">码分复用</font> <font color="#00b050">CDM</font>  (Code Division Multiplexing)</p><ul><li>人们常用的名词是<font color="#c00000">码分多址 </font><font color="#00b050">CDMA</font> (Code Division Multiple Access)。</li><li>码分复用的每一个用户可以在<font color="#245bdb">同一个时间</font>使用<font color="#245bdb">同样的频带</font>进行通信。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>工作原理：<ul><li>每一个比特时间划分为 m 个短的间隔，称为<font color="#c00000">码片</font> (chip)。</li><li>使用 CDMA 的每个站被指派一个唯一的 m bit <font color="#c00000">码片序列 </font>(chip sequence)。<ul><li>如要发送<u>比特 1</u>，则发送自己的 m bit <u>码片序列</u>。</li><li>如要发送<u>比特 0</u>，则发送<u>该码片序列的二进制反码</u>。</li></ul></li><li>CDMA 的重要特点：每个站分配的码片序列不仅必须<u>各不相同</u>，并且还必须<u>互相正交 </u>。在实用的系统中是使用<font color="#245bdb">伪随机码序列</font>。</li><li>码片序列的<font color="#245bdb">正交</font>关系：<br>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。<br><u> 两个不同站的码片序列正交</u>，就是向量 S 和 T 的<font color="#245bdb">规格化内积</font> (inner product)都是 0：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext mathvariant="bold">S</mtext><mo>∙</mo><mtext mathvariant="bold">T</mtext><mo>≡</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\textbf{S}\bullet\textbf{T}\equiv\frac{1}{m}\sum_{i=1}^m S_i T_i=0\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.2291em;vertical-align:-1.3645em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8645em;"><span style="top:-3.8645em;"><span class="pstrut" style="height:3.6514em;"></span><span class="mord"><span class="mord text"><span class="mord textbf">S</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∙</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord textbf">T</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3645em;"><span></span></span></span></span></span></span></span></span></span></span><br>例如，向量 S 为 (–1 –1 –1 +1 +1 –1 +1 +1)，向量 T 为 (–1 –1 +1 –1 +1 +1 +1 –1)。<br>带入上式就可看出这两个码片序列是正交的（对应相乘，相加为 0）。</li><li>正交关系的另一个重要特性：<br>任何一个码片向量和该码片向量自己的规格化内积都是 1 。<br>任何一个码片向量和该码片反码的向量的规格化内积值是 –1。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/CDMA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></li><li>X 站要接收 S 站的发送的数据，就必须要知道 S 站特有的码片序列，使用其与接收到未知信号进行求内积的运算。这样其他站点的信号都会被滤掉，只剩下 S 站的信号。S 站发送的是 1，在 X 站计算内积的结果就是 +1，发送的是 0，接收到的就是-1。</li><li>比如，S 站要给 X 站发送 110 三个码元：<ul><li>假设一个码元被扩展为 8 个码片（m = 8）。</li><li>S 站的码片序列为：(–1 –1 –1 +1 +1 –1 +1 +1) 。即：00011011。</li><li>S 站发送的扩频信号 S<sub>x</sub>中，用 S 站的<u>码片序列</u>表示 1，用 S 站的<u>码片序列的反码</u>表示 0。</li><li>T 站的码片序列是 (–1 –1 +1 –1 +1 +1 +1 –1)。T 站也发送 110 三个码元。</li><li>因为所有的站都使用相同的频率，所以所有站点（包括 X）会收到叠加信号 S<sub>x</sub> + T<sub>x</sub></li><li>因为要接收 S 站的信号，所以 X 站用 S 站的码片序列与收到的信号 S<sub>x</sub> + T<sub>x</sub> 进行规格化内积，这相当于分别就算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∗</mo><mi>S</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">S*Sx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∗</mo><mi>T</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">S*Tx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">x</span></span></span></span> 。前者会得到 S 站发送的数据比特，而后者一定是 0。则 X 收到了 S 站的数据，但收不到 T 站的数据。</li></ul></li></ul></li></ul></li><li><p>课后题 2-16：共有 4 个站进行码分多址通信。4 个站的码片序列为：<br>A：（－1－1－1＋1＋1－1＋1＋1） B：（－1－1＋1－1＋1＋1＋1－1）<br>C：（－1＋1－1＋1＋1＋1－1－1） D：（－1＋1－1－1－1－1＋1－1）<br>现收到这样的码片序列 S：（－1＋1－3＋1－1－3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是 0 还是 1？<br>解：求内积：<br>S·A=（＋1－1＋3＋1－1＋3＋1＋1）／8=1， A 发送 1<br>S·B=（＋1－1－3－1－1－3＋1－1）／8=-1， B 发送 0<br>S·C=（＋1＋1＋3＋1－1－3－1－1）／8=0， C 无发送<br>S·D=（＋1＋1＋3－1＋1＋3＋1－1）／8=1， D 发送 1</p></li></ul><h2 id="2-5-数字传输系统">2.5 数字传输系统</h2><ul><li><p><font color="#c00000">脉码调制 PCM </font> 体制最初是为了在电话局之间的中继线上传送多路的电话。</p></li><li><p>由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路 PCM（简称为 T 1）和欧洲的 30 路 PCM（简称为 E 1）。<u>我国采用的是欧洲的 E 1 标准</u>。</p></li><li><p>E 1 的速率是 2.048 Mb/s，而 T 1 的速率是 1.544 Mb/s。</p></li><li><p>旧的数字传输系统存在着许多缺点。其中最主要的是以下两个方面：</p><ul><li><font color="#245bdb">速率标准不统一</font></li><li><font color="#245bdb">不是同步传输</font></li></ul></li><li><p><font color="#c00000">同步光纤网 SONET</font> (Synchronous Optical Network)</p><ul><li>SONET 的各级时钟都来自一个非常精确的主时钟。</li><li>SONET 为光纤传输系统定义了同步传输的线路速率等级结构：<ol><li>对电信信号称为第 1 级<font color="#245bdb">同步传送信号</font> STS-1 ，其传输速率是 51.84 Mbit/s。</li><li>对光信号则称为第 1 级<font color="#245bdb">光载波</font> OC-1 (OC 表示 Optical Carrier)。</li></ol></li></ul></li><li><p><font color="#c00000">同步数字系列 SDH</font> (Synchronous Digital Hierarchy)</p><ul><li>一般可认为 SDH 与 SONET 是同义词。</li><li>其主要不同点是：SDH 的基本速率为 155.52 Mbit/s，称为<font color="#c00000">第 1 级同步传递模块 STM-1</font>，相当于 SONET 体系中的 OC-3 速率。</li></ul></li><li><p>SONET / SDH 标准的意义：</p><ul><li>使不同的数字传输体制在 STM-1 等级上获得了统一。</li><li>第一次真正实现了数字传输体制上的世界性标准。</li><li>已成为公认的新一代理想的传输网体制。</li><li>SDH 标准也适合于微波和卫星传输的技术体制。</li></ul></li></ul><h2 id="2-6-宽带接入技术">2.6 宽带接入技术</h2><ul><li><p><font color="#c00000">xDSL</font> 技术：就是用数字技术对<u>现有的模拟电话用户线</u>进行改造，使它能够承载宽带业务。</p></li><li><p><font color="#c00000">DSL——数字用户线</font> (Digital Subscriber Line) ，前缀 x 表示在数字用户线实现的不同宽带方案。</p></li><li><p>xDSL 技术就把 0~4 kHz <u>低端频谱</u>留给<u>传统电话</u>使用，而把原来没有被利用的<u>高端频谱</u>留给<u>用户上网</u>使用。</p></li><li><p><font color="#c00000">ADSL 非对称数字用户线</font></p><ul><li>ADSL 的<u>极限传输距离</u>与<u>数据率</u>以及用户线的<u>线径</u>都有很大的关系（用户线<u>越细</u>，信号传输时的<u>衰减就越大</u>），而所能得到的<u>最高数据传输速率</u>与实际的用户线上的<u>信噪比</u>密切相关。</li><li>ADSL 的特点：<ul><li><font color="#245bdb">上行</font>和<font color="#245bdb">下行</font>带宽做成不对称的。上行指从用户到 ISP，而下行指从 ISP 到用户。</li><li>ADSL 在用户线（铜线）的两端各安装一个 <font color="#245bdb">ADSL 调制解调器</font>。</li><li>我国目前采用的方案是<font color="#245bdb">离散多音调 DMT</font> (Discrete Multi-Tone)调制技术。这里的“多音调”就是“<font color="#245bdb">多载波</font>”或“<font color="#245bdb">多子信道</font>”的意思。</li></ul></li><li><font color="#c00000">离散多音调 DMT</font> (Discrete Multi-Tone)调制技术：<ul><li>DMT 调制技术采用<u>频分复用</u>的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。</li><li>每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器<font color="#245bdb">并行地</font>传送数据。</li></ul></li><li>ADSL 的数据率：<ul><li>由于用户线的具体条件往往相差很大（距离、线径、受到相邻用户线的干扰程度等都不同），因此 ADSL 采用<font color="#245bdb">自适应调制技术</font>使用户线能够传送尽可能高的数据率。</li><li>当 ADSL 启动时，用户线两端的 ADSL 调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。</li><li><u>ADSL 不能保证固定的数据率</u>。对于质量很差的用户线甚至无法开通 ADSL。</li><li>通常下行数据率在 32 kbit/s 到 6.4 Mbit/s 之间，而上行数据率在 32 kbit/s 到 640 kbit/s 之间。</li></ul></li><li>ADSL 的组成：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ADSL%E7%9A%84%E7%BB%84%E6%88%90.png" alt=""></li><li>第二代 ADSL<ul><li>包括 ADSL 2（G.992.3 和 G.992.4）和 ADSL 2+（G.992.5）。</li><li>通过提高调制效率得到了<u>更高的数据率</u>。</li><li>采用了<font color="#245bdb">无缝速率自适应技术 SRA </font>(Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</li><li>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。</li></ul></li></ul></li><li><p><font color="#c00000">光纤同轴混合网（HFC 网）</font></p><ul><li>HFC (Hybrid Fiber Coax) 网是在目前覆盖面很广的<font color="#245bdb">有线电视网 CATV </font>的基础上开发的一种居民宽带接入网。</li><li>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</li><li>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。 <u>HFC 网对 CATV 网进行了改造</u>。</li><li>HFC 网将原 CATV 网中的同轴电缆<font color="#245bdb">主干部分改换为光纤</font>，并使用<font color="#245bdb">模拟光纤技术</font>。</li><li>在模拟光纤中采用<font color="#245bdb">光的振幅调制 AM</font>，这比使用数字光纤更为经济。</li><li>模拟光纤从<font color="#245bdb">头端</font>连接到<font color="#245bdb">光纤结点</font> (fiber node)，即<font color="#245bdb">光分配结点 ODN</font> (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。</li><li>HFC 网采用<font color="#c00000">结点体系结构</font>(node architecture)，即从头端到各个光纤结点用模拟光纤连接，构成星型网。光纤结点以下是同轴电缆组成的树形网。</li><li>HFC 网具有比 CATV 网<font color="#245bdb">更宽的频谱</font>，且具有<font color="#245bdb">双向传输</font>功能。</li><li>每个家庭要安装一个用户接口盒，<font color="#c00000">用户接口盒 UIB </font>(User Internet Box) 提供三种连接：<ol><li>使用同轴电缆连接到<font color="#c00000">机顶盒</font> (set-top box)，然后再连接到用户的电视机。</li><li>使用双绞线连接到用户的电话机。</li><li>使用<font color="#245bdb">电缆调制解调器</font>连接到用户的计算机。</li></ol></li><li><font color="#245bdb">电缆调制解调器</font>是为 HFC 网而使用的调制解调器。<ul><li>电缆调制解调器最大的特点就是传输速率高。</li><li>电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在用户端。</li></ul></li><li>HFC 网的最大优点： 具有<font color="#245bdb">很宽的频带</font>，并且能够利用已经有相当大的覆盖面的有线电视网。</li></ul></li><li><p><font color="#c00000">FTTX 技术</font></p><ul><li>FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。</li><li>FTTx 表示 Fiber To The…（光纤到…），例如：<ul><li>光纤到户 FTTH (Fiber To The Home)</li><li>光纤到大楼 FTTB (Fiber To The Building)</li><li>光纤到路边 FTTC (Fiber To The Curb)</li></ul></li></ul></li><li><p>课后题 2-17：试比较 xDSL、HFC 以及 FTTx 接入技术的优缺点。</p><ul><li>使用 xDSL 最大的好处就是可以<u>利用现有电话网中的用户线，不需要重新布线</u>。用户可以根据自己的情况使用不同速率的宽带接入（按带宽付费）。这种接入的缺点就是<u>对用户线的质量有较高的要求</u>。如果用户住宅距离电话交换局较远，或线路的噪声较大，那么宽带接入的速率就会适当地降低。</li><li>HFC 的优点是<u>覆盖面很广</u>，井且其<u>宽带也很高</u>，<u>可以传送很高速率的数据</u>。缺点是<u>必须对现有单向传输的有线电缆进行改造，变为可双向通信的电缆</u>。用户家中需要增加一个机顶盒，用来观看电视和传送上行信号（在点播节目时使用） 。此外，为了解决信<u>号传输时有衰减</u>的问题，在有线电缆中每隔一定距离就要加入一个放大器。<u>大量放大器的接入将使整个网络的可靠性下降</u>。</li><li>光纤接入 FTTx 是解决宽带接入<u>最理想的</u>方案，因为<u>光纤可传送的数据率很高</u>，且通<u>信质量最好</u>。但大量用户使用光纤接入还需要<u>较多的建设资金</u>。</li></ul></li></ul><h1 id="第-3-章数据链路层">第 3 章数据链路层</h1><ul><li>数据链路层使用的信道主要有以下两种类型：<ul><li><font color="#c00000">点对点信道</font>——这种信道使用<font color="#245bdb">一对一</font>的<font color="#245bdb">点对点通信</font>方式。</li><li><font color="#c00000">广播信道</font>——这种信道使用<font color="#245bdb">一对多</font>的<font color="#245bdb">广播通信</font>方式。</li></ul></li></ul><h2 id="3-1使用点对点信道的数据链路层">3.1使用点对点信道的数据链路层</h2><ul><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">链路</font> (link) 是一条从一个<font color="#245bdb">结点到相邻结点</font>的一段<font color="#245bdb">物理线路</font>，中间没有任何其他的<font color="#245bdb">交换结点</font>。</mark></p></li><li><p><mark style="background: #FFF3A3A6;"><font color="#c00000">数据链路</font> (data link) 除了<font color="#245bdb">物理线路</font>外，还必须有<font color="#245bdb">通信协议</font>来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</mark></p></li><li><p><mark style="background: #ABF7F7A6;"><font color="#245bdb">适配器</font>（即<font color="#245bdb">网卡</font>）：实现<font color="#245bdb">数据链路层</font>和<font color="#245bdb">物理层</font>这两层协议的硬件和软件。</mark></p></li><li><p>点对点信道的数据链路层的协议数据单元——<font color="#c00000">帧</font></p></li><li><p>三个基本问题：<font color="#00b050">封装成帧</font>、<font color="#00b050">透明传输</font>、<font color="#00b050">差错检测</font>。</p><ol><li><strong>封装成帧</strong><ul><li><mark style="background: #BBFABBA6;"><font color="#c00000">封装成帧</font> (framing) 就是在一段数据的前后分别添加<font color="#245bdb">首部</font>和<font color="#245bdb">尾部</font>，然后就构成了一个帧。首部和尾部的一个重要作用就是进行<font color="#c00000">帧定界</font>。</mark></li><li>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</li><li>网络层的 IP 数据报传送到数据链路层就成了帧的数据部分。</li><li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能的大于首部和尾部的长度。</li><li><mark style="background: #BBFABBA6;"><font color="#c00000">最大传输单元 MTU</font> (Maximum Transfer Unit)：帧的数据部分的长度上限。</mark></li><li><font color="#c00000">帧定界符</font>：标志一个帧的开始和结束的字符。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E7%94%A8%E5%B8%A7%E9%A6%96%E9%83%A8%E5%92%8C%E5%B8%A7%E5%B0%BE%E9%83%A8%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png" alt=""><br>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的<font color="#c00000">帧定界符</font>：</li><li>控制字符<font color="#c00000"> SOH</font> (Start Of Header) 放在帧的最前面，表示帧的首部的开始。</li><li>控制字符 <font color="#c00000">EOT</font> (End Of Transmission) 放在帧的末尾，表示帧的结束。</li><li>SOH 用二进制 00000001 表示，EOT 用二进制 00000000 表示。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%B8%A7%E5%AE%9A%E7%95%8C.png" alt=""></li></ul></li><li><strong>透明传输</strong><ul><li>“<font color="#c00000">透明</font>”指某一个实际存在的事物看起来却好像不存在一样。</li><li><mark style="background: #BBFABBA6;">“在数据链路层<u>透明传送</u>数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。</mark></li><li>而如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，就会发生错误。</li><li>解决透明传输的方法： <font color="#ff0000">字节填充</font> (byte stuffing) 或<font color="#ff0000">字符填充</font> (character stuffing)。<ol><li><u>发送端</u>的数据链路层在数据中出现控制字符“SOH”或“EOT”的<u>前面插入</u>一个<font color="#245bdb">转义字符</font>“ESC”(其十六进制编码是 1B)。</li><li><u>接收端</u>的数据链路层在将数据送往网络层之前<u>删除</u>插入的转义字符。</li></ol><ul><li>如果转义字符 ESC 也出现在数据当中，那么应在转义字符前面<u>再插入</u>一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E7%94%A8%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E6%B3%95%E8%A7%A3%E5%86%B3%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93%E7%9A%84%E9%97%AE%E9%A2%98.png" alt=""></li></ul></li></ul></li><li><strong>差错检测</strong><ul><li><p>背景</p><ul><li>现实通信链路不是理想的，在传输过程中可能会产生<font color="#c00000">比特差错</font>：即1 可能会变成 0 而 0 也可能变成 1。</li><li><font color="#c00000">误码率 BER</font> (Bit Error Rate)：一段时间内，传输错误的比特占所传输比特总数的比率。</li><li>误码率与信噪比有很大的关系。</li><li>在数据链路层传送的帧中，广泛使用了<font color="#c00000">循环冗余检验 CRC</font> 的检错技术。</li></ul></li><li><p><strong>循环冗余检验 CRC 的原理</strong></p><ul><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C%20CRC.png" alt=""></li><li>在发送端，先把数据划分为组，假定每组 k 个比特。<ul><li>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位<font color="#245bdb">冗余码</font>一起发送。</li><li>关于冗余码的计算：<ol><li>用二进制的模 2 运算进行 2<sup>n</sup> 乘 M 的运算，这相当于<u>在 M 后面添加 n 个 0</u>。</li><li>得到的 (k + n) 位的数<u>除以</u>事先选定好的长度为<u> (n + 1) 位的除数 P</u>，得出<u>商是 Q</u> 而<u>余数是 R</u>，<u>余数 R 比除数 P 少 1 位</u>，即 R 是 n 位。</li><li>将<u>余数 R 作为冗余码</u>拼接在数据 M 后面，一起发送出去。</li></ol></li></ul></li><li>在接收端对收到的每一帧进行 CRC 检验：<ul><li>若得出的<u><font color="#245bdb">余数</font> R = 0</u>，则判定这个帧没有差错，就<u>接受</u> (accept)。</li><li>若<u>余数 R ≠ 0</u>，则判定这个帧有差错，就<u>丢弃</u>。</li></ul></li></ul></li><li><p>冗余码的计算举例：现在假定 k = 6, 待发送数据某分组 M = 101001。规定除数 P = 1101，求冗余码。解：</p><ol><li>冗余码比除数少一位，P =1101 是 4 位，所以 n=3</li><li>被除数是 2<sup>n</sup>M = 101001<u>000</u>。 （在 M 后加 n 个 0）</li><li>用被除数 101001<u>000</u> 除以除数 P=1101，得到商 Q = 110101，余数 R = 001。</li><li>则 M 的冗余码是 001，把它加在 M 后面即：101001<u>001</u>发送出去。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E6%8E%A5%E6%94%B6%E7%AB%AF%E6%A3%80%E9%AA%8CCRC.png" alt=""></li></ol><ul><li>注意，做除法运算时，这里采用模 2 运算进行加减法，即<font color="#00b050">不借位</font>（可以理解为<u>按位异或</u>：相同为 0，不同为 1），凑够 4 位且高位是 1 就可以理解为够除。<ul><li>按位异或：0^ 0 = 0, 1 ^ 1 = 0， 0 ^ 1 = 1, 1 ^ 0 = 1。</li></ul></li><li>接收端收到数据后，用收到的101001001 作为被除数，用约定好的 P 做除数，再进行运算，看得到的余数是否为 0 即可检验 M 是否发生了比特差错。</li></ul></li><li><p>一种较简便的方法使用<font color="#245bdb">多项式来表示循环冗余检验</font>的过程：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>X</mi><mn>3</mn></msup><mo>+</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">P (X)=X^3+X^2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 等价于 P=1101（最高位对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，最低位对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>）</p></li><li><p><font color="#c00000">帧检验序列 FCS</font> (Frame Check Sequence)：即在数据后面添加上的<font color="#245bdb">冗余码</font>。</p></li><li><p>循环冗余检验 CRC 和帧检验序列 FCS <u>并不等同</u>。</p><ul><li>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。</li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。</li></ul></li><li><p>应当注意：</p><ol><li>CRC 检测方法<u>并不能</u>确定究竟是哪一个或哪几个 bit 出现了差错。（错了但不知道错哪）</li><li>仅用循环冗余检验 CRC 差错检测技术只能做到<font color="#c00000">无差错接受</font> (accept)。</li><li>“<font color="#245bdb">无差错接受</font>”是指：“凡是<font color="#245bdb">接受</font>的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。而有差错的帧就<font color="#245bdb">丢弃</font>而不接受。</li><li>单纯使用 CRC 差错检测技术<u><font color="#245bdb">不能</font></u>实现“<font color="#245bdb">无差错传输</font>”或“<font color="#245bdb">可靠传输</font>”。</li><li>在数据链路层使用 CRC 检验，能够实现<font color="#245bdb">无比特差错</font>的传输，但这还<font color="#245bdb"><u>不是可靠传输</u>。</font></li><li>要做到“<font color="#245bdb">无差错传输</font>”（即发送什么就收到什么）就必须再加上<font color="#245bdb">确认</font>和<font color="#245bdb">重传机制</font>。</li><li>本章介绍的数据链路层协议<u>都不是可靠传输</u>的协议。</li></ol></li></ul></li></ol></li></ul><h2 id="3-2-点对点协议-PPP">3.2 点对点协议 PPP</h2><ul><li><p><font color="#c00000">高级数据链路控制协议 HDLC</font>：一种可靠协议，应用在通信链路质量差的年代。</p></li><li><p><font color="#c00000">点对点协议 PPP</font> (Point-to-Point Protocol)：目前使用得最广泛的数据链路层协议，用于<font color="#245bdb">点对点</font>的链路。</p></li><li><p>PPP 协议就是<u><font color="#245bdb">用户计算机</font>和<font color="#245bdb"> ISP</font> 进行通信时</u>所使用的数据链路层协议。</p></li><li><p>PPP 协议应该满足的要求：</p><ol><li>简单 —— 这是首要的要求。</li><li>封装成帧 —— 必须规定特殊的字符作为帧定界符。</li><li>透明性 —— 必须保证数据传输的透明性。</li><li>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。</li><li>多种类型链路 —— 能够在多种类型的链路上运行。</li><li>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。</li><li>最大传送单元 —— 必须对每一种类型的点对点链路设置<font color="#245bdb">最大传送单元MTU</font> 的标准默认值。</li><li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li><li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法。</li></ol></li><li><p>PPP 协议不需要的功能：</p><ol><li>纠错——PPP 协议只负责<font color="#245bdb">检错</font>，<font color="#245bdb">纠错</font>由运输层的 TCP 协议负责。<font color="#245bdb">PPP 协议是不可靠传输协议</font>。</li><li>流量控制——端到端的流量控制同样由 TCP 协议负责。</li><li>序号——PPP 协议是不可靠传输协议，不需要序号。</li><li>多点线路 ——PPP 协议只支持点对点的链路通信。</li><li>半双工或单工链路 ——PPP 协议只支持全双工链路。</li></ol></li><li><p>PPP 协议的<strong>组成</strong>：</p><ol><li>一个将 IP 数据报封装到串行链路的方法。IP 数据报是 PPP 帧中的信息部分。</li><li>一个<font color="#c00000">链路控制协议 LCP</font> (Link Control Protocol)：用来建立、配置和测试数据链路连接。</li><li>一套<font color="#c00000">网络控制协议 NCP</font> (Network Control Protocol)：其中的每一个协议支持不同的网络层协议。</li></ol></li><li><p>PPP 协议的帧格式：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt=""></p><ul><li>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。<ul><li>首部：<ul><li><font color="#00b0f0">标志字段</font> F 规定为0x7E。此字段是 PPP 帧的定界符。</li><li><font color="#00b0f0">地址字段</font> A 只置为 0xFF。</li><li><font color="#00b0f0">控制字段</font> C 通常置为 0x03。</li><li><font color="#00b0f0">协议字段</font>：表明信息字段的类型。</li></ul></li><li>尾部：<ul><li><font color="#00b0f0">FCS</font>：帧校验序列。</li><li><font color="#00b0f0">标志字段</font> F。</li></ul></li></ul></li><li><mark style="background: #BBFABBA6;">PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</mark></li></ul></li><li><p>透明传输问题：</p><ol><li>当 PPP 用在<font color="#c00000">异步传输</font>（逐个字符的传送）时，就使用一种特殊的<font color="#c00000">字符填充</font>法。<ul><li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。</li><li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。</li><li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li></ul></li><li>当 PPP 用在<font color="#c00000">同步传输</font>（一连串的比特连续传送）链路时，协议规定采用硬件来完成<font color="#c00000">比特填充</font>（和 HDLC 的做法一样）。<ul><li>PPP 协议采用<font color="#c00000">零比特填充</font>方法来实现透明传输。在发送端，只要发现有 5 个连续 1，则立即填入一个 0。</li></ul></li></ol></li><li><p>PPP 协议不提供使用<font color="#245bdb">序号</font>和<font color="#245bdb">确认</font>的<font color="#245bdb">可靠传输</font>的原因：</p><ol><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>在因特网环境下，PPP 的信息字段放入的数据是 IP  数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列 FCS 字段可保证无差错接受。</li></ol></li></ul><h2 id="3-3-使用广播信道的数据链路层">3.3 使用广播信道的数据链路层</h2><ul><li><p><mark style="background: #BBFABBA6;"> 局域网<u>最主要的特点</u>是：网络为一个单位所拥有，且地理范围和站点数目均有限。 </mark></p></li><li><p><strong>局域网具有如下主要优点</strong>：</p><ol><li>具有<font color="#245bdb">广播</font>功能，从一个站点可很方便地访问全网。局域网上的主机可<font color="#245bdb">共享</font>连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和生存性。</li></ol></li><li><p><mark style="background: #FFB8EBA6;">局域网的拓扑结构：<font color="#00b050">星形</font>网、<font color="#00b050">环形</font>网、<font color="#00b050">总线</font>网、<font color="#00b050">树形</font>网。</mark></p></li><li><p>共享信道带来的问题：如何使众多用户能够合理而方便地共享通信媒体资源？<br>在技术上有两种方法：</p><ol><li><font color="#c00000">静态划分信道</font>：频分复用、时分复用、波分复用、码分复用等。<br>用户只要分配了信道就不会和其他用户发生冲突。但是这种方法<u>代价太高，不适合局域网</u>。</li><li><font color="#c00000">动态媒体接入控制</font>（又称<font color="#c00000">多点接入</font>）<ul><li><font color="#c00000">随机接入</font>：特点是所有用户可<u>随机发送</u>信息。<br>但是同一时间发送会产生<font color="#245bdb">碰撞</font>（即发生<font color="#245bdb">冲突</font>），因此必须有解决碰撞的网络协议。</li><li><font color="#c00000">受控接入</font>：特点是用户不能随机发送信息，必须<u>服从一定的控制</u>。<br>典型代表：<font color="#245bdb">多点线路探询</font> ，或称为轮询。</li></ul></li></ol></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">传统以太网</font>：表示最早流行的 10 Mb/s 速率的以太网。 </mark></p></li><li><p>以太网的两个标准：</p><ol><li><font color="#245bdb">DIX Ethernet V2</font> 是<u>世界上第一个</u>局域网产品（以太网）的规约。</li><li><font color="#245bdb">IEEE 802.3</font> 是第一个 IEEE 的以太网标准。</li></ol><ul><li>802.3 局域网简称为“<font color="#c00000">以太网</font>”。</li></ul></li><li><p>IEEE 820.3 把数据链路层又分为两个子层：</p><ol><li><font color="#c00000">逻辑链路控制 LLC (Logical Link Control)子层</font>；</li><li><font color="#c00000">媒体接入控制 MAC (Medium Access Control)子层</font>。</li></ol><ul><li>与接入到<u>传输媒体</u>有关的内容都放在<u> MAC 子层</u>，而 LLC 子层则与传输媒体<u>无关</u>。</li><li>不管采用何种协议的局域网，对 <u>LLC 子层</u>来说都是<u>透明</u>的。</li></ul></li><li><p><strong>适配器</strong>的作用</p><ul><li><u>计算机网络</u>与<u>外界局域网</u>的连接是通过<u>通信适配器</u>。</li><li>适配器本来是在主机箱内插入的一块<font color="#245bdb">网络接口板</font>。这种接口板又称为<font color="#c00000">通信适配器 </font>(adapter) 或<font color="#c00000">网络接口卡</font> NIC (Network Interface Card)，或“<font color="#c00000">网卡</font>”。</li><li>适配器的重要功能：<ol><li>进行数据串行传输和并行传输的转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装管理该适配器的设备驱动程序。</li><li>要能够实现以太网协议。</li></ol></li></ul></li><li><p>CSMA/CD 协议</p><ul><li><p>背景：</p><ul><li>最初的以太网是将许多计算机都连接到一根<font color="#245bdb">总线</font>上。</li><li>总线的特点是：一台计算机发送数据，总线上的其他计算机都能监测到这个数据。这种就是<font color="#245bdb">广播</font>通信方式。</li><li>为了实现<u>一对一通信</u>，将接收站的<u>硬件地址</u>写入帧首部中的<u>目的地址</u>字段中。仅当数据帧中的目的地址与适配器的硬件地址一致时，才能接收这个数据帧。</li><li>总线也有缺点：若多台计算机或多个站点同时发送时，会产生发送<font color="#245bdb">碰撞</font>或<font color="#245bdb">冲突</font>，导致发送失败。</li></ul></li><li><p>为了通信的简便，以太网采取了两种重要的措施：</p><ol><li><mark style="background: #FFB86CA6;">采用较为灵活的<font color="#c00000">无连接</font>的工作方式</mark><ul><li>即不必建立连接就可以直接发送数据。</li><li>适配器对发送的数据帧<u>不进行编号，也不要求对方发回确认</u>。这样做的理由是<u>局域网信道的质量很好</u>，因信道质量产生差错的概率是很小的。</li><li>以太网提供的服务是不可靠的交付，即<font color="#c00000">尽最大努力的交付</font>。</li><li>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。对有差错的帧是否需要重传由高层（TCP 协议）决定。但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li></ul></li><li><mark style="background: #FFB86CA6;">以太网发送的数据都使用曼彻斯特编码</mark></li></ol></li><li><p>问题：如何协调总线上各计算机的工作？我们知道，<u>总线</u>上只要有一台计算机在发送数据，总线的传输资源就一直被占用，所以<u>同一时间只能允许一台计算机发送信息</u>。以太网协调的方法是使用一种特殊的协议，即：</p></li><li><p><font color="#c00000">载波监听多点接入/碰撞检测</font>协议 ：<font color="#00b050">CSMA/CD</font>(Carrier Sense Multiple Access with Collision Detection) 。</p><ul><li><font color="#c00000">载波监听</font>——即“发送前先监听”，每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</li><li><font color="#c00000">多点接入</font>——表示这是总线型的网路。许多计算机以多点接入的方式连接在一根总线上。</li><li><font color="#c00000">碰撞检测</font>——即“边发送边监听”，适配器边发送数据边检测信道上的<u>信号电压大小</u>，以便判读是否其他站点也在同时发送数据。也称为“<font color="#c00000">冲突检测</font>”。</li></ul></li><li><p>问题：既然发送前已经监听到信号是空闲的了，为什么还要进行碰撞检测？ （必要性）<br>答：因为信号<font color="#245bdb">传播时延</font>对载波监听产生了影响：</p><ul><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6%E5%BD%B1%E5%93%8D%E8%BD%BD%E6%B3%A2%E7%9B%91%E5%90%AC.png" alt=""></li><li>t = 0 时，A 监听到信道空闲，向 1 km 外的 B 开始发送数据。比特在信道中传播需要时间，当比特还没有到达 B 时，B 的载波监听检测不到 A 的信息，B 会错误地认为此时信道也是空闲的，此时 B 发送数据，必然在某个时间后与 A 发生碰撞，造成信号失真。</li></ul></li><li><p>最先发送数据帧的 A 站，在发送数据帧后<u>至多经过时间 2τ </u>就可知道发送的数据帧是否遭受了碰撞，此时δ=0。因此，<mark style="background: #BBFABBA6;">称以太网的端到端<font color="#245bdb">往返时延 2τ</font>  称为<font color="#c00000">争用期</font>，或<font color="#c00000">碰撞窗口</font>。</mark></p></li><li><p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p></li><li><p>CSMA/CD 协议的重要特性</p><ul><li>显然，在使用 CSMA/CD 协议时，一个站点<u>无法同时进行发送和接收</u>。因此<mark style="background: #BBFABBA6;">使用 CSMA/CD 协议的以太网<u>不能进行全双工通信</u>而只能进行<font color="#245bdb">双向交替通信</font>（<font color="#245bdb">半双工通信</font>）。</mark></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇<font color="#245bdb">碰撞</font>的可能性。</li><li>这种发送的<font color="#245bdb">不确定性</font>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul></li><li><p>以太网采用<font color="#c00000">截断二进制指数退避算法</font> (truncated binary exponential type) 来解决碰撞问题：<br>发生碰撞的站在停止发送数据后，要推迟（退避）一个<font color="#245bdb">随机时间</font>才能再发送数据。</p><ol><li><font color="#245bdb">基本退避时间</font>取为争用期 2τ 。</li><li>从整数集合 {0,1,2,3 … , (2<sup>k</sup>-1)} 中<font color="#245bdb">随机</font>地取出一个数，记为 r。下次重传的时间就是：r<u> 倍的基本退避时期</u>。</li><li>参数 k 按下面的公式计算：K = Min{重传次数, 10}，即<mark style="background: #FFB86CA6;"> K 最大取 10</mark>。</li><li>最大当重传次数≤10 时，参数 K = 重传次数；当重传次数 ＞10 时，K =10。</li><li><mark style="background: #FFB86CA6;">当重传达 <u>16</u> 次仍不能成功时即<u>丢弃该帧</u>，并向高层报告。</mark></li></ol></li><li><p>举例：</p><ul><li>第 1 次冲突重传时：K = 1，r 为 {0，1} 集合中的任何一个数。</li><li>第 2 次冲突重传时：K = 2，r 为 {0，1，2，3} 集合中的任何一个数。</li><li>第 3 次冲突重传时：K = 3，r 为 {0，1，2，3，4，5，6，7} 集合中的任何一个数。</li></ul></li><li><p>10 Mbit/s 以太网（<font color="#245bdb">传统以太网</font>）争用期的长度：2τ = <font color="#ff0000"> 51.2 μs</font></p><ul><li>对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即<font color="#ff0000"> 64 字节</font>，。</li><li>即以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</li><li><mark style="background: #BBFABBA6;"> 以太网规定“<font color="#c00000">最短有效帧长</font>”为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的<font color="#245bdb">无效帧</font>。</mark>这种无效帧收到后应立即丢弃。</li><li>以太网还规定了<font color="#c00000">帧间最小间隔</font>为 9.6 μs，相当于 96 bit 的发送时间。一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</li></ul></li><li><p>以太网还采用了一种叫做<font color="#c00000">强化碰撞</font>的措施：</p><ul><li>当发送数据的站一旦发现发生了碰撞时：立即停止发送数据；</li><li>再继续发送若干比特的<font color="#c00000">人为干扰信号</font> (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。</li></ul></li></ul></li></ul><h2 id="3-4-使用广播信道的以太网">3.4 使用广播信道的以太网</h2><h3 id="3-4-1-使用集线器的星形拓扑">3.4.1 使用集线器的星形拓扑</h3><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>传统以太网使用同轴电缆，采用<font color="#245bdb">总线形拓扑</font>结构。</li><li>这种采用双绞线的以太网采用<font color="#245bdb">星形拓扑</font>，在星形的中心则增加了一种可靠性非常高的设备，叫做<font color="#c00000">集线器</font> (hub)。</li><li>1990 年，IEEE 制定出采用<u>双绞线</u>的<u>星形以太网</u> <font color="#c00000">10BASE-T</font> 的标准 802.3i。<ul><li><mark style="background: #BBFABBA6;">10 —— 代表 10 Mb/s 的数据率</mark></li><li><mark style="background: #BBFABBA6;">BASE —— 表示连接线上的信号是基带信号</mark></li><li><mark style="background: #BBFABBA6;">T —— 代表双绞线</mark></li></ul></li><li>以太网在局域网中的统治地位：<ul><li>10 BASE-T 的通信距离稍短，<mark style="background: #FFB86CA6;">每个站到集线器的距离不超过 100 m</mark>。</li><li>这种 10 Mb/s 速率的<u>无屏蔽双绞线</u><u>星形网</u>的出现，既降低了成本，又提高了可靠性。</li><li>10 BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</li></ul></li><li>集线器的特点：<ol><li>表面上集线器的局域网在<font color="#245bdb">物理上</font>是一个<font color="#245bdb">星形网</font>，集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。也就是说：<br>使用集线器的以太网在<font color="#245bdb">逻辑上</font>仍是一个<font color="#245bdb">总线网</font>，各工作站使用的还是 <font color="#245bdb">CSMA/CD</font> 协议，并共享逻辑上的总线。</li><li>集线器很像一个<font color="#245bdb">多接口</font>的<font color="#245bdb">转发器</font>，工作在<font color="#245bdb">物理层</font>。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</li></ol></li></ul><h3 id="3-4-2-以太网的信道利用率">3.4.2 以太网的信道利用率</h3><ul><li>假设 τ 是以太网<font color="#245bdb"><u>单程</u>端到端传播时延</font>。则<u>争用期长度为 2τ</u> ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BF%A1%E9%81%93%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5.png" alt=""><ul><li>设<u>帧长为 L</u> (bit)，数据<u>发送速率为 C</u> (bit/s)，则<u>帧的发送时间为  T<sub>0</sub> = L/C (s)</u>。</li><li>某站点在发送帧时出现了碰撞。如图，经过一个争用期 2τ 后，可能又出现了碰撞。这样经过若干个争用期后才发送成功。假定发送帧需要的时间是 T<sub>0</sub>。</li><li>注意到，成功发送一个帧需要占用信道的时间是 <u>T<sub>0</sub> + τ </u>， τ 是以太网<u>单程</u>端到端传播时延。</li><li><u>要提高以太网的信道利用率，就必须减小 τ 与 T<sub>0</sub> 之比</u>。</li></ul></li><li>在以太网中定义了<mark style="background: #BBFABBA6;"><u>参数 a </u>，它是以太网<u>单程端到端时延 τ</u> 与<u>帧的发送时间 T<sub>0</sub></u> 之比</mark>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mi>a</mi><mo>=</mo><mfrac><mi mathvariant="bold-italic">τ</mi><msub><mi>T</mi><mn>0</mn></msub></mfrac><mspace width="1em"/><mrow></mrow></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">\boxed{\quad a=\dfrac{\boldsymbol{\tau}}{T_0}\quad\text{}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6374em;vertical-align:-1.176em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4614em;"><span style="top:-4.6374em;"><span class="pstrut" style="height:4.6374em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.13472em;">τ</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"></span></span></span></span></span><span style="top:-3.4614em;"><span class="pstrut" style="height:4.6374em;"></span><span class="stretchy fbox" style="height:2.6374em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.176em;"><span></span></span></span></span></span></span></span></span><ul><li><mark style="background: #BBFABBA6;">a 越小，以太网的信道利用率越高。</mark><u></u></li></ul></li><li>对以太网参数 a 的要求是：<ul><li>当数据率一定时，以太网的<font color="#245bdb"><u>连线的长度不能太长</u></font>，否则 τ  的数值会太大，进而使 a 值太大。</li><li>以太网的<font color="#245bdb"><u>帧长不能太短</u></font>，否则 T<sub>0</sub> = L/C 的值会太小，使 a 值太大。</li></ul></li><li>在最理想的情况下，以太网上的各站发送数据都不会产生碰撞，即总线一旦空闲就有某一个站立即发送数据。</li><li><font color="#c00000">信道利用率的最大值 S<sub>max</sub></font>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>S</mi><mtext>max</mtext></msub><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mi>τ</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>a</mi></mrow></mfrac></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">\boxed{S_{\text{max}}=\frac{T_0}{T_0+\tau}=\frac{1}{1+a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.8763em;vertical-align:-1.176em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7003em;"><span style="top:-4.8763em;"><span class="pstrut" style="height:4.8763em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><span style="top:-3.7003em;"><span class="pstrut" style="height:4.8763em;"></span><span class="stretchy fbox" style="height:2.8763em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.176em;"><span></span></span></span></span></span></span></span></span></li><li><mark style="background: #BBFABBA6;">只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。</mark>（线路尽可能短一些，每一帧的长度尽可能大一些）</li></ul><h3 id="3-4-3-以太网的-MAC-层">3.4.3 以太网的 MAC 层</h3><ul><li><p><font color="#c00000">媒体接入控制</font> <font color="#00b050">MAC</font> (Medium Access Control)子层，与接入到<u>传输媒体</u>有关的内容都放在<u> MAC 子层</u>。</p></li><li><p>在局域网中，<font color="#c00000">硬件地址</font>又称为<font color="#c00000">物理地址</font>，或 <font color="#c00000">MAC 地址</font>。</p></li><li><p><font color="#245bdb">48 位</font>的 MAC 地址：lIEEE 的注册管理机构 RA 负责向厂家分配高位 24 位，称为<font color="#c00000">组织唯一标识符</font>。低位 24 位由厂家自行指派，称为<font color="#c00000">扩展唯一标识符</font>。必须保证生产出的适配器没有重复地址。</p></li><li><p>“MAC 地址”实际上就是<font color="#c00000">适配器地址</font>或适配器标识符 EUI-48。</p></li><li><p>单站地址，组地址，广播地址：</p><ul><li>IEEE 规定地址字段的<u>第一字节</u>的<u>最低位</u>为 I/G 位。Individual / Group。</li><li>当 I/G 位 = 0 时，地址字段表示一个<font color="#245bdb">单站地址</font>。</li><li>当 I/G 位 = 1 时，表示<font color="#245bdb">组地址</font>，用来进行<font color="#245bdb">多播</font>。</li><li>所有 48 位都为 1 时，为<font color="#245bdb">广播地址</font>，只能作为目的地址使用。</li></ul></li><li><p>全球管理与本地管理：</p><ul><li>IEEE 把地址字段<u>第一字节</u>的<u>最低第 2 位</u>规定为 G/L 位。Global / Local。</li><li>当 G/L 位 = 0 时，是<font color="#245bdb">全球管理</font>（保证在全球没有相同的地址）。</li><li>当 G/L 位 = 1 时，是<font color="#245bdb">本地管理</font>，这时用户可任意分配网络上的地址。</li></ul></li><li><p>适配器检查 MAC 地址：</p><ul><li>适配器从网络上每收到一个 MAC 帧就首先用硬件检查帧中的 MAC 地址：<ol><li>如果是<font color="#245bdb">发往本站的帧</font>则收下，然后再进行其他的处理。</li><li>否则就将此帧丢弃，不再进行其他的处理。</li></ol></li><li>“发往本站的帧”包括以下三种帧：<ol><li><font color="#245bdb">单播</font> (unicast) 帧（一对一）</li><li><font color="#245bdb">广播</font> (broadcast) 帧（一对全体）</li><li><font color="#245bdb">多播</font> (multicast) 帧（一对多）</li></ol></li><li>所有的适配器都至少能够识别单播地址和广播地址。</li><li>有的适配器可用编程方法识别多播地址。</li><li><mark style="background: #BBFABBA6;"> 只有目的地址才能使用广播地址和多播地址。</mark></li><li>以<font color="#245bdb">混杂方式 </font>(promiscuous mode) 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。</li></ul></li><li><p>以太网 V2 的 MAC 帧格式：</p><ul><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt=""></li><li>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。在帧的前面插入（硬件生成）的 8 字节中：<ul><li>第一个字段 7 个字节，是<font color="#245bdb">前同步码</font>，用来迅速实现 MAC 帧的<font color="#245bdb">比特同步</font>。</li><li>第二个字段 1 个字节是<font color="#245bdb">帧开始定界符</font>，表示后面的信息就是 MAC 帧。</li></ul></li><li>类型字段：用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。</li><li>数据字段：正式名称是 <font color="#c00000">MAC 客户数据字段</font>。数据字段的长度在 46~1500 字节之间。数据字段的最小长度46 字节=最小有效帧长 64 字节 - 18 字节的首部和尾部。</li><li>当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。</li></ul></li><li><p><font color="#245bdb">无效的 MAC 帧</font>：</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间<br>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</li></ul></li></ul><h2 id="3-5-扩展的以太网">3.5 扩展的以太网</h2><h3 id="3-5-1-在物理层扩展以太网">3.5.1 在物理层扩展以太网</h3><ul><li><p>使用<strong>光纤</strong>扩展——简单</p><ol><li><u>主机</u>使用光纤（通常是一对<font color="#245bdb">光纤</font>）和一对<font color="#245bdb">光纤调制解调器</font>连接到<u>集线器</u>。</li><li>很容易使主机和几公里以外的集线器相连接。<br>光纤调制解调器的作用是进行电信号和光信号的转换。</li></ol></li><li><p>使用<strong>集线器</strong>扩展：将多个以太网段连成更大的、多级星形结构的以太网。</p></li><li><p>优点</p><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><p>缺点</p><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，就不能用集线器将它们互连起来。</li></ol></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E9%9B%86%E7%BA%BF%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91.png" alt=""></p></li><li><p><font color="#c00000">碰撞域</font>（collision domain）又称为<font color="#c00000">冲突域</font>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p></li><li><p><mark style="background: #BBFABBA6;"> 碰撞域越大，发生碰撞的概率越高。</mark></p></li></ul><h3 id="3-5-2-在数据链路层扩展以太网">3.5.2 在数据链路层扩展以太网</h3><ul><li><p>在数据链路层扩展局域网是使用<font color="#c00000">网桥</font>。</p></li><li><p>网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。</p></li><li><p>网桥具有<font color="#c00000">过滤帧</font>的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。</p></li><li><p>两个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可以称为一个<font color="#c00000">网段</font> (segment)。</p></li><li><p>网桥依靠<font color="#c00000">转发表</font>来转发帧。转发表也叫做<font color="#c00000">转发数据库</font>或<font color="#c00000">路由目录</font>。</p></li><li><p><mark style="background: #BBFABBA6;"> 网桥在转发帧时，不改变帧的源地址。</mark></p></li><li><p>使用网桥带来的好处：</p><ul><li>过滤通信量，增大吞吐量。网桥可以使各网段成为隔离的碰撞域。</li><li>扩大了物理范围。</li><li>提高了可靠性。</li><li>可互连不同物理层、不同 MAC 子层和不同速率（如 10 Mb/s 和 100 Mb/s 以太网）的局域网。</li></ul></li><li><p>使用网桥带来的缺点：</p><ul><li>存储转发增加了时延。</li><li>在 MAC 子层并没有流量控制功能。</li><li>具有不同 MAC 子层的网段桥接在一起时时延更大。</li><li>网桥只适合于用户数不太多 (不超过几百个)和通信量不太大的局域网，否则有时还会因<u>传播过多的广播信息而产生网络拥塞</u>。这就是所谓的<font color="#c00000">广播风暴</font>。</li></ul></li><li><p>网桥和集线器（或转发器）不同：</p><ul><li>集线器在转发帧时，不对传输媒体进行检测。</li><li>网桥在转发帧之前必须执行 CSMA/CD 算法。<ul><li>若在发送过程中出现碰撞，就必须停止发送和进行退避。</li></ul></li><li>网桥是按存储转发方式工作的，一定要先把整个帧收下来再尽心处理，而不管其目的地址是什么。但集线器或转发器是逐比特转发。</li><li>网桥会丢弃 CRC 检验有差错的帧和帧长过长或过短的无效帧。</li></ul></li><li><p><strong>透明网桥</strong></p><ul><li>目前使用得最多的网桥是<font color="#c00000">透明网桥</font> (transparent bridge)。</li><li>“透明”是指<u>局域网上的站点并不知道所发送的帧将经过哪几个网桥</u>，因为网桥对各站来说是看不见的。</li><li>透明网桥是一种<u>即插即用</u>设备。</li><li>网桥在转发表中登记以下三个信息：<font color="#c00000">地址</font>和<font color="#c00000">接口</font>还有帧进入该网桥的<font color="#c00000">时间</font>。<ul><li>登记时间是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。另外，以太网上的工作站并非总是接通电源的。</li><li>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的<font color="#245bdb">最新状态信息</font>。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。</li><li>注意，转发表中没有“源地址”一项，只有“地址”。</li></ul></li><li>网桥使用<font color="#c00000">自学习</font>算法处理收到的帧和建立转发表：<ul><li>网桥收到一帧后先进行<font color="#c00000">自学习</font>：查找<font color="#245bdb">转发表</font>中与收到帧的<font color="#245bdb">源地址</font>有无相匹配的项目。<ol><li>如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）</li><li>如有，则把原有的项目进行更新。</li></ol></li></ul></li><li>网桥<font color="#c00000">转发帧</font>：查找转发表中与收到帧的<font color="#245bdb">目的地址</font>有无相匹配的项目：<ol><li>如没有，则通过<u>所有其他接口</u>（进入网桥的接口除外）进行转发。</li><li>如有，则按转发表中给出的接口进行转发。</li><li>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。</li></ol></li><li>透明网桥使用了<font color="#c00000">生成树</font>算法，这是为了避免产生转发的帧在网络中不断地兜圈子。</li></ul></li><li><p><strong>源路由网桥</strong>——发送帧的源站负责路由选择的网桥</p><ul><li>透明网桥容易安装，但网络资源的利用不充分。</li><li>源路由 (source route)网桥在发送帧时将详细的路由信息放在帧的首部中。</li><li>源站以广播方式向欲通信的目的站发送一个<font color="#245bdb">发现帧</font>，每个发现帧都记录所经过的路由。</li><li>发现帧<u>到达目的站</u>时就沿各自的路由<u>返回源站</u>。源站在得知这些路由后，从所有可能的路由中选择出一个<font color="#245bdb">最佳路由</font>。凡从该源站向该目的站发送的帧的<font color="#245bdb">首部</font>，都必须携带源站所确定的这一<font color="#245bdb">路由信息</font>。</li></ul></li><li><p><strong>多接口网桥——以太网交换机</strong></p><ul><li><font color="#c00000">交换式集线器</font>常称为<font color="#c00000">以太网交换机</font>或<font color="#c00000">第二层交换机</font>，这表明这种交换机工作在<u>数据链路层</u>。</li><li><mark style="background: #BBFABBA6;">以太网交换机实质上就是一个多接口的网桥。</mark></li><li>以太网交换机的特点：<ul><li>以太网交换机的每个接口都直接与主机相连，一般工作在<font color="#245bdb">全双工</font>方式。</li><li>交换机能同时连通许多对的接口，使每一对相互通信的主机都能像<font color="#245bdb">独占通信媒体</font>那样，进行<font color="#245bdb">无碰撞地传输数据</font>。</li><li>以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。</li></ul></li><li>利用以太网交换机可以很方便地实现<font color="#245bdb">虚拟局域网</font>：<ul><li><mark style="background: #BBFABBA6;"><font color="#c00000">虚拟局域网</font> <font color="#00b050">VLAN</font>是由一些局域网网段构成的<font color="#245bdb">与物理位置无关</font>的<font color="#245bdb">逻辑组</font>。</mark></li><li>VLAN 只是局域网给用户提供的一种服务，而并不是一种新型局域网。</li><li>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即广播风暴)而引起性能恶化。</li><li>虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 <font color="#d83931">VLAN 标记</font>(tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。</li></ul></li></ul></li></ul><h2 id="3-6-高速以太网">3.6 高速以太网</h2><ul><li><p><font color="#c00000">高速以太网</font>：速率达到或超过 100 Mb/s 的以太网。</p></li><li><p><font color="#c00000"> 100BASE-T 以太网</font>：<u>双绞线</u>上传送 <u>100 Mb/s </u><u>基带信号</u>的星形拓扑以太网。100BASE-T 以太网又称为<font color="#c00000">快速以太网</font>。</p></li><li><p>100BASE-T 以太网的特点：</p><ul><li>可在<u>全双工</u>方式下工作而无冲突发生。</li><li><u> 在全双工方式下工作时，不使用 CSMA/CD 协议。</u></li><li>在半双工方式下工作时，必须使用 CSMA/CD 协议。</li><li>保持<u>最短帧长不变</u>，64 字节，但将一个网段的最大<u>电缆长度减小到 100 米</u>。</li><li>100 Mb/s 的比特网的征用期是 5.12 μs，帧间时间间隔是 0.96 μs，都是原来 10 Mb/s 以太网的 1/10。</li></ul></li><li><p>100 Mbit/s 以太网的三种不同的物理层标准：</p><ul><li>100 BASE-TX：使用 2 对 UTP 5 类线或屏蔽双绞线 STP。</li><li>100 BASE-FX：使用 2 对光纤。</li><li>100 BASE-T4：使用 4 对 UTP 3 类线或 5 类线。</li></ul></li><li><p><font color="#c00000">吉比特以太网</font>（<font color="#c00000">千兆以太网</font>）</p><ul><li>允许在 1 Gbit/s 下以<font color="#245bdb">全双工</font>和<font color="#245bdb">半双工</font>两种方式工作。</li><li>使用 IEEE 802.3 协议规定的帧格式。</li><li>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。</li><li>与 10 BASE-T 和 100 BASE-T 技术向后兼容。</li></ul></li><li><p>吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中。</p></li><li><p>吉比特以太网的物理层使用两种成熟的技术：一种来自现有的以太网，另一种则是美国国家标准协会 ANSI 制定的<font color="#c00000">光纤通道 FC</font>  (Fiber Channel)。</p></li><li><p>吉比特以太网工作在<font color="#245bdb">半双工</font>方式时，就必须进行碰撞检测。由此数据率提高了，因此只有<u>减小最大电缆长度</u>或者<u>增大帧的最小长度</u>，才能使 a 的数值较小。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mi>a</mi><mo>=</mo><mfrac><mi mathvariant="bold-italic">τ</mi><msub><mi>T</mi><mn>0</mn></msub></mfrac><mspace width="1em"/><mrow></mrow></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">\boxed{\quad a=\dfrac{\boldsymbol{\tau}}{T_0}\quad\text{}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6374em;vertical-align:-1.176em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4614em;"><span style="top:-4.6374em;"><span class="pstrut" style="height:4.6374em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.13472em;">τ</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"></span></span></span></span></span><span style="top:-3.4614em;"><span class="pstrut" style="height:4.6374em;"></span><span class="stretchy fbox" style="height:2.6374em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.176em;"><span></span></span></span></span></span></span></span></span></p></li><li><p>为保持 64 字节最小帧长度，以及 100 米的网段的最大长度，吉比特以太网增加了两个功能：</p><ol><li><font color="#c00000">载波延伸</font> (carrier extension)<ul><li>使最短帧长仍为 64 字节，同时将<font color="#245bdb">争用时间增大为 512 字节</font>。</li></ul></li><li><font color="#c00000">分组突发</font> (packet bursting)<ul><li>当很多短帧要发送时，第一个短帧要采用载波延伸方法进行填充，随后的一些短帧则可一个接一个地发送，只需留有必要的帧间最小间隔即可。这样就形成可一串分组的突发，直到达到 1500 字节或稍多一些为止。</li></ul></li></ol></li><li><p>吉比特以太网工作在<font color="#245bdb">全双工</font>方式下，不适用载波延伸和分组突发技术。</p></li><li><p><font color="#c00000">10 吉比特以太网</font></p></li><li><p>10 吉比特以太网与 10Mb/s，100Mb/s 和 1Gb/s 以太网的帧格式完全相同。</p></li><li><p>10 吉比特以太网还保留了 802.3 标准规定的以太网最小和最大帧长。</p></li><li><p>10 吉比特以太网不再使用<font color="#245bdb">铜线</font>而只使用<font color="#245bdb">光纤</font>作为传输媒体。</p></li><li><p>10 吉比特以太网只工作在<font color="#245bdb">全双工</font>方式，因此没有争用问题，也不使用 CSMA/CD 协议。</p></li><li><p>10 GE 有两种不同的物理层：</p><ol><li>局域网物理层 LAN PHY</li><li>可选的广域网物理层 WAN PHY</li></ol></li><li><p>10 吉比特以太网的出现，以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现了<font color="#245bdb">端到端的以太网传输</font>。</p></li><li><p>以太网从 10 Mb/s 到 10 Gb/s 的演进证明了以太网是：</p><ul><li>可扩展的</li><li>灵活的（多种传输媒体、全/半双工、共享/交换）</li><li>易于安装</li><li>稳健性好</li></ul></li><li><p>使用高速以太网进行宽带接入：</p><ul><li>以太网已成功地把速率提高到 1 ~ 10 Gb/s ，所覆盖的地理范围也扩展到了城域网和广域网，因此现在人们正在尝试使用以太网进行宽带接入。</li><li>以太网接入的重要特点是它可提供双向的宽带通信，并且可根据用户对带宽的需求灵活地进行带宽升级。</li><li>采用以太网接入可实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率和降低了传输的成本。</li></ul></li></ul><h1 id="第-4-章网络层">第 4 章网络层</h1><h2 id="4-1-网络层提供的两种服务">4.1 网络层提供的两种服务</h2><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<font color="#245bdb">面向连接</font>”还是“<font color="#245bdb">无连接</font>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：在计算机通信中，<font color="#245bdb">可靠交付应当由谁来负责？</font>是网络还是端系统？</li><li>因特网的设计思路：<mark style="background: #BBFABBA6;">网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</mark></li><li><strong>尽最大努力交付</strong>：<ul><li>由于<font color="#245bdb">传输网络不提供端到端的可靠传输服务</font>，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<font color="#245bdb">主机中的运输层负责可靠交付（包括差错处理、流量控制等）</font>。</li><li><font color="#245bdb">采用这种设计思路的好处</font>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li></ul></li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230318230030242.png" alt="image-20230318230030242"></li></ul><h2 id="4-2-网际协议-IP">4 .2 网际协议 IP</h2><ul><li><p><font color="#c00000">网际协议</font> <font color="#00b050">IP</font> 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有四个协议：</p><ul><li><font color="#c00000">地址解析协议</font> <font color="#00b050">ARP</font>  (Address Resolution Protocol)</li><li><font color="#c00000">逆地址解析协议</font> <font color="#00b050">RARP</font> (Reverse Address Resolution Protocol)</li><li><font color="#c00000">网际控制报文协议</font> <font color="#00b050">ICMP</font> (Internet Control Message Protocol)</li><li><font color="#c00000">网际组管理协议</font> <font color="#00b050">IGMP</font> (Internet Group Management Protocol)</li></ul></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%85%B6%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.png" alt=""></p></li><li><p>IP 协议要经常使用 ARP 和 RARP 协议，所以它们在 IP 协议的下面。</p></li><li><p>ICMP 协议和 IGMP 协议要使用 IP 协议，所以它们在 IP 协议的上面。</p></li><li><p>由于 I<mark style="background: #BBFABBA6;">P 协议是用来使互联起来的众多计算机网络能够进行通信</mark>，因此 TCP/IP 体系中的网络层常常称为<font color="#c00000">网际层</font> (internet layer)，或 <font color="#c00000">IP 层</font>。</p></li></ul><h3 id="4-2-1-虚拟互联网络">4.2.1 虚拟互联网络</h3><ul><li><p>从一般概念来讲，将网络互相连接起来要使用一些<font color="#245bdb">中间设备</font>。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ol><li>物理层使用的中间设备：<font color="#245bdb">转发器</font> (repeater)。</li><li>数据链路层使用的中间设备：<font color="#245bdb">网桥</font>或<font color="#245bdb">桥接器</font> (bridge)。</li><li>网络层使用的中间设备：<font color="#245bdb">路由器</font> (router)。</li><li>网络层以上使用的中间设备：<font color="#245bdb">网关</font> (gateway)。</li></ol></li><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">网络互连</font>是指用路由器进行网络互连和路由选择。</mark></p></li><li><p>当中继系统是<u>转发器</u>或<u>网桥</u>时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。</p></li><li><p>历史原因，许多 TCP/IP 文献把网络层使用的路由器称为网关。</p></li><li><p><font color="#c00000">虚拟互连网络</font>，也就是<font color="#c00000">逻辑互连网络</font>，它的意思就是互连起来的各种物理网络的<font color="#245bdb">异构性</font>本来是客观存在的，但是我们<font color="#245bdb">利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络</font>。</p></li><li><p>使用 IP 协议的虚拟互连网络可简称为 <font color="#c00000">IP 网</font>。</p></li><li><p>使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。</p></li><li><p>如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的<font color="#245bdb">互联网</font> (Internet)。</p></li></ul><h3 id="4-2-2-分类的-IP-地址">4.2.2 分类的 IP 地址</h3><ul><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">IP 地址</font>就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。</mark></p></li><li><p><font color="#245bdb">IP 地址的编址方法</font>经过了三个历史阶段：</p><ol><li><font color="#c00000">分类的 IP 地址</font>。这是<font color="#245bdb">最基本的编址方法</font>。</li><li><font color="#c00000">子网的划分</font>。这是对最基本的编址方法的<font color="#245bdb">改进</font>。</li><li><font color="#c00000">构成超网</font>。这是比较新的<font color="#245bdb">无分类编址方法</font>。</li></ol></li><li><p><strong>分类 IP 地址</strong>——将 IP 地址划分为若干个固定类。</p><ul><li>每一类地址都由两个固定长度的字段组成：<ol><li><font color="#245bdb">网络号 net-id</font>，它标志主机（或路由器）所连接到的<font color="#245bdb">网络</font>，</li><li><font color="#245bdb">主机号 host-id</font>，它标志该<font color="#245bdb">主机</font>（或路由器）。</li></ol></li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此，一个 IP 地址在整个互联网范围内是唯一的。</li><li>这种两级的 IP 地址可以记为：==IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt; }==<ul><li>::=  代表“定义为”。</li></ul></li><li>各类 IP 地址的网络号字段和主机号字段：</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt=""></li><li>由于今年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类、C 类地址的区分已经成为历史。</li><li>C 类地址是<font color="#245bdb">多播地址</font>，其余为<font color="#245bdb">单播地址</font>（不包括一些特殊的 IP 地址）。</li><li>IP 地址的可指派范围：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%AF%E6%8C%87%E6%B4%BE%E8%8C%83%E5%9B%B4.png" alt=""><ul><li>A 类地址的网络号字段占一个字节，但只有 7 位可供使用，最高位被固定为 0。所以可指派的网络号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>126</mn></mrow><annotation encoding="application/x-tex">2^7-2=126</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">126</span></span></span></span> 。减 2 是因为：<ol><li>网络号字段全 0 表示“本网络”，IP 地址中的全 0 表示“这个 this”；</li><li>网络号 127 (0111 1111)保留作为<font color="#245bdb">本地软件环回测试</font>用。</li></ol></li><li>A 类地址的主机号字段占三个字节，因此每一个 A 类网络中的最大主机数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>16777214</mn></mrow><annotation encoding="application/x-tex">2^{24}-2=16777214</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16777214</span></span></span></span> 。减 2 是因为：<ol><li>主机号字段全 0 表示该 IP 地址是本主机所连接的单个网络地址；</li><li>主机号字段全 1 表示该网络下的所有主机。</li></ol></li><li>B 类地址的网络号字段占两个字节，但前面两位（10）已经固定了，只剩下 14 位可以分配。不管怎么取网络号都不能全为 0 或全为 1，所以这里不存在减 2 的问题。但实际 B 类网络地址 128.0.0.0 是不指派的，128 的二进制表示 1000 0000，而可指派的 B 类最小网络地址是 128.1.0.0。所以 B 类地址可指派的网络数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>16383</mn></mrow><annotation encoding="application/x-tex">2^{14}-1=16383</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16383</span></span></span></span> 。</li><li>B 类地址的主机号字段占两个字节，每一个 B 类网络地址上的最大主机数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>65534</mn></mrow><annotation encoding="application/x-tex">2^{16}-2=65534</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65534</span></span></span></span> ，减 2 是因为要扣除全 0 和全 1 的主机号。</li><li>C 类地址的网络号字段占 3 个字节，前面三位（110）已经固定，只剩下 21 可以分配。但 192.0.0.0 实际上也不分配，所以 C 类最小网络地址是 192.0.1.0，可指派的最大网络数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>20997151</mn></mrow><annotation encoding="application/x-tex">2^{21}-1=20997151</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20997151</span></span></span></span> 个。每一个 C 类网络地址的最大主机数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>254</mn></mrow><annotation encoding="application/x-tex">2^8-2=254</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">254</span></span></span></span> 。</li></ul></li><li>一般不使用的特殊的 IP 地址：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80.png" alt=""></li><li><font color="#245bdb">点分十进制记法</font>：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6%E8%AE%B0%E6%B3%95.png" alt=""></li><li>IP 地址的一些重要特点：<ol><li>IP 地址是一个分等级的地址结构。分等级的好处：<ul><li>方便 IP 地址的管理；</li><li>路由器根据网络号来转发分组而不必考虑主机号，路由表的存储空间小。</li></ul></li><li>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。<ul><li><font color="#c00000">多归属主机</font>：当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<font color="#245bdb">一个路由器至少应当有两个不同的 IP 地址</font>。</li></ul></li><li>用<font color="#245bdb">转发器</font>或<font color="#245bdb">网桥</font>连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。</li><li>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</li></ol></li><li>互联网中的 IP 地址：<ol><li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。</li><li>路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口都有一个不同网络号的 IP 地址。</li><li>两个路由器直接相连的接口处，可指明也可不指明 IP 地址。如指明 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” 。现在常不指明 IP 地址以节省资源，称这种特殊网络为“无编号网络”或“无名网络”。</li></ol></li></ul></li></ul><h3 id="4-2-3-IP-地址与硬件地址">4.2.3 IP 地址与硬件地址</h3><ul><li>IP 地址与硬件地址是不同的地址。</li><li>从层次的角度看，<ol><li><font color="#c00000">硬件地址</font>（或<font color="#c00000">物理地址</font>）是<u>数据链路层和物理层</u>使用的地址。</li><li>IP 地址是<u>网络层和以上各层</u>使用的地址，是一种<font color="#c00000">逻辑地址</font>。</li></ol></li></ul><ul><li><p>称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的。</p></li><li><p>路由器只根据目的站的 IP 地址的网络号进行路由选择。</p></li><li><p>在具体的物理网络的链路层只能看见 MAC 帧而看不见 IP 数据报。</p></li><li><p>IP 层抽象的互联网屏蔽了下层很复杂的细节。在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80.png" alt=""></p></li><li><p>主机 H1 与 H2 通信中使用的 IP 地址与硬件地址 HA 的变化：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%802.png" alt=""></p></li><li><p>两个问题：</p><ol><li>主机或者路由器怎样知道应当在 MAC 帧的首部填入什么样的硬件地址？</li><li>路由器的路由表是怎么得出的？</li></ol></li></ul><h3 id="4-2-4-地址解析协议-ARP-与逆地址解析协议-RARP">4 .2.4  地址解析协议 ARP 与逆地址解析协议 RARP</h3><ul><li>已经知道了一个机器（主机或路由器）的 IP 地址，如何找出其相应的硬件地址？<ul><li><font color="#c00000">地址解析协议 ARP</font> 就是用来解决这样的问题的：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ARP%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt=""></li><li><mark style="background: #BBFABBA6;"> ARP 作用：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</mark></li><li><font color="#c00000">逆地址解析协议 RARP</font> 的作用与 ARP 的作用是相反的，即让电脑主机根据自己的硬件地址找到自己的 IP 地址。</li></ul></li><li>ARP 工作原理：<ul><li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是<font color="#245bdb">必须使用硬件地址</font>。</li><li>每一个主机都设有一个 <font color="#c00000">ARP 高速缓存</font> (ARP cache)，里面有所在的局域网上的<font color="#245bdb">各主机和路由器的 IP 地址到硬件地址的映射表</font>。</li><li>==&lt; IP address；MAC address；TTL &gt;==，其中 TTL 是地址映射有效时间。</li><li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。<ol><li>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</li><li>如没有， ARP 进程在<u>本局域网</u>上<font color="#245bdb">广播</font>发送一个<font color="#245bdb"> ARP 请求分组</font>。收到 <font color="#245bdb">ARP 响应分组</font>后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</li></ol></li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/ARP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></li><li>ARP 高速缓存的作用：<ol><li><u>存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量</u>。</li><li>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。</li><li>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</li></ol></li><li>应当注意的问题：<ul><li>ARP 用于解决<font color="#245bdb">同一个局域网</font>上的主机或路由器的 IP 地址和硬件地址的映射问题。</li><li>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器（网关）的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</li></ul></li><li>为什么不直接使用硬件地址进行通信？<ul><li>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些<font color="#245bdb">异构网络</font>能够互相通信就必须进行<font color="#245bdb">非常复杂的硬件地址转换</font>工作，因此几乎是不可能的事。</li><li>IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便。</li></ul></li></ul></li></ul><h3 id="4-2-5-IP-数据报的格式">4.2.5 IP 数据报的格式</h3><ul><li><p>一个 IP 数据报由<font color="#245bdb">首部</font>和<font color="#245bdb">数据</font>两部分组成。</p></li><li><p><mark style="background: #BBFABBA6;"> 首部的前一部分是<font color="#245bdb">固定长度</font>，共 <u>20 字节</u>，是所有 IP 数据报必须具有的。</mark></p></li><li><p>在首部的固定部分的后面是一些<font color="#245bdb">可选字段</font>，其长度是可变的：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt=""></p><ul><li><font color="#00b050">版本</font>——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv 4)。</li><li><font color="#00b050">首部长度</font>——占 4 位，可表示的最大十进制数是 15（1111）。这个字段的<font color="#245bdb">单位是 32 位</font>也就是 4 字节。所以，当字段为 1111 时，表示<font color="#245bdb">整个首部长度达到了最大值 60 字节</font>。</li><li><font color="#00b050">区分服务</font>——占 8 位，用来获得更好的服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。</li><li><font color="#00b050">总长度</font>——占 16 位，指<font color="#245bdb">首部和数据之和的长度</font>，<font color="#245bdb">单位为 8 位</font>也就是 1字节，因此数据报的最大长度为 65535 字节。<font color="#245bdb">总长度必须不超过最大传送单元 MTU。</font><ul><li><font color="#c00000">最大传送单元</font> MTU：数据链路层帧格式中数据字段的最大长度。</li></ul></li><li><font color="#00b050">标识</font>(identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。</li><li><font color="#00b050">标志</font> (flag) ——占 3 位，目前只有前两位有意义。<ol><li>标志字段的最低位是 MF (More Fragment)。MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。</li><li>标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF=0 时才允许分片。</li></ol></li><li><font color="#00b050">片偏移</font>——占 13 位，指出：较长的分组在分片后某片在原分组中的相对位置。<font color="#245bdb">片偏移以 8 个字节为偏移单位</font>。表明相对于原来的数据字段，该片<font color="#245bdb">从何处开始</font>。<ul><li>IP 数据报分片举例：一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。</li><li>因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。</li><li><u>原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。</u></li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87.png" alt=""></li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%872.png" alt=""></li><li>其中标识字段任意给定。<font color="#245bdb">具有相同标识字段的数据报片在目的站就可无误地重装成原来的数据。</font></li></ul></li><li><font color="#00b050">生存时间</font>——占 8 位，记为 <font color="#c00000">TTL</font> (Time To Live)，<mark style="background: #BBFABBA6;">指示数据报在网络中可通过的路由器数的最大值。</mark>（不是时间单位而是个数单位，要注意）</li><li><font color="#00b050">协议</font>——占 8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给哪一个<font color="#245bdb">进程</font>。<ul><li><mark style="background: #BBFABBA6;">IP 协议支持多种协议，IP 数据报可以封装多种协议 PDU</mark>：如 ICMP、IGMP、TCP、EGP、UDP、OSF 等。</li></ul></li><li><font color="#00b050">首部检验和</font>——占 16 位，<u>只检验数据报的首部，不检验数据部分</u>。这里<s>不采用 CRC 检验码</s>而采用<font color="#245bdb">简单的计算方法</font>。<ul><li>在发送端，把 IP 数据报首部划分成许多 16 位字的序列，并把检验和字段置为 0。用<font color="#245bdb">反码算术运算</font>把所有 16 位字相加求和（0 和 0 相加是 0；0 和 1 相加是 1；1 和 1 相加是 0 当时要向高位进位 1）。将这个求出的和<font color="#245bdb">取它的反码</font>，写入检验和字段。</li><li>接收方收到数据报后，把首部的所有 16 位字再使用反码算术运算相加一遍，将得到的和取反码，<font color="#245bdb">结果为 0 则保留这个数据报，否则丢弃</font>。</li></ul></li><li><font color="#00b050">源地址</font>：32 位</li><li><font color="#00b050">目的地址</font>：32 位</li></ul></li><li><p>IP 数据报首部的可变部分</p><ul><li>IP 首部的可变部分就是一个选项字段，用来支持<font color="#245bdb">排错</font>、<font color="#245bdb">测量</font>以及<font color="#245bdb">安全</font>等措施，内容很丰富。</li><li>选项字段的长度可变，从 <font color="#245bdb">1 个字节到 40 个字节不等</font>，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的<font color="#245bdb">开销</font>。</li><li>实际上这些选项<font color="#245bdb">很少被使用</font>。</li></ul></li></ul><h3 id="4-2-6-IP-转发分组的流程">4.2.6 IP 转发分组的流程</h3><ul><li>若按目的主机号来制作路由表，所得出的路由表就会过于庞大。</li><li>若按<font color="#245bdb">主机所在的网络地址</font>来制作路由表，可使路由表大大简化。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E8%B7%AF%E7%94%B1%E8%A1%A8.png" alt=""></li><li>根据<font color="#245bdb">目的网络地址</font>就能确定下一跳路由器，这样做的结果是：<ul><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的<font color="#245bdb">间接交付</font>）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行<font color="#245bdb">直接交付</font>。</li></ul></li><li><font color="#c00000">特定主机路由</font>：为特定的目的主机指明一个路由，而不是根据目的网络地址所在的网络进行路由选择。<ul><li>采用<font color="#245bdb">特定主机路由</font>可使网络管理人员能更方便地<font color="#245bdb">控制网络</font>和<font color="#245bdb">测试网络</font>，同时也可在需要考虑某种<font color="#245bdb">安全问题</font>时采用这种特定主机路由。</li></ul></li><li><font color="#c00000">默认路由</font>：路由器还可采用<font color="#245bdb">默认路由</font>以<font color="#245bdb">减少路由表所占用的空间</font>和<font color="#245bdb">搜索路由表所用的时间</font>。<ul><li>这种转发方式在一个网络只有<font color="#245bdb">很少的对外连接</font>时是很有用的。</li><li>默认路由在主机发送 IP 数据报时往往更能显示出它的好处。</li><li>如果一个主机连接在一个<font color="#245bdb">小网络</font>上，而这个网络<font color="#245bdb">只用一个路由器和互联网连接</font>，那么在这种情况下使用默认路由是非常合适的。</li></ul></li><li>必须强调指出：<ul><li><u>IP 数据报的首部</u>中<u>没有</u>地方可以用来指明“下一跳路由器的 IP 地址”。</li><li>当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是<font color="#245bdb">送交下层的网络接口软件</font>。</li><li>网络接口软件<font color="#245bdb">使用 ARP </font>负责将<font color="#245bdb">下一跳路由器的 IP 地址转换成硬件地址</font>，并将此<font color="#245bdb">硬件地址</font>放在<font color="#245bdb">链路层的 MAC 帧的首部</font>，然后根据这个硬件地址找到下一跳路由器。</li><li>路由表<font color="#245bdb">没有</font>给分组指明到某个网络的<font color="#245bdb">完整路径</font>。路由表指出，<font color="#245bdb">到某个网络应当先到某个路由器</font>（即<font color="#245bdb">下一跳路由器</font>）。在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</li></ul></li></ul><h2 id="4-3-划分子网和构造超网">4.3 划分子网和构造超网</h2><h3 id="4-3-1-划分子网">4.3.1 划分子网</h3><ul><li><p>从两级 IP 地址到三级 IP 地址</p><ul><li>早期 IP 地址设计不合理的地方：<ol><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li></ol></li><li>三级 IP 地址<ul><li><font color="#c00000">划分子网</font> (subnetting)：在 IP 地址中又增加了一个“<font color="#245bdb">子网号字段</font>”。</li><li>划分子网的基本思路：<ul><li>划分子网纯属一个<font color="#245bdb">单位内部</font>的事情，对外仍然表现为没有划分子网的网络。</li><li>从主机号<font color="#245bdb">借用</font>若干个位作为<font color="#245bdb">子网号</font> subnet-id，而主机号 host-id 也就相应减少了若干个位。==IP 地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}==</li><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<font color="#245bdb">目的网络号</font> net-id，先找到连接在<font color="#245bdb">本单位网络上的路由器</font>。</li><li>然后<font color="#245bdb">此路由器</font>在收到 IP 数据报后，再按<font color="#245bdb">目的网络号</font> net-id 和<font color="#245bdb">子网号</font> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul></li><li>划分子网后 IP 地址就变成了三级结构。</li><li>划分子网只是把 IP 地址的<font color="#245bdb">主机号</font> host-id 这部分进行<font color="#245bdb">再划分</font>，而<font color="#245bdb">不改变 IP 地址原来的网络号</font> net-id。</li><li>优点：<ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li></ul></li></ul></li><li><p>子网掩码</p><ul><li>从一个 IP 数据报的首部并<font color="#245bdb">无法判断</font>源主机或目的主机所连接的网络是否进行了子网划分。</li><li>使用<font color="#c00000">子网掩码</font> (subnet mask) 可以找出 IP 地址中的子网部分。  规则：<ul><li>子网掩码长度 ＝ 32 位 = IP 地址长度</li><li>子网掩码左边部分的一连串 1，对应于网络号和子网号</li><li>子网掩码右边部分的一连串 0，对应于主机号</li></ul></li><li>==(IP 地址) AND (子网掩码) = 子网的网络地址。==（AND 是按位相与：1&amp;1=1；1&amp;0=0；0&amp;1=0；0&amp;0=0 。全 1 为 1，其余为 0）<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E5%AD%90%E7%BD%91%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80.png" alt=""></li><li>如果一个网络不划分子网，那么该网络的子网掩码就是用<font color="#c00000">默认子网掩码</font>。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E9%BB%98%E8%AE%A4%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png" alt=""></li><li>子网掩码是一个重要属性<ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></li><li>子网划分方法<ul><li>有<font color="#245bdb">固定长度子网</font>和<font color="#245bdb">变长子网</font>两种子网划分方法。</li><li>在采用<font color="#245bdb">固定长度子网</font>时，所划分的<font color="#245bdb">所有子网的子网掩码都是相同的</font>。</li><li>全 1 和全 0 的子网号一定要谨慎使用，</li><li>划分子网增加了灵活性，但却<font color="#245bdb">减少了能够连接在网络上的主机总数</font>。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329153316.png" alt=""></li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329153335.png" alt=""></li><li><mark style="background: #BBFABBA6;">同样的 IP 地址和不同的子网掩码可以得出相同的网络地址，但不同的掩码的效果是不同的。</mark>在例 4-2 中，subnet-id 是 2 位，host-id 是 14 位。但例 4-3 中，subnet-id 是 3 位，host-id 是 13 位。因此它们可以划分的子网数和最大主机数都不相同。</li><li>按位相与：全 1 为 1，其余为 0。</li></ul></li><li>在划分子网情况下路由器转发分组的算法<ol><li>从收到的分组的首部提取目的 IP 地址 D。</li><li>先判断<font color="#245bdb">是否直接交付</font>。<font color="#245bdb">用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配</font>。若匹配，则将分组直接交付。否则就是间接交付，执行 (3)。</li><li>若路由表中有目的地址为 D <font color="#245bdb">的特定主机路由</font>，则将分组传送给指明的下一跳路由器；否则，执行 (4)。</li><li><font color="#245bdb">对路由表中的每一行，将子网掩码和 D 逐位相“与”。</font>若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。</li><li>若路由表中有一个<font color="#245bdb">默认路由</font>，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。</li><li>报告转发分组出错。</li></ol></li></ul><h3 id="4-3-3-无分类编址-CIDR（构造超网）">4.3.3 无分类编址 CIDR（构造超网）</h3></li><li><p>使用<font color="#c00000">变长子网掩码</font> <font color="#00b050">VLSM</font> (Variable Length Subnet Mask)可进一步提高 IP 地址资源的利用率。</p></li><li><p>在 VLSM 的基础上又进一步研究出<font color="#245bdb">无分类编址方法</font>，它的正式名字是<font color="#c00000">无分类域间路由选择</font> <font color="#00b050">CIDR</font> (Classless Inter-Domain Routing)。</p></li><li><p>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</p></li><li><p>CIDR 使用各种长度的“<font color="#c00000">网络前缀</font>”(network-prefix)来代替分类地址中的网络号和子网号。</p></li><li><p>IP 地址从三级编址（使用子网掩码）又回到了两级编址。</p></li><li><p>无分类的两级编址的记法是：==IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}==</p></li><li><p>CIDR 使用“<font color="#c00000">斜线记法</font>”(slash notation)，它又称为 <font color="#245bdb">CIDR 记法</font>，即在 IP 地址面加上一个斜线“/”，然后写上<font color="#245bdb">网络前缀所占的位数</font>（这个数值对应于<font color="#245bdb">三级编址中子网掩码中 1 的个数</font>）。例如： 128.14.32.0/20</p></li><li><p>CIDR 地址块</p><ul><li>CIDR 把<font color="#245bdb">网络前缀都相同</font>的<font color="#245bdb">连续</font>的 IP 地址组成“<font color="#c00000">CIDR 地址块</font>”。</li><li>128.14.32.0/20 表示的地址块共有 2<sup>12</sup> 个地址。因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位。<ol><li>这个地址块的起始地址是 128.14.32.0<br>（<u>10000000 00001110 0010</u>0000 00000000）。</li><li>128.14.32.0/20 地址块的最小地址：128.14.32.0<br>（<u>10000000 00001110 0010</u>0000 00000000）</li><li>128.14.32.0/20 地址块的最大地址：128.14.47.255<br>（<u>10000000 00001110 0010</u>1111 11111111）</li><li><mark style="background: #BBFABBA6;"> 全 0 和全 1 的主机号地址一般不使用。</mark></li><li>所有地址的 20 位前缀都是一样的。</li></ol></li></ul></li><li><p><font color="#245bdb">一个 CIDR 地址块可以表示很多地址</font>，所以路由表中就利用这种 CIDR 地址块来查找目的网络。这种地址的聚合常称为<font color="#c00000">路由聚合</font>，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</p></li><li><p>路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p></li><li><p>路由聚合也称为<font color="#c00000">构成超网</font>。</p></li><li><p>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</p></li><li><p>对于 /20  地址块，它的掩码是 20 个连续的 1。斜线记法中的数字就是掩码中 1 的个数。</p></li><li><p>构成超网：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329161815.png" alt=""></p><ul><li>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C  类地址。这些 C 类地址合起来就构成了<font color="#245bdb">超网</font>。（可以理解为把许多小的网络合并成一个超网，而划分子网时把一个网络划分成许多小的子网）</li><li>CIDR 地址块中的地址数一定是 <font color="#245bdb">2 的整数次幂</font>。</li><li><font color="#245bdb">网络前缀越短，其地址块所包含的地址数就越多</font>。</li><li>而在三级结构的 IP 地址中，<font color="#245bdb">划分子网是使网络前缀变长</font>。</li><li>CIDR 的一个好处是：可以<font color="#245bdb">更加有效地分配 IPv4 的地址空间</font>，可根据客户的需要分配适当大小的 CIDR 地址块。</li></ul></li><li><p>最长前缀匹配</p><ul><li>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。</li><li>应当从匹配结果中选择具有最长网络前缀的路由：<font color="#c00000">最长前缀匹配</font> (longest-prefix matching)。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体 (more specific) 。</li><li>最长前缀匹配又称为<font color="#245bdb">最长匹配</font>或<font color="#245bdb">最佳匹配</font>。</li></ul></li><li><p>使用二叉线索查找路由表</p><ul><li>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。</li><li>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<font color="#c00000">二叉线索</font>。</li><li>IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</li><li>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1.png" alt=""></li></ul></li></ul><h2 id="4-4-网际控制报文协议-ICMP">4.4 网际控制报文协议 ICMP</h2><ul><li><p><font color="#c00000">网际控制报文协议</font> <font color="#00b050">ICMP</font> (Internet Control Message Protocol)：用来使主机或路由器报告差错情况和提供有关异常情况的报告，这样就更有效地转发 IP 数据报和提高交付成功的机会。</p></li><li><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p></li><li><p>但 ICMP 不是高层协议，而是 IP 层的协议。看起来好像是高层协议，是因为 <font color="#245bdb">ICMP 报文是装在 IP 数据报中</font>，作为其中的<font color="#245bdb">数据部分</font>。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329165916.png" alt=""></p></li><li><p>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。</p></li><li><p>ICMP 报文的种类有两种，即<font color="#c00000"> ICMP 差错报告报文</font>和<font color="#c00000"> ICMP 询问报文</font>。</p></li><li><p>ICMP 差错报告报文共有 5 种：</p><ul><li><font color="#00b050">终点不可达 </font></li><li><font color="#00b050">源点抑制 </font>：降低放松速率减缓拥堵。</li><li><font color="#00b050">时间超过 </font></li><li><font color="#00b050">参数问题 </font></li><li><font color="#00b050">改变路由（重定向）</font></li></ul></li><li><p><font color="#245bdb"> 所有的 ICMP 差错报文中的数据字段都具有相同的格式</font>。</p></li><li><p>不应发送 ICMP 差错报告报文的几种情况：</p><ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ul></li><li><p>ICMP 询问报文有两种：</p><ul><li><font color="#c00000">回送请求和回答报文</font></li><li><font color="#c00000">时间戳请求和回答报文</font></li></ul></li><li><p>ICMP 的应用举例：</p><ul><li><font color="#245bdb">PING</font> (Packet InterNet Groper)<ul><li>PING 用来测试两个主机之间的<font color="#245bdb">连通性</font>。</li><li>PING 使用了 <font color="#245bdb">ICMP 回送请求与回送回答报文</font>。</li><li>PING 是<font color="#245bdb">应用层直接使用网络层 ICMP</font> 的例子，它没有通过运输层的 TCP 或 UDP。</li></ul></li><li>Traceroute 的应用举例<ul><li>在 Windows 操作系统中这个命令是 <font color="#245bdb">tracert</font>。</li><li>用来跟踪一个分组<font color="#245bdb">从源点到终点的路径</font>。</li><li>它利用 IP 数据报中的 TTL 字段和 ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。</li></ul></li></ul></li></ul><h2 id="4-5-因特网的路由选择协议">4.5 因特网的路由选择协议</h2><h3 id="4-5-1-有关路由选择协议的几个基本概念">4.5.1  有关路由选择协议的几个基本概念</h3><ul><li><p>关于“<font color="#245bdb">最佳路由</font>”</p><ul><li>不存在一种绝对的最佳路由算法。</li><li>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li><li>路由选择是个非常复杂的问题：<ul><li>它是网络中的所有结点共同协调工作的结果。</li><li>路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。</li></ul></li></ul></li><li><p>从路由算法的自适应性考虑 ：</p><ul><li><font color="#c00000">静态路由选择策略</font>——即<font color="#c00000">非自适应</font>路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。</li><li><font color="#c00000">动态路由选择策略</font>——即<font color="#c00000">自适应</font>路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</li></ul></li><li><p><font color="#c00000">自治系统</font> <font color="#00b050">AS</font> (Autonomous System)：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。</p></li><li><p>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是<font color="#245bdb">一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略</font>。</p></li><li><p><strong>互联网有两大类路由选择协议</strong>：</p></li></ul><ol><li><font color="#c00000">内部网关协议</font> <font color="#00b050">IGP</font> (Interior Gateway Protocol)  ：在一个<font color="#245bdb">自治系统内部使用</font>的路由选择协议。<br>如 <font color="#6425d0">RIP</font> 和 <font color="#6425d0">OSPF</font> 协议。</li><li><font color="#c00000">外部网关协议</font> <font color="#00b050">EGP</font> (External Gateway Protocol) ：若源站和目的站处在<font color="#245bdb">不同的自治系统</font>中，当数据报传到一个自治系统的边界时，就需要使用一种协议<font color="#245bdb">将路由选择信息传递到另一个自治系统中</font>。<br>在外部网关协议中目前使用最多的是 <font color="#6425d0">BGP-4</font>。</li></ol><ul><li><p>IGP 和 EGP 是协议类别的名称，而不是协议的名称。</p></li><li><p>自治系统之间的路由选择也叫做<font color="#c00000">域间路由选择</font> (interdomain routing)，</p></li><li><p>在自治系统内部的路由选择叫做<font color="#c00000">域内路由选择</font> (intradomain routing) 。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329180741.png" alt=""></p></li></ul><h3 id="4-5-2-内部网关协议-RIP">4.5.2 内部网关协议 RIP</h3><ul><li><p><font color="#c00000">路由信息协议</font> <font color="#00b050">RIP</font> (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。</p></li><li><p>RIP 是一种<font color="#245bdb">分布式的、基于距离向量的</font>路由选择协议。</p></li><li><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的<font color="#245bdb">距离</font>记录。</p></li><li><p>RIP 协议中的“距离”也称为“<font color="#245bdb">跳数</font>”，因为每经过一个路由器，跳数就加 1。</p></li><li><p>RIP 协议认为好的路由就是它通过的路由器数目少，即“距离短”。这里的距离指的是“最短距离”。</p></li><li><p>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（距离最短），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p></li><li><p>RIP 允许一条路径最多包含 15 个路由器，距离=16 时即认为不可达。</p></li><li><p><mark style="background: #BBFABBA6;">RIP 只适用于小型互联网</mark>。</p></li><li><p>RIP 和 OSPF 协议都是分布式路由选择协议，它们的共同特点就是每一个路由器都要不断地和其他路由器交换信息。要搞清楚以下三点：和哪些路由器交换信息？交换什么信息？在什么时候交换信息？</p></li><li><p>RIP 协议的三个特点：</p><ol><li>仅和<font color="#245bdb">相邻路由器</font>交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的<font color="#245bdb">路由表</font>。</li><li>按<font color="#245bdb">固定的时间间隔</font>交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ol></li><li><p>路由器在<font color="#245bdb">刚开始工作</font>时，只知道到直接连接的网络的距离（此距离定义为 1）。它的<font color="#245bdb">路由表是空的</font>。</p></li><li><p>以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</p></li><li><p>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</p></li><li><p>RIP 协议的<font color="#c00000">收敛</font> (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</p></li><li><p>路由表最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。</p></li><li><p>路由表更新的原则是找出到每个目的网络的<font color="#245bdb">最短距离</font>。这种更新算法又称为<font color="#c00000">距离向量算法</font>。</p></li><li><p><strong>距离向量算法</strong></p></li><li><p>距离向量算法的基础就是 <font color="#245bdb">Bellman-Ford 算法</font>（或<font color="#245bdb"> Ford-Fulkerson 算法</font>）。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95.png" alt=""></p><ul><li><p>例：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329184809.png" alt=""></p></li><li><p>课后题 4-42 和 4-42。</p></li></ul></li><li><p>RIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</p></li><li><p>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p></li><li><p>RIP 协议的报文格式</p><ul><li>RIP2 是较新的 RIP 版本。</li><li>RIP2 <u>支持变长子网掩码和 CIDR</u>。</li><li>RIP2 还可以提供简单的<font color="#245bdb">鉴别</font>功能。</li><li>RIP 协议使用运输层的用户数据包<font color="#245bdb"> UDP</font> 进行传送（端口 502）。</li><li>RIP 协议的特点：<font color="#245bdb">好消息传播得快，坏消息传播得慢</font>。即网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是 RIP 的一个主要缺点。</li></ul></li><li><p>RIP 协议的优缺点：</p><ul><li>优点：实现简单，开销较小。</li><li>缺点：<ol><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是完整的路由表，因而随着网络规模的扩大，<font color="#245bdb">开销</font>也就增加。</li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。<br>因此，<mark style="background: #BBFABBA6;">对于<u>规模较大的网络</u>就应该使用 OSPF 协议，RIP 协议在<u>规模较小的网络</u>中占据多数。</mark></li></ol></li></ul></li></ul><h3 id="4-5-3-内部网关协议-OSPF">4.5.3 内部网关协议 OSPF</h3><ul><li><p><font color="#c00000">开放最短路径优先</font> <font color="#00b050">OSPF</font> (Open Shortest Path First)</p><ul><li>“开放”表明 OSPF 协议不是受某一家厂商控制，而是<font color="#245bdb">公开发表</font>的。</li><li>“最短路径优先”是因为使用了 Dijkstra 提出的<font color="#245bdb">最短路径算法 SPF</font></li></ul></li><li><p>注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p></li><li><p>OSPF 的原理很简单，但实现起来却较复杂。</p></li><li><p>OSPF 采用分布式的<font color="#245bdb">链路状态协议</font> (link state protocol)，而不是 RIP 那样的的距离向量协议。</p></li><li><p>三个要点：</p><ol><li>向本自治系统中<font color="#245bdb">所有路由器</font>发送信息，这里使用的方法是<font color="#c00000">洪泛法</font>。</li><li>发送的信息就是与本路由器<font color="#245bdb">相邻的所有路由器的链路状态</font>，但这只是路由器所知道的<font color="#245bdb">部分信息</font>。<ul><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“<font color="#c00000">度量</font>”(metric)。</li><li>度量可以使费用、距离、时延、带宽等等。由管理人员指定。</li></ul></li><li>只有当链路状态<font color="#245bdb">发生变化</font>时，路由器才用洪泛法向所有路由器发送此信息。</li></ol></li><li><p>由这 3 个要点可以看出：OSPF 和 RIP 协议的工作原理相差较大。</p></li><li><p><font color="#c00000">链路状态数据库</font> (link-state database)</p><ul><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li><li>这个数据库实际上就是<font color="#245bdb">全网的拓扑结构图</font>，它在全网范围内是一致的（这称为<font color="#245bdb">链路状态数据库的同步</font>）。</li><li>OSPF 的链路状态数据库能<font color="#245bdb">较快地进行更新</font>，使各个路由器能及时更新其路由表。</li><li><font color="#245bdb">OSPF 的更新过程收敛得快是其重要优点。</font></li></ul></li><li><p>OSPF 的<font color="#c00000">区域</font>（area）</p><ul><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。</li><li>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</li><li>区域也不能太大，在一个区域内的路由器最好不超过 200 个。</li><li>划分区域的<font color="#245bdb">好处</font>：就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</li><li><font color="#245bdb">在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</font></li></ul></li><li><p>OSPF 使用<font color="#245bdb">层次结构的区域划分</font>。</p><ul><li>在上层的区域叫做<font color="#c00000">主干区域</font> (backbone area)。</li><li>主干区域的标识符规定为 0.0.0.0。主干区域的<font color="#245bdb">作用</font>是用来连通其他在下层的区域。</li><li>从其他区域过来的信息都由<font color="#c00000">区域边界路由器</font>进行概括。一个区域至少有一个区域边界路由器。在主干区域内的路由器称为<font color="#c00000">主干路由器</font>，一个主干路由器可以同时是一个边界路由器。</li><li>在主干区域内还要有一个路由器专门和<font color="#245bdb">本自治系统外</font>的<font color="#245bdb">其他自治系统</font>交换路由信息，这样的路由器称为<font color="#c00000">自治系统边界路由器</font>。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329192543.png" alt=""></li></ul></li><li><p><font color="#245bdb">OSPF 不用 UDP 而是直接用 IP 数据报传送。</font></p></li><li><p>OSPF 构成的<font color="#245bdb">数据报很短</font>。这样做可减少路由信息的通信量。</p></li><li><p>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p></li><li><p>OSPF 的其他特点：</p><ul><li>OSPF 对于不同类型的业务可计算出不同的路由。</li><li><font color="#245bdb">多路径间的负载平衡</font>：如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。</li><li>所有在 OSPF 路由器之间交换的分组都具有<font color="#245bdb">鉴别</font>的功能。</li><li>和 RIP 一样，OSPF <font color="#245bdb">支持可变长度的子网划分和无分类编址 CIDR。</font></li><li>每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。</li></ul></li><li><p>OSPF 的五种分组类型：</p><ol><li>问候 (Hello)分组。</li><li>数据库描述 (Database Description)分组。</li><li>链路状态请求 (Link State Request)分组。</li><li>链路状态更新 (Link State Update)分组，用洪泛法对全网更新链路状态。</li><li>链路状态确认 (Link State Acknowledgment)分组。</li></ol></li><li><p>OSPF 使用的是<strong>可靠的洪泛法</strong>。</p></li><li><p>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</p></li><li><p>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。<mark style="background: #BBFABBA6;">因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 </mark></p></li><li><p>OSPF 没有“坏消息传播得慢”的问题。</p></li><li><p>OSPF 对多点接入的局域网采用了<font color="#c00000">指定的路由器</font>的方法，使广播的信息量大大减少。</p></li><li><p>指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</p></li></ul><h3 id="4-5-4-外部网关协议-BGP">4.5.4 外部网关协议 BGP</h3><ul><li><p><mark style="background: #BBFABBA6;"><font color="#c00000">边界网关协议</font> <font color="#c00000">BGP</font>：是不同自治系统的路由器之间交换路由信息的协议</mark>。</p></li><li><p>BGP 的使用环境：</p><ol><li>因特网的规模太大，使得自治系统之间路由选择非常困难。<ul><li>对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。</li><li>当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。</li><li>比较合理的做法是在 AS 之间交换“<font color="#245bdb">可达性</font>”信息。</li></ul></li><li>自治系统之间的路由选择必须考虑有关<font color="#245bdb">策略</font>。</li></ol></li><li><p>因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且<font color="#245bdb">比较好的路由</font>（不能兜圈子），而<font color="#245bdb">并非要寻找一条最佳路由</font>。</p></li><li><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ <font color="#245bdb">BGP 发言人</font>” 。</p></li><li><p>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。</p></li><li><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 <font color="#245bdb">TCP 连接</font>，然后在此连接上交换 BGP 报文以建立 <font color="#245bdb">BGP 会话</font> (session)，利用 BGP 会话交换路由信息。</p></li><li><p>使用 TCP 连接能提供<font color="#245bdb">可靠</font>的服务，也简化了路由选择协议。</p></li><li><p>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<font color="#245bdb">邻站</font>(neighbor)或<font color="#245bdb">对等站</font>(peer) 。</p></li><li><p>BGP 发言人和自治系统 AS 的关系：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329203111.png" alt=""></p></li><li><p>BGP 所交换的<font color="#245bdb">网络可达性</font>的信息就是<font color="#245bdb">要到达某个网络所要经过的一系列 AS</font>。</p></li><li><p>当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。</p></li><li><p>BGP 发言人交换<font color="#245bdb">路径向量</font>的例子：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329204304.png" alt=""></p><ol><li>自治系统 AS2 的 BGP 发言人通知主干网 AS1 的 BGP 发言人：“要到达网络 N1、 N2、N3 和 N4 可经过 AS2。</li><li>主干网发出通知：“要到达网络 N1、N2 和 N3 可沿路径（AS1, AS2）。</li></ol></li><li><p>BGP 协议交换路由信息的<font color="#245bdb">结点</font>数量级是<font color="#245bdb">自治系统数</font>的量级，这要<font color="#245bdb">比这些自治系统中的网络数少很多。</font></p></li><li><p>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。</p></li><li><p><font color="#245bdb">BGP 支持 CIDR</font>，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p></li><li><p>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时<font color="#245bdb">更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。 </font></p></li><li><p>BGP-4 共使用四种报文：</p><ol><li>打开 (OPEN) 报文，用来与相邻的另一个 BGP 发言人建立关系。</li><li>更新 (UPDATE) 报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li>保活 (KEEPALIVE) 报文，用来确认打开报文和周期性地证实邻站关系。</li><li>通知 (NOTIFICATION) 报文，用来发送检测到的差错。</li></ol></li><li><p>BGP 系统很容易解决距离向量路由选择算法中的“坏消息传播得慢”问题。</p></li></ul><h3 id="4-5-5-路由器的组成">4.5.5 路由器的组成</h3><ul><li><p>路由器是一种典型的<font color="#245bdb">网络层设备</font>。</p></li><li><p>路由器是互联网中的关键设备。</p></li><li><p>路由器的主要作用是：</p><ol><li>连通不同的网络。</li><li>选择信息传送的线路。</li></ol></li><li><p>路由器是一种<font color="#245bdb">具有多个输入端口和多个输出端口的专用计算机</font>，其<font color="#245bdb">任务是转发分组</font>。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。</p></li><li><p>下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。</p></li><li><p>路由器的转发分组正是网络层的主要工作。</p></li><li><p>路由器的典型结构：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329205017.png" alt=""></p></li><li><p>整个的路由器结构可划分为两大部分：</p><ol><li><font color="#00b050">路由选择部分</font><ul><li>也叫做<font color="#245bdb">控制部分</font>，其核心构件是<font color="#245bdb">路由选择处理机</font>。</li><li><font color="#245bdb">路由选择处理机的任务</font>是根据所选定的路由选择协议<font color="#245bdb">构造出路由表</font>，同时经常或定期地和相邻路由器<font color="#245bdb">交换路由信息</font>而不断地<font color="#245bdb">更新和维护路由表</font>。</li></ul></li><li><font color="#00b050">分组转发部分</font><br>分组转发部分由三部分组成：<ol><li><font color="#00b0f0">交换结构</font>：又称为<font color="#245bdb">交换组织</font>，其作用是根据<font color="#245bdb">转发表</font>对分组进行处理。</li><li><font color="#00b0f0">一组输入端口</font></li><li><font color="#00b0f0">一组输出端口</font>（请注意：这里的端口就是硬件接口）</li></ol></li></ol></li><li><p><strong>“转发”和“路由选择”的区别</strong></p><ul><li>“<font color="#245bdb">转发</font>”(forwarding) 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</li><li>“<font color="#245bdb">路由选择</font>”(routing) 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。</li><li>路由表是根据<font color="#245bdb">路由选择算法</font>得出的。而转发表是从<font color="#245bdb">路由表</font>得出的。</li><li>路由表总是用软件实现的，而转发表可用特殊的硬件来实现。</li><li><font color="#245bdb">在讨论路由选择的原理时，往往不去区分转发表和路由表的区别</font>。</li></ul></li><li><p>输入端口对线路上收到的分组的处理：数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。</p></li><li><p>输出端口将交换结构传送来的分组发送到线路，交换结构传送过来的分组先进行缓存。数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</p></li><li><p>分组丢弃：若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</p></li><li><p><font color="#245bdb">路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因</font>。</p></li><li><p>交换结构：</p><ul><li>交换结构是路由器的关键构件。</li><li>正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。</li><li>实现交换有多种方法。常用交换方法有三种：<ol><li>通过<font color="#00b050">存储器</font></li><li>通过<font color="#00b050">总线</font></li><li>通过<font color="#00b050">纵横交换结构</font>（这种交换结构常称为<font color="#245bdb">互连网络</font>）<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329210919.png" alt=""></li></ol></li></ul></li></ul><h2 id="4-6-IP-多播">4.6 IP 多播</h2><h3 id="4-6-1-IP-多播的基本概念">4.6.1 IP 多播的基本概念</h3><ul><li><p><font color="#c00000">IP 多播</font> ：在因特网上进行多播。</p></li><li><p>目的：更好地支持<font color="#245bdb">一对多通信</font>。</p></li><li><p>一对多通信：<font color="#c00000">一个源点发送到许多个终点</font>。<br>例如，实时信息的交付（如新闻、股市行情等），软件更新，交互式会议及其他多媒体通信。</p></li><li><p>多播可明显地减少网络中资源的消耗。</p></li><li><p><font color="#245bdb">互联网范围的多播要靠路由器来实现。</font></p></li><li><p>能够运行多播协议的路由器称为<font color="#c00000">多播路由器</font> (multicast router)。当然它也可以转发普通的单播 IP 数据报。</p></li><li><p>从 1992 年起，在互联网上开始试验虚拟的<font color="#c00000">多播主干网</font> MBONE。现在多播主干网已经有了相当大的规模。</p></li><li><p>在因特网上进行多播就叫做 IP 多播。</p></li><li><p>IP 多播所传送的分组需要使用 IP 多播地址。</p></li><li><p>多播 IP 地址</p><ul><li>IP 多播所传送的分组需要使用<font color="#245bdb">多播 IP 地址</font>。</li><li>在多播数据报的目的地址写入的是<font color="#245bdb">多播组的标识符</font>。</li><li><font color="#245bdb">多播组的标识符就是 IP 地址中的 D 类地址（多播地址）。</font></li><li>每一个 D 类地址标志一个多播组。</li><li><font color="#245bdb">多播地址只能用于目的地址，不能用于源地址。</font></li></ul></li><li><p>多播数据报和一般的 IP 数据报的区别就是它使用 <font color="#245bdb">D 类 IP 地址</font>作为目的地址，并且首部中的<font color="#245bdb">协议字段值是 2</font>，表明使用<font color="#245bdb">网际组管理协议 IGMP</font>。</p></li><li><p>多播数据报也是“<font color="#245bdb">尽最大努力交付</font>”，不保证一定能够交付多播组内的所有成员。</p></li><li><p>对多播数据报<font color="#245bdb">不产生 ICMP 差错报文</font>。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p></li><li><p>IP 多播分为两种，一种是在<font color="#245bdb">本局域网上进行硬件多播</font>，另一种则是<font color="#245bdb">在因特网范围内进行多播</font>。</p></li></ul><h3 id="4-6-2-在局域网上进行硬件多播">4.6.2 在局域网上进行硬件多播</h3><ul><li>互联网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为 00-00-5 E。</li><li>因此 TCP/IP 协议使用的<font color="#245bdb">以太网地址块</font>的范围是：<br>从  <font color="#245bdb"> 00-00-5 E-00-00-00</font><br>到  <font color="#245bdb"> 00-00-5 E-FF-FF-FF </font></li><li>不难看出，在每一个地址中，只有 23 位可用作多播。</li><li>D 类 IP 地址可供分配的有 28 位，在这 28 位中的<u>前 5 位不能用来构成以太网硬件地址</u>。</li><li>D 类 IP 地址与以太网多播地址的映射关系：<img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329214148.png" alt=""></li><li>由于<u>多播 IP 地址与以太网硬件地址的映射关系不是唯一的</u>，因此收到多播数据报的主机，<font color="#245bdb">还要在 IP 层利用软件进行过滤</font>，把不是本主机要接收的数据报丢弃。</li></ul><h3 id="4-6-3-网际组管理协议-IGMP-和多播路由选择协议">4.6.3 网际组管理协议 IGMP 和多播路由选择协议</h3><ul><li>IP 多播需要两种协议</li></ul><ol><li>为了使路由器知道多播组成员的信息，需要利用<font color="#c00000">网际组管理协议 IGMP</font> (Internet Group Management Protocol)。</li><li>连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<font color="#c00000">多播路由选择协议</font>。</li></ol><ul><li><p>IGMP 的使用范围：</p><ul><li>IGMP <font color="#245bdb">并非</font>在互联网范围内对所有多播组成员进行管理的协议。</li><li>IGMP <font color="#245bdb">不知道</font> IP 多播组包含的成员数，<font color="#245bdb">也不知道</font>这些成员都分布在哪些网络上。</li><li>IGMP 协议是让连接在<font color="#245bdb">本地局域网</font>上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。</li></ul></li><li><p>多播路由选择协议更为复杂：</p><ul><li>多播转发必须<font color="#245bdb">动态地适应多播组成员的变化</font>（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</li><li>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的<font color="#245bdb">目的地址</font>，而是还要考虑这个多播数据报<font color="#245bdb">从什么地方来和要到什么地方去</font>。</li><li>多播数据报<font color="#245bdb">可以由没有加入多播组的主机发出</font>，也可以通过没有组成员接入的网络。</li></ul></li><li><p>网际组管理协议 IGMP</p><ul><li>和 ICMP 相似，<font color="#245bdb">IGMP 使用 IP 数据报传递其报文</font>（即 IGMP 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。</li><li>因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</li></ul></li><li><p>IGMP 的工作可分为两个阶段：</p><ol><li><font color="#245bdb">第一阶段：加入多播组。</font><br>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送 IGMP 报文，声明自己要成为该组的成员。<br>本地的多播路由器收到 IGMP 报文后，将组成员关系转发给互联网上的其他多播路由器。</li><li><font color="#245bdb">第二阶段：探询组成员变化情况。</font><br>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。<br>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。<br>但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</li></ol></li><li><p>IGMP 采用的一些具体措施：</p><ul><li><font color="#245bdb">在主机和多播路由器之间的所有通信都是使用 IP 多播。</font></li><li>多播路由器在探询组成员关系时，只需要对<font color="#245bdb">所有的组发送一个请求信息的询问报文</font>，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒发送一次。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li><li>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。对应于最小时延的响应最先发送。</li><li>同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。</li></ul></li><li><p>多播路由选择</p><ul><li>播路由选择协议尚未标准化。</li><li>一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。</li><li><font color="#245bdb">多播路由选择实际上就是要找出以源主机为根结点的多播转发树。</font></li><li>在多播转发树上的路由器不会收到重复的多播数据报。</li><li>对不同的多播组对应于不同的多播转发树。</li><li>同一个多播组，对不同的源点也会有不同的多播转发树。</li></ul></li><li><p>多播路由选择协议在转发多播数据报时使用三种方法：</p><ol><li>洪泛与剪除</li><li>隧道技术 (tunneling)</li><li>基于核心的发现技术</li></ol></li></ul><h2 id="4-7-虚拟专用网-VPN-和网络地址转换-NAT">4.7  虚拟专用网 VPN 和网络地址转换 NAT</h2><h3 id="4-7-1-虚拟专用网-VPN">4.7.1 虚拟专用网 VPN</h3><ul><li><p>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅<font color="#245bdb">在机构内部使用</font>的计算机就可以由本机构<font color="#245bdb">自行分配其 IP 地址</font>。</p></li><li><p><font color="#c00000">本地地址</font>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</p></li><li><p><font color="#c00000">全球地址</font>——全球唯一的 IP 地址，必须向互联网的管理机构申请.</p></li><li><p>问题：在内部使用的本地地址就有可能和互联网中某个 IP 地址<font color="#245bdb">重合</font>，这样就会出现地址的二义性问题。如何解决？<br>解决：RFC 1918 指明了一些<font color="#c00000">专用地址</font> (private address)。<font color="#245bdb">专用地址只能用作本地地址</font>而不能用作全球地址。<font color="#245bdb">在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</font>。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329221238.png" alt=""></p></li><li><p>采用这样的专用 IP 地址的互连网络称为<font color="#245bdb">专用互联网</font>或<font color="#245bdb">本地互联网</font>，或更简单些，就叫做<font color="#c00000">专用网</font>。</p></li><li><p>因为这些专用地址仅在本机构内部使用。专用 IP 地址也叫做<font color="#c00000">可重用地址 </font>(reusable address)。</p></li><li><p>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为<font color="#c00000">虚拟专用网 VPN</font> (Virtual Private Network)。</p><ul><li>“<font color="#245bdb">专用网</font>”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。</li><li>“<font color="#245bdb">虚拟</font>”表示“好像是”，但实际上并不是，因为现在<font color="#245bdb">并没有真正使用通信专线</font>，而 VPN 只是在效果上和真正的专用网一样。</li></ul></li><li><p>如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的<font color="#245bdb">数据都必须加密</font>。</p></li><li><p>一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</p></li><li><p>用隧道技术实现局域网：</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E7%94%A8%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt=""></p></li><li><p>由部门 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为<font color="#c00000">内联网 </font>(intranet)，表示部门 A 和 B 都是在<font color="#245bdb">同一个机构的内部</font>。</p></li><li><p>一个机构和某些外部机构共同建立的虚拟专用网 VPN 又称为<font color="#c00000">外联网 </font>(extranet)。</p></li><li><p>请注意，内联网 intranet 和外联网 extranet 都是<font color="#245bdb">基于 TCP/IP 协议</font>的。</p></li><li><p>还有一种类型的 VPN，就是<font color="#c00000">远程接入 VPN</font>：</p><ul><li>远程接入 VPN 可以满足外部流动员工访问公司网络的需求。</li><li>在外地工作的员工拨号接入互联网，而驻留在员工 PC 机中的 VPN 软件可在员工的 PC 机和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。</li></ul></li></ul><h3 id="4-8-2-互联网地址转换-NAT">4.8.2 互联网地址转换 NAT</h3><ul><li><p>问题：在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？</p></li><li><p>解决：</p><ol><li>再申请一些全球 IP 地址。但这在很多情况下是不容易做到的。</li><li>采用<font color="#c00000">网络地址转换</font> NAT。这是目前使用得最多的方法。</li></ol></li><li><p>需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 <font color="#245bdb">NAT 路由器</font>，它至少有一个<font color="#245bdb">有效的外部全球 IP 地址</font>。</p></li><li><p>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上<font color="#245bdb">将其本地地址转换成全球 IP 地址</font>，才能和互联网连接。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Pasted%20image%2020230329224816.png" alt=""></p></li><li><p>网络地址转换的过程：</p><ul><li>内部主机 A 用<font color="#245bdb">本地地址</font> IPA 和互联网上主机 B 通信所发送的数据报必须经过 NAT 路由器。</li><li>NAT 路由器<font color="#245bdb">将数据报的源地址 IPA 转换成全球地址 IPG</font> ，并把转换结果记录到 <font color="#245bdb">NAT 地址转换表</font>中，目的地址 IPB 保持不变，然后发送到互联网。</li><li>NAT 路由器收到主机 B 发回的数据报时，知道数据报中的源地址是  IPB  而目的地址是 IPG  。</li><li><font color="#245bdb">根据 NAT 转换表</font>，NAT 路由器<font color="#245bdb">将目的地址 IPG 转换为 IPA </font>，转发给最终的内部主机 A。</li></ul></li><li><p>可以看出，在内部主机与外部主机通信时，在 NAT 路由器上发生了<font color="#245bdb">两次地址转换</font>：</p><ol><li><font color="#245bdb">离开专用网</font>时：替换源地址，将内部地址替换为全球地址；</li><li><font color="#245bdb">进入专用网</font>时：替换目的地址，将全球地址替换为内部地址；</li></ol></li><li><p>当 NAT 路由器具有 n 个全球 IP 地址时，专用网内<font color="#245bdb">最多可以同时有 n 台主机</font>接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的全球 IP 地址。</p></li><li><p>通过 NAT 路由器的通信必须由专用网内的主机发起。<font color="#245bdb">专用网内部的主机不能充当服务器用</font>，因为互联网上的客户无法请求专用网内的服务器提供服务。</p></li><li><p>网络地址与端口号转换 NAPT</p><ul><li>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表<font color="#245bdb">把运输层的端口号也利用上</font>。这样，就可以使多个拥有本地地址的主机，<font color="#245bdb">共用一个 NAT 路由器上的全球 IP 地址</font>，因而可以同时和互联网上的不同主机进行通信。</li><li>使用端口号的 NAT 叫做<font color="#c00000">网络地址与端口号转换 NAPT</font> (Network Address and Port Translation)，而不使用端口号的 NAT 就叫做<font color="#245bdb">传统的 NAT</font> (traditional NAT)。</li></ul></li><li><p>NAPT把专用网内不同的源 IP 地址，都转换为<font color="#245bdb">同样的全球 IP 地址</font>。但对源主机所采用的 TCP 端口号（不管相同或不同），则转换为<font color="#245bdb">不同的新的端口号</font>。因此，当 NAPT 路由器收到从互联网发来的应答时，就可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从 NAPT 转换表中找到正确的目的主机。</p></li></ul><h1 id="第-5-章运输层">第 5 章运输层</h1><h2 id="5-1-运输层协议概述">5.1  运输层协议概述</h2><h3 id="5-1-1-进程之间的通信">5.1.1  进程之间的通信</h3><h3 id="5-1-2-运输层的两个主要协议">5.1.2  运输层的两个主要协议</h3><h3 id="5-1-3-运输层的端口">5.1.3  运输层的端口</h3><h2 id="5-2-用户数据报协议-UDP">5.2  用户数据报协议 UDP</h2><h3 id="5-2-1-UDP-概述">5.2.1  UDP 概述</h3><h3 id="5-2-2-UDP-的首部格式">5.2.2  UDP 的首部格式</h3><h2 id="5-3-传输控制协议-TCP-概述">5.3 传输控制协议 TCP 概述</h2><h3 id="5-3-1-TCP-最主要的特点">5.3.1 TCP 最主要的特点</h3><h3 id="5-3-2-TCP-的连接">5.3.2 TCP 的连接</h3><h2 id="5-4-可靠传输的工作原理">5.4 可靠传输的工作原理</h2><h3 id="5-4-1-停止等待协议">5.4.1 停止等待协议</h3><h3 id="5-4-2-连续-ARQ-协议">5.4.2 连续 ARQ 协议</h3><h2 id="5-5-TCP-报文段的首部格式">5.5  TCP 报文段的首部格式</h2><h2 id="5-6-TCP-可靠传输的实现">5.6 TCP 可靠传输的实现</h2><h3 id="5-6-1-以字节为单位的滑动窗口">5.6.1 以字节为单位的滑动窗口</h3><h3 id="5-6-2-超时重传时间的选择">5.6.2 超时重传时间的选择</h3><h3 id="5-6-3-选择确认-SACK">5.6.3 选择确认 SACK</h3><h2 id="5-7-TCP-的流量控制">5.7 TCP 的流量控制</h2><h3 id="5-7-1-利用滑动窗口实现流量控制">5.7.1 利用滑动窗口实现流量控制</h3><h3 id="5-7-2-必须考虑传输效率">5.7.2 必须考虑传输效率</h3><h2 id="5-8-TCP-的拥塞控制">5.8 TCP 的拥塞控制</h2><h3 id="5-8-1-拥塞控制的一般原理">5.8.1 拥塞控制的一般原理</h3><h3 id="5-8-2-几种拥塞控制方法">5.8.2 几种拥塞控制方法</h3><h3 id="5-8-3-随机早期检测-RED">5.8.3 随机早期检测 RED</h3><h2 id="5-9-TCP-的运输连接管理">5.9 TCP 的运输连接管理</h2><ul><li><p>TCP 是<strong>面向连接</strong>的协议。</p></li><li><p>TCP 连接有三个阶段：</p><ol><li>连接建立</li><li>数据传送</li><li>连接释放</li></ol></li><li><p><strong>TCP 连接的管理</strong>就是使 TCP 连接的建立和释放都能正常地进行。</p></li><li><p>TCP 连接建立过程中要解决的三个问题：</p><ol><li>要使每一方能够确知对方的存在。</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol></li><li><p>客户-服务器模式：</p><ol><li>TCP 连接的建立采用<font color="#245bdb">客户-服务器方式</font>。</li><li>主动发起连接建立的应用进程叫做<font color="#245bdb">客户 (client)</font>。</li><li>被动等待连接建立的应用进程叫做<font color="#245bdb">服务器 (server)</font>。</li></ol></li></ul><h3 id="5-9-1-TCP-的连接建立">5.9.1 TCP 的连接建立</h3><ul><li><p><font color="#c00000">握手</font>：TCP 建立连接的过程。</p></li><li><p><font color="#c00000"> 三次握手 (three-way handshake)</font>：客户和服务器之间交换三个 TCP 报文段以建立连接。</p></li><li><p>A 向 B 发送请求，B 回复确认足以建立连接，为什么 A 还要再向 B 发送一次确认呢？<br>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230324050110494.png" alt="image-20230324050110494"></p></li></ul><h3 id="5-9-2-TCP-的连接释放">5.9.2 TCP 的连接释放</h3><ul><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p></li><li><p>为什么 A 必须经过<font color="#245bdb">时间等待计时器</font>设置的时间 2 MSL （<font color="#245bdb">最长报文段寿命</font>）后，才能进入 CLOSED 状态？<br>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。<br>第二，防止已失效的连接请求报文段出现在本连接中。</p></li><li><p>保活计时器：用来防止在 TCP 连接出现长时期的空闲。<br>保活计时器通常设置为 2 小时。若服务器过了 2 小时还没有收到客户的信息，它就发送探测报文段。<br>若发送了 10 个探测报文段（每一个相隔 75 秒）还没有响应，就假定客户出了故障，因而就终止该连接。</p></li></ul><h3 id="5-9-3-TCP-的有限状态机">5.9.3 TCP 的有限状态机</h3><ul><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/image-20230324055311713.png" alt="image-20230324055311713"></p></li><li><p>粗实线箭头表示对客户进程的正常变迁。</p></li><li><p>粗虚线箭头表示对服务器进程的正常变迁。</p></li><li><p>细线箭头表示异常变迁。</p></li></ul><h1 id="第-6-章应用层">第 6 章应用层</h1><ul><li>应用层协议的特点<ol><li>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。<span style="background:rgba(205, 244, 105, 0.55)">应用层的具体内容就是规定应用进程在通信时所遵循的协议。</span></li><li>应用层的许多协议都是基于<font color="#245bdb">客户服务器</font>方式。客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用<font color="#245bdb">进程</font>。客户服务器方式所描述的是进程之间<font color="#245bdb">服务和被服务</font>的关系。客户是服务请求方，服务器是服务提供方。</li></ol></li></ul><h2 id="6-1-域名系统-DNS">6.1 域名系统 DNS</h2><ol><li><font color="#d83931">域名系统 DNS (Domain Name System)</font>：是因特网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。</li><li>早在 1983 年因特网就开始采用<strong>层次树状结构</strong>的命名方法，并使用<strong>分布式</strong>的域名系统。</li></ol><h2 id="6-2-文件传送协议">6.2 文件传送协议</h2><h2 id="6-3-远程终端协议-TELNET">6.3 远程终端协议 TELNET</h2><h2 id="6-4-万维网-WWW">6.4 万维网 WWW</h2><h2 id="6-5-电子邮件">6.5 电子邮件</h2><h2 id="6-6-动态主机配置协议-DHCP">6.6 动态主机配置协议 DHCP</h2><h2 id="6-7-简单网络管理协议-SNMP">6.7 简单网络管理协议 SNMP</h2><h2 id="6-8-应用进程跨越网络的通信">6.8 应用进程跨越网络的通信</h2><h1 id="第-7-章网络安全">第 7 章网络安全</h1><h2 id="7-1-网路安全问题概述">7.1 网路安全问题概述</h2><ul><li><p>计算机网络的通信通常面临以下四种威胁：</p><ol><li><strong>截获</strong> interception：从网络中<mark style="background: #FFB8EBA6;">窃听</mark>他人的通信内容。</li><li><strong>中断</strong> interruption：有意中断他人在网络上的通信。</li><li><strong>篡改</strong> modification：故意篡改网络上传送的报文。</li><li><strong>伪造</strong> fabrication：伪造信息在网络上传送。</li></ol><p>这四种威胁可以进一步划分为<font color="#c00000">主动攻击</font>和<font color="#c00000">被动攻击</font>两大类：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%AF%B9%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%BB%E5%8A%A8%E6%94%BB%E5%87%BB%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%94%BB%E5%87%BB-1.png" alt=""></p><ul><li><font color="#c00000">被动攻击</font>：攻击者只是观察和分析某一个协议数据单元 PDU 而不干扰信息流。</li><li><font color="#c00000">流量分析</font>：攻击者通过观察 PDU 的协议控制信息部分，了解正在通信的协议实体的地址和身份，研究 PDU 的长度和传输的频度，以便了解所交换数据的某种性质。</li><li><font color="#c00000">主动攻击</font>：攻击者对某个连接中通过的 PDU 进行各种处理。如有选择地更改、删除、延迟这些 PDU，还可以在稍后的时间将以前录下的 PDU 插入到这个连接（<font color="#c00000">重放攻击</font>）。甚至还可将合成的或者伪造的 PDU 送入到一个连接中去。</li></ul><p>从类型上看，主动攻击又可以进一步划分为三种：</p><ol><li><font color="#245bdb">更改报文流</font>：包括对通过链接的 PDU 的真实性、完整性和有序性的攻击。</li><li><font color="#245bdb">拒绝服务</font>（DoS: Denial of Service）：攻击者向因特网上的服务器不停地发送大量分组，是因特网或者服务器无法正常提供服务。</li><li><font color="#245bdb">伪造连接初始化</font>：攻击者重放以前被记录的合法连接初始化序列，或者伪造身份企图建立连接。<br>主动攻击可以采取适当的措施加以检测，但被动攻击通常检测不到。</li></ol></li><li><p>计算机网路通信安全的五个目标：</p><ol><li>防止析出报文内容</li><li>防止流量分析</li><li>检测更改报文流</li><li>检测拒绝服务</li><li>检测伪造初始化连接<br>对付被动攻击可采用数据加密技术，对付主动攻击要将<font color="#245bdb">加密技术</font>和<font color="#245bdb">鉴别技术</font>相结合。</li></ol></li><li><p><font color="#c00000">恶意程序</font> (rogue program)：一种特殊的主动攻击。主要包括：</p><ol><li><em>计算机病毒 (computer virus )</em>：会传染其他程序的程序，传染是通过修改其他程序来把自身或其变种复制进去完成的。</li><li><em>计算机蠕虫 (computer worm)</em>：通过网路的通信功能将自身从一个结点发送到另一个结点并自动启动运行的程序。</li><li><em>特洛伊木马 (Trojan horse)</em>：执行的功能与声称的功能不符合的恶意程序。</li><li><em>逻辑炸弹 (logic bomb)</em>：当运行环境满足一定条件时执行特殊功能。</li></ol></li><li><p>计算机网络安全的内容：</p><ol><li>保密性</li><li>安全协议的设计</li><li><font color="#c00000">访问控制</font> (access control)：也称作<font color="#c00000">存取控制</font>或者<font color="#c00000">接入控制</font>，对接入网络的权限加以控制，并规定每个用户的接入权限。</li></ol></li><li><p>一般的数据加密模型<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%B8%80%E8%88%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9E%8B.png" alt=""></p><ol><li>加密和解密用的密钥 K (key) 是一串秘密的字符串（即比特串）。</li><li>明文通过加密算法 E  和加密密钥 K  变成密文：Y = E<sub>K</sub>(X)</li><li>接收端利用解密算法 D 运算和解密密钥 K  解出明文 X。解密算法是加密算法的逆运算：D<sub>K</sub>(Y) = D<sub>K</sub>(E<sub>K</sub>(X)) = X</li><li>加密密钥和解密密钥可以一样，也可以不一样。</li><li>密钥通常由密钥中心提供。</li><li>当密钥需要向远地传送时，一定要通过另一个安全信道。</li></ol></li><li><p>一些重要概念</p><ol><li><font color="#245bdb">密码编码学</font> (cryptography) 是密码体制的设计学。</li><li><font color="#245bdb">密码分析学</font> (cryptanalysis) 则是在未知密钥的情况下从密文推演出明文或密钥的技术。</li><li>密码编码学与密码分析学合起来即为<font color="#245bdb">密码学 </font>(cryptology)。</li><li>如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为<font color="#245bdb">无条件安全的</font>，或称为<font color="#245bdb">理论上是不可破的</font>。</li><li>如果密码体制中的密码不能被可使用的计算资源破译，则这一密码体制称为<font color="#245bdb">在计算上是安全的</font>。</li><li>20 世纪 70 年代后期，美国的<font color="#245bdb">数据加密标准 DES</font> (Data Encryption Standard)和<font color="#245bdb">公钥密码体制 </font>(public key crypto-system) 称为近代密码学发展史上的两个重要里程碑。</li></ol></li></ul><h2 id="7-2-两类密码体制">7.2 两类密码体制</h2><h3 id="7-2-1-对称密钥密码体制">7.2.1 对称密钥密码体制</h3><ul><li><font color="#c00000">对称密钥密码体制</font>：加密密钥与解密密钥是相同的密码体制，又成为<font color="#c00000">对称密钥系统</font>。</li><li><font color="#245bdb">数据加密标准 DES</font> 属于对称密钥密码体制。</li><li>DES 是一种分组密码，加密前对明文进行分组，每组 64 位二进制数据。对每组数据进行加密后将各组密文串接起来得到整个密文。使用的密钥是 64 位（密钥长度 56 位+8 位奇偶校验）。</li><li>DES 的保密性仅取决于对密钥的保密，而算法是公开的。</li><li>DES 之后出现了<font color="#245bdb">国际数据加密算法 IDEA</font> (International Data Encryption Algorithm)，使用 128 位密钥，更加安全。</li></ul><h3 id="7-2-2-公钥密码体制">7.2.2 公钥密码体制</h3><ul><li><p><font color="#c00000">公钥密码体制</font>（又称为<font color="#c00000">公开密钥密码体制</font>）使用不同的加密密钥与解密密钥。是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p></li><li><p>产生原因：</p><ol><li>对称密钥密码体制的<font color="#245bdb">密钥分配</font>问题</li><li>对<font color="#245bdb">数字签名</font>的需求</li></ol></li><li><p><font color="#d83931">RSA 体制</font>：最著名的公钥密码体制，基于数论中的大数分解问题的体制。</p></li><li><p>在公钥密码体制中，加密密钥 PK (public key)即<font color="#d83931">公钥</font>，是向公众公开的，而解密密钥 SK (secret key) 即<font color="#d83931">私钥</font>或秘钥，则是需要保密的。</p></li><li><p>加密算法 E 和解密算法 D 也都是公开的。</p></li><li><p>虽然私钥 SK 是由公钥 PK 决定的，但却不能根据 PK 计算出 SK。</p></li><li><p>A 发给 B 的明文用 B 的公钥进行加密算法得到密文，B 收到后用自己的私钥进行解密算法得到明文。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6.png" alt="公钥密码体制"></p></li><li><p><mark style="background: #BBFABBA6;">任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量</mark>。在这方面，公钥密码体制并不具有比传统加密体制更加优越之处。</p></li><li><p>公钥加密算法<font color="#245bdb">开销</font>较大。</p></li><li><p>公钥还需要<font color="#245bdb">密钥分配协议</font>，具体的分配过程并不比采用传统加密方法时更简单。</p></li></ul><h2 id="7-3-数字签名">7.3 数字签名</h2><p>现实生活中，书信或者文件是根据亲笔签名或者印章来证明其真实性。<font color="#c00000">数字签名</font>就是用来对计算机网络中传送的文电进行真实性验证的。</p><ul><li><p>数字签名必须实现的三点功能：</p><ol><li><font color="#245bdb">报文鉴别</font>——接收者能够核实发送者对报文的签名（证明来源）；</li><li><font color="#245bdb">报文的完整性</font>——接收者不能伪造对报文的签名（防伪造）；</li><li><font color="#245bdb">不可否认</font>——发送者事后不能抵赖对报文的签名（防否认）。</li></ol></li><li><p>采用公钥算法比对称密钥算法更容易实现数字签名：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%9F%BA%E4%BA%8E%E5%85%AC%E9%92%A5%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%AE%9E%E7%8E%B0.png" alt="基于公钥的数字签名实现"></p><ul><li><p><font color="#245bdb">签名</font>与<font color="#245bdb">核实签名</font>：<br>A 利用自己的私钥对报文 X 进行 D 运算（D 本来是解密算法，还没有加密怎么先解密？D 运算只是得到了某种不可读的密文，在这里相当于加密算法），B 都到密文 Y 后用 A 的公钥进行 E 运算还原明文 Y。</p></li><li><p>这样的数字签名为什么具有上述的三点功能？</p><ol><li>A 的私钥只能自己拥有，除了 A 以外没有人能生成密文 Y，所以 B 就相信 Y 是 A 签名发送的。这是实现报文鉴别功能。</li><li>如果 Y 被篡改过，B 使用 A 的公钥进行 E 运算时就得不到可读的明文。这是实现报文的完整性功能。</li><li>若 A 想否认，则 B 可以将密文 Y 提供给第三方，第三方很容易就能通过 A 的公钥来证实这确实是 A 发送的。这是实现不可否认功能。<br>这些功能的实现都是基于 A 的私钥只能自己私有。</li></ol></li></ul></li></ul><p>上述过程只是对报文进行了签名，但是并没有对报文进行加密。任何人截获到 Y，都可以通过查阅 A 的公钥来获得明文内容。可做如下改进，同时实现<font color="#245bdb">私密通信</font>和<font color="#245bdb">数字签名</font>：</p><ul><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%85%B7%E6%9C%89%E4%BF%9D%E5%AF%86%E6%80%A7%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt="具有保密性的数字签名"></li></ul><h2 id="7-4-鉴别">7.4 鉴别</h2><ul><li>在信息的安全领域中，对付被动攻击的重要措施是加密，而对付主动攻击中的篡改和伪造则要用<font color="#c00000"><font color="#c00000">鉴别 </font></font>。</li><li><font color="#c00000">鉴别 (authentication)</font>是要验证通信的对方确实是自己所要通信的对象，而不是其他冒充者。</li><li>分类：<ol><li><font color="#c00000">报文鉴别</font>：所收到的报文的确是报文的发送者所发送的，而不是其他人伪造或篡改的。包含了端点鉴别和报文完整性的鉴别。</li><li><font color="#c00000">实体鉴别</font>：仅仅鉴别发送报文的实体。实体可以是一个人，也可以是一个进程（客户或者服务器）。这就是端点鉴别。</li></ol></li></ul><h3 id="7-4-1-报文鉴别">7.4.1 报文鉴别</h3><p>许多报文并不需要加密，但却需要数字签名，以便让报文的接收者能够<font color="#245bdb">鉴别报文的真伪</font>。</p><p>使用数字签名可以完成报文鉴别，但是对很长的报文进行数字签名会使计算机增加很大的负担（D 运算与 E 运算都需要花费很多的 CPU 时间）。</p><p>当我们传送<u>不需要加密的报文</u>时，应当使接收者能用很简单的方法鉴别报文的真伪。</p><ul><li><p><font color="#c00000">报文摘要 MD</font> (Message Digest)是进行报文鉴别的简单方法：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E7%94%A8%E6%8A%A5%E6%96%87%E6%91%98%E8%A6%81%E9%89%B4%E5%88%AB%E4%BF%9D%E6%B8%A9.png" alt="用报文摘要鉴别保温"><br>A 将报文 X 经过<font color="#245bdb">报文摘要算法</font>运算后得出很短的<font color="#245bdb">报文摘要 H</font>。然后然后用自己的<font color="#245bdb">私钥</font>对 H 进行 D 运算，即进行<font color="#245bdb">数字签名</font>。得出已签名的报文摘要 D (H)后，并将其追加在报文 X 后面发送给 B。B 收到报文后首先把已签名的 D (H) 和报文 X 分离。然后再做两件事：</p><ol><li>用 A 的公钥对 D (H) 进行 E 运算，得出报文摘要 H 。</li><li>对报文 X 进行报文摘要运算，看是否能够得出同样的报文摘要 H。如一样，就能以极高的概率断定收到的报文是 A 产生的。否则就不是。</li></ol></li><li><p>报文摘要的优点是：仅对短的多的定长报文摘要 H 进行数字签名即可完成对报文 X 的报文鉴别，所耗费的计算资源比直接对 X 进行数字签名要小得多。</p></li><li><p>报文摘要算法就是一种<font color="#245bdb">散列函数</font>，是精心选择的一种<font color="#245bdb">单向函数</font>，即很容易计算出一个长报文 X 的报文摘要 H，但不可能通过报文摘要 H 去反推长报文 X。而且对于特定的报文，报文摘要是唯一的，也就是说，攻击者不可能通过伪造另一个报文使其与 H 相同。</p></li><li><p>MD 5 算法可以对任意长的报文进行运算，然后得出 128 位的 MD 5 报文摘要代码。</p></li><li><p>另一种标准叫做<font color="#c00000">安全散列算法 SHA (Secure Hash Algorithm</font>)，与 MD 5 相似，但码长是 160 位，相对更安全，但也更慢。</p></li></ul><h3 id="7-4-2-实体鉴别">7.4.2 实体鉴别</h3><ul><li><p>实体鉴别与报文鉴别不同：<br>报文鉴别是对每一个收到的报文都要鉴别报文的发送者。<br>实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体<u>只需验证一次</u>。</p></li><li><p>最简单的实体鉴别过程：<font color="#245bdb">使用共享的对称密钥进行实体鉴别</font><br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%BB%85%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E4%BC%A0%E9%80%81%E9%89%B4%E5%88%AB%E5%AE%9E%E4%BD%93%E8%BA%AB%E4%BB%BD%E7%9A%84%E6%8A%A5%E6%96%87.png" alt="仅使用对称密钥传送鉴别实体身份的报文"></p><p>A 和 B 通过提前约定好的共享对称密钥 K<sub>AB</sub>来传送鉴别实体身份的报文。</p><p><em>漏洞</em>：入侵者 C 截获 A 发送的报文后，不需要破译，直接发送给 B，让 B 以为 C 就是 A，于是 B 就想 C 发送原本应该发送给 A 的报文。这就是<font color="#c00000">重发攻击 (replay attack)</font>。</p><p>为了对付重放攻击，可以使用<font color="#c00000">不重数 (nonce)</font>：一个不重复使用的大随机数，即“一次一数”。</p></li><li><p><font color="#245bdb">使用公钥体制进行不重数鉴别</font>：<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E4%BD%BF%E7%94%A8%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E8%BF%9B%E8%A1%8C%E4%B8%8D%E9%87%8D%E6%95%B0%E9%89%B4%E5%88%AB.png" alt="使用公钥密码体制进行不重数鉴别"><br>A 使用明文发送其身份 A 和一个不重数 R<sub>A</sub> 给 B，B 收到后，使用自己的私钥对不重数 R<sub>A</sub> 进行加密，同时发给 A 一个不重数 R<sub>B</sub>，A 用 B 的公钥进行解密，如果得到的不重数 R<sub>A</sub> 与自己发送的一致，就可以认为通信的对方是 B，然后 B 再对 A 进行身份确认。</p><p>虽然公钥密码体制不需要在用户之间秘密地分配共享密钥，但仍有受到攻击可能（“<font color="#245bdb">中间人攻击</font>”），由此可见，公钥的分配是一个非常重要的问题。</p></li></ul><h2 id="7-5-密钥分配">7.5 密钥分配</h2><ul><li><p>由于密码算法是公开的，网络的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——<font color="#c00000">密钥管理</font>。</p></li><li><p>密钥管理包括：密钥的产生、分配、注入、验证和使用。本节只讨论密钥的分配。</p></li><li><p>密钥分配是密钥管理中最大的问题。</p></li><li><p>密钥必须通过最安全的通路进行分配。</p></li><li><p>密钥分配方式：</p><ol><li><font color="#245bdb">网外分配</font>方式：派非常可靠的信使携带密钥分配给互相通信的各用户。<br>2.<font color="#245bdb"> 网内分配</font>方式：密钥自动分配。<br>但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再适用，而应采用网内分配方式。</li></ol></li></ul><h3 id="7-5-1-对称密钥的分配">7.5.1 对称密钥的分配</h3><ul><li><p>存在的两个问题：</p><ol><li>如果有 n 个用户彼此之间都需要通信，每两个人之间要共享一个密钥，共 n (n-1)/2 个，这个数字是 n<sup>2</sup>级别的，即所需要的密钥的数量非常大。</li><li>通信双方如何安全的得到共享密钥？</li></ol></li><li><p>目前常用的密钥分配方式是设立<font color="#c00000">密钥分配中心 KDC (Key Distribution Center)</font>。<br>KDC 是大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配一个会话密钥（仅使用一次）。<br>假设用户 A 和 B 都是 KDC 的登记用户，并已经在 KDC 的服务器上安装了各自和 KDC 进行通信的<font color="#c00000">主密钥（master key）</font>K<sub>A</sub> 和 <sub>KB</sub>。 “主密钥”可简称为“密钥”。<br><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/KDC%E5%AF%B9%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5%E7%9A%84%E5%88%86%E9%85%8D.png" alt="KDC对会话密钥的分配."><br>密钥分配的步骤：</p><ol><li>A 向 KDC 用明文发送报文说 A 和 B 想要通信。</li><li>KDC 随机产生“一次一密”的会话密钥 K<sub>AB</sub>供 A 和 B 使用，然后使用 A 的密钥 K<sub>A</sub>对报文进行加密。报文中还包含一个<font color="#245bdb">票据</font>，票据包含了 A 和 B 的身份以及会话密钥，不过这个票据是用 B 的密钥 K<sub>B</sub>加密的。</li><li>A 将报文解密后获得会话密钥，同时把票据转给 B，让 B 解密票据以获得会话密钥。</li></ol><ul><li>为防止重放攻击，KDC 还可在报文中加入<font color="#245bdb">时间戳</font>。</li><li>会话密钥 KAB 是一次性的，因此保密性较高。</li><li>KDC 分配给用户的密钥 KA 和 KB，应定期更换，以减少攻击者破译密钥的机会。</li></ul></li><li><p>目前最出名的密钥分配协议是 <font color="#245bdb">Kerberos V 5</font>。</p></li><li><p>Kerberos 既是鉴别协议，同时也是 KDC，它已经变得很普及，现在是互联网建议标准。</p></li><li><p>Kerberos 使用比 DES 更加安全的<font color="#245bdb">高级加密标准 AES </font>进行加密。</p></li><li><p>Kerberos 使用两个服务器：<font color="#245bdb">鉴别服务器 AS (Authentication Server)</font>、<font color="#245bdb">票据授予服务器 TGS (Ticket-Granting Server)</font>。</p></li><li><p>Kerberos 只用于客户与服务器之间的鉴别，而不用于人与人的鉴别。</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/Kerberos%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="Kerberos的工作原理"></p></li></ul><h3 id="7-5-2-公钥的分配">7.5.2 公钥的分配</h3><ul><li>在公钥密码体制中，如果每个用户都具有其他用户的公钥，就可实现安全通信。</li><li>但不能随意公布用户的公钥，因为无法防止假冒和欺骗。使用者也无法确定公钥的真正拥有者。</li><li>需要有一个值得信赖的机构——即<font color="#c00000">认证中心 CA </font>(Certification Authority)，来将公钥与其对应的实体（人或机器）进行<font color="#245bdb">绑定</font> (binding)。认证中心一般由政府出资建立。</li><li>每个实体都有 CA  发来的<font color="#245bdb">证书</font> (certificate)，里面有公钥及其拥有者的标识信息。此证书被 CA 进行了数字签名，是不可伪造的，可以信任。</li><li>证书是一种身份证明，用于解决信任问题。</li></ul><h2 id="7-6-网络层使用的安全协议">7.6 网络层使用的安全协议</h2><h3 id="7-6-1-网络层安全协议">7.6.1 网络层安全协议</h3><ul><li><p>IPsec 与安全关联 SA<br>IP 几乎不具备任何安全性，由于其在设计和实现上存在安全漏洞，使各种攻击有机可乘。<br>IPsec 提供了标准、健壮且包含广泛的机制保证 IP 层安全。</p><ul><li><font color="#c00000">IPsec</font> (IP security)：IP 安全协议的缩写。</li><li>IPsec 并不是一个单个的协议，而是能够在 IP 层提供互联网通信安全的协议族。</li><li><font color="#c00000">网络层保密</font>是指所有在 IP 数据报中的数据都是加密的。此外，网络层还应提供<font color="#c00000">源点鉴别</font> (source authentication)，即当目的站收到 IP 数据报是，能确信这是源 IP 地址的主机发来的。</li></ul></li><li><p>IP 安全数据报格式的两个协议</p><ol><li><font color="#c00000">鉴别首部</font> AH (Authentication Header) 协议</li><li><font color="#c00000">封装安全有效载荷</font> ESP (Encapsulation Security Payload) 协议<br>二者的区别是：AH 提供源点鉴别和数据完整性，但不能保密。ESP 更复杂，提供源点鉴别、数据完整性和保密。</li></ol></li><li><p><font color="#c00000"> 安全关联</font> SA (Security Association)：在使用 AH 或者 ESP 之前，先要从源主机到目的主机建立一条网络层的逻辑连接，称之为~。<br>这样，<span style="background:rgba(205, 244, 105, 0.55)">IPsec 就把传统的因特网无连接的网络层转换为具有逻辑连接的层</span>。<br>安全关联是一个<font color="#245bdb">单向连接</font>，如果进行双向的安全通信则需要建立两个安全关联。<br>一个安全关联 SA 由一个三元组唯一确定：</p><ol><li>安全协议的标识符（使用 AH 或者 ESP 协议）。</li><li>此单向连接的目的 IP 地址</li><li><font color="#c00000">安全参数索引 SPI</font> (Security Parameter Index)：一个 32 位的连接标记符。<br>对于一个给定的安全关联 SA，每一个 IPsec 数据报都有一个存放 SPI 的字段。通过此 SA 的所有数据报都使用同样的 SPI 值。</li></ol></li><li><p>鉴别首部协议 AH</p><ul><li>在使用鉴别首部协议 AH 时，把 AH 首部插在原数据报数据部分的前面，同时把 IP 首部中的协议字段置为 51。</li><li>在传输过程中，中间的路由器都不查看 AH 首部。当数据报到达终点时，目的主机才处理 AH 字段，以鉴别源点和检查数据报的完整性。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/AH%E9%A6%96%E9%83%A8%E5%9C%A8%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt=""></li><li>AH 首部具有以下字段：<br>(1) 下一个首部 (8 位)。标志紧接着本首部的下一个首部的类型（如 TCP 或 UDP）。<br>(2) 有效载荷长度 (8 位)，即鉴别数据字段的长度，以 32 位字为单位。<br>(3) 安全参数索引 SPI (32 位)。标志安全关联。<br>(4) 序号 (32 位)。鉴别数据字段的长度，以 32 位字为单位。<br>(5) 保留 (16 位)。为今后用。<br>(6) 鉴别数据 (可变)。为 32 位字的整数倍，它包含了<font color="#245bdb">经数字签名的报文摘要</font>。因此可用来鉴别源主机和检查 IP 数据报的完整性。</li></ul></li><li><p>封装安全有效载荷协议 ESP</p><ul><li>使用 ESP 时，IP 数据报首部的协议字段置为 50。当 IP 首部检查到协议字段是 50 时，就知道在 IP 首部后面紧接着的是 ESP 首部，同时在原 IP 数据报后面增加了两个字段，即 <font color="#245bdb">ESP 尾部</font>和 <font color="#245bdb">ESP 数据</font>。</li><li>在 ESP 首部中有标识一个安全关联的安全参数索引 SPI (32 位)和序号 (32 位)。</li><li>在 ESP 尾部中有下一个首部（8 位，作用和 AH 首部的一样）。ESP 尾部和原来数据报的数据部分一起进行加密，因此攻击者无法得知所使用的运输层协议。</li><li>ESP 的鉴别数据和 AH 中的鉴别数据的作用是一样的。因此，用 ESP 封装的数据报既有鉴别源站和检查数据报完整性的功能，又能提供保密。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E5%9C%A8IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%AD%E7%9A%84ESP%E5%90%84%E5%AD%97%E6%AE%B5.png" alt=""></li></ul></li></ul><h3 id="7-6-2-运输层安全协议">7.6.2 运输层安全协议</h3><ul><li><p><font color="#c00000"> 安全套接层 SSL 协议</font> (Secure Socket Layer)</p><ul><li><mark style="background: #BBFABBA6;"> SSL 可对万维网客户和服务器之间传送的数据进行加密和鉴别。</mark></li><li>SSL 的位置在应用层和运输层之间。<br>在发送方，SSL 接收应用层的数据（如 HTTP 或 IMAP 报文），对数据进行加密，然后把加了密的数据送往 TCP 套接字。在接收方，SSL 从 TCP 套接字读取数据，解密后把数据交给应用层。</li><li>SSL 不仅被所有常用的浏览器和万维网服务器所支持，而且也是<font color="#c00000">运输层安全协议 TLS</font> (Transport Layer Security)的基础。</li><li>SSL 提供以下三个功能：<ol><li><font color="#245bdb">SSL 服务器鉴别</font>：允许用户证实服务器的身份。</li><li><font color="#245bdb">加密的 SSL 会话</font>：客户和服务器交互的所有数据都在发送方加密，在接收方解密。</li><li><font color="#245bdb">SSL 客户鉴别</font>：允许服务器证实客户的身份。</li></ol></li></ul></li><li><p><font color="#c00000">安全电子交易协议 SET</font>(Secure Electronic Transaction)</p><ul><li>专为在因特网上进行安全信用卡交易的协议。</li><li>SET 的主要特点是：<ul><li>(1) SET 是专为与支付有关的报文进行加密的。</li><li>(2) SET 协议涉及到三方，即顾客、商家和商业银行。所有在这三方之间交互的敏感信息都被加密。</li><li>(3) SET 要求这三方都有证书。在 SET 交易中，商家看不见顾客传送给商业银行的信用卡号码。</li></ul></li><li>由于 SET 交易中客户端要使用专门的软件，且商家要支付的费用 SET 比 SSL 更贵，在竞争中失败了。</li></ul></li></ul><h3 id="7-6-3-应用层安全协议">7.6.3 应用层安全协议</h3><p>在应用层实现安全比较简单，介绍两种用于电子邮件的安全协议：</p><ol><li><p>PGP 协议</p><ul><li><font color="#c00000">PGP 协议</font> (Pretty Good Privacy)是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩技术。</li><li>PGP 并没有使用什么新的概念，它只是将现有的一些算法如 MD 5，RSA，以及 IDEA 等综合在一起而已。</li><li>虽然 PGP 已被广泛使用，但 PGP 并不是因特网的正式标准。</li></ul></li><li><p>PEM 协议</p><ul><li><font color="#c00000">PEM 协议</font>(Privacy Enhanced Mail) 是因特网的邮件加密建议标准。</li><li>PEM 的功能和 PGP 的差不多，都是对基于 RFC 822 的电子邮件进行加密和鉴别。</li><li>PEM 有比 PGP 更加完善的密钥管理机制。</li></ul></li></ol><h2 id="7-7-链路加密与端到端加密">7.7 链路加密与端到端加密</h2><h3 id="7-7-1-链路加密">7.7.1 链路加密</h3><ul><li>在采用链路加密的网络中，每条通信链路上的加密是独立实现的。</li><li>通常对每条链路使用不同的加密密钥。（图中 E 和 D 分别表示加密和解密运算）</li><li>当某条链路受到破坏时不会导致其他链路上传送的信息被析出。协议数据单元 PDU 中的协议控制信息和数据都被加密，因而掩盖了源点和终点信息。若在结点间保持连续的密文序列，则 PDU 的频度和长度也能得到掩盖。这样能够防止各种形式的流量分析。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E9%93%BE%E8%B7%AF%E5%8A%A0%E5%AF%86.png" alt="链路加密"></li><li>相邻结点之间具有相同的密钥，因而密钥管理易于实现。链路加密对用户是透明的。</li><li>报文在结点内是以明文的形式加密的，所以各个结点本身必须是安全的。一般认为网络的源点和终点在物理上是安全的，但所有的中间结点未必。</li><li>链路加密的最大缺点是在中间结点暴露了信息。</li><li>在网络互联的情况下，仅采用链路加密是不能实现通信安全的。</li><li>链路加密不适用于广播网络，因为它的通信子网没有明确的链路存在。</li></ul><p>7.7.2 端到端加密</p><ul><li>端到端加密是在源结点和目的结点中对传送的 PDU 进行加密和解密，报文的安全性不会因中间结点的不可靠而受到影响。</li><li><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86.png" alt=""></li><li>在端到端加密的情况下，PDU 的控制信息部分 (如源结点地址、目的结点地址、路由信息等)不能被加密，否则中间结点就不能正确选择路由。</li><li>端到端加密不仅适合互联网环境，同样适用于广播网。</li></ul><h2 id="7-8-防火墙">7.8 防火墙</h2><ul><li><p><font color="#c00000">防火墙</font> (firewall)是一种特殊编程的<u>路由器</u>，安装在一个网点和网络的其余部分之间，目的是实施<font color="#245bdb">访问控制策略</font>。</p></li><li><p>一般把防火墙里面的网络称为<font color="#c00000">可信的网络</font>，而把防火墙外的网络称为<font color="#c00000">不可信的网络</font>。</p></li><li><p>防火墙可用来解决内联网和外联网的安全问题</p></li><li><p><img src="https://blog-img-save.oss-cn-chengdu.aliyuncs.com/img/%E9%98%B2%E7%81%AB%E5%A2%99.png" alt=""></p></li><li><p>防火墙的功能有两个：<font color="#c00000">阻止</font>和<font color="#c00000">允许</font>。<br>阻止就是阻止某种类型的通信量通过防火墙（从外部网络到内部网络，或反过来）。允许的功能与阻止恰好相反。<br>防火墙必须能够识别通信量的各种类型。不过在大多数情况下防火墙的主要功能是“阻止”。</p></li><li><p>防火墙的分类：</p><ol><li><font color="#245bdb">网络级防火墙</font>——用来防止整个网络出现外来非法的入侵。<br>属于这类的有<font color="#245bdb">分组过滤</font>和<font color="#245bdb">授权服务器</font>。前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据，而后者则是检查用户的登录是否合法。</li><li><font color="#245bdb">应用级防火墙</font>——从应用程序来进行接入控制。<br>通常使用<font color="#245bdb">应用网关</font>或<font color="#245bdb">代理服务器</font>来区分各种应用。例如，可以只允许通过访问万维网的应用，而阻止 FTP 应用的通过。</li></ol></li></ul><h1 id="第-8-章因特网上的音频-视频服务">第 8 章因特网上的音频/视频服务</h1><h1 id="第-9-章无线网络">第 9 章无线网络</h1><h1 id="第-10-章下一代因特网">第 10 章下一代因特网</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> IP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
